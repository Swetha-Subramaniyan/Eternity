
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AddCustomer
 * 
 */
export type AddCustomer = $Result.DefaultSelection<Prisma.$AddCustomerPayload>
/**
 * Model AddCasting
 * 
 */
export type AddCasting = $Result.DefaultSelection<Prisma.$AddCastingPayload>
/**
 * Model AddFiling
 * 
 */
export type AddFiling = $Result.DefaultSelection<Prisma.$AddFilingPayload>
/**
 * Model AddSetting
 * 
 */
export type AddSetting = $Result.DefaultSelection<Prisma.$AddSettingPayload>
/**
 * Model AddBuffing
 * 
 */
export type AddBuffing = $Result.DefaultSelection<Prisma.$AddBuffingPayload>
/**
 * Model AddSupplierItem
 * 
 */
export type AddSupplierItem = $Result.DefaultSelection<Prisma.$AddSupplierItemPayload>
/**
 * Model AddPurchaseStock
 * 
 */
export type AddPurchaseStock = $Result.DefaultSelection<Prisma.$AddPurchaseStockPayload>
/**
 * Model CustomerTransaction
 * 
 */
export type CustomerTransaction = $Result.DefaultSelection<Prisma.$CustomerTransactionPayload>
/**
 * Model AddItem
 * 
 */
export type AddItem = $Result.DefaultSelection<Prisma.$AddItemPayload>
/**
 * Model AddTouch
 * 
 */
export type AddTouch = $Result.DefaultSelection<Prisma.$AddTouchPayload>
/**
 * Model CastingEntry
 * 
 */
export type CastingEntry = $Result.DefaultSelection<Prisma.$CastingEntryPayload>
/**
 * Model CastingItems
 * 
 */
export type CastingItems = $Result.DefaultSelection<Prisma.$CastingItemsPayload>
/**
 * Model CastiingTotalBalance
 * 
 */
export type CastiingTotalBalance = $Result.DefaultSelection<Prisma.$CastiingTotalBalancePayload>
/**
 * Model LotInfo
 * 
 */
export type LotInfo = $Result.DefaultSelection<Prisma.$LotInfoPayload>
/**
 * Model FilingEntry
 * 
 */
export type FilingEntry = $Result.DefaultSelection<Prisma.$FilingEntryPayload>
/**
 * Model LotFilingMapper
 * 
 */
export type LotFilingMapper = $Result.DefaultSelection<Prisma.$LotFilingMapperPayload>
/**
 * Model FilingItems
 * 
 */
export type FilingItems = $Result.DefaultSelection<Prisma.$FilingItemsPayload>
/**
 * Model FilingTotalBalance
 * 
 */
export type FilingTotalBalance = $Result.DefaultSelection<Prisma.$FilingTotalBalancePayload>
/**
 * Model FilingWastage
 * 
 */
export type FilingWastage = $Result.DefaultSelection<Prisma.$FilingWastagePayload>
/**
 * Model SettingEntry
 * 
 */
export type SettingEntry = $Result.DefaultSelection<Prisma.$SettingEntryPayload>
/**
 * Model SettingItems
 * 
 */
export type SettingItems = $Result.DefaultSelection<Prisma.$SettingItemsPayload>
/**
 * Model LotSettingMapper
 * 
 */
export type LotSettingMapper = $Result.DefaultSelection<Prisma.$LotSettingMapperPayload>
/**
 * Model SettingTotalBalance
 * 
 */
export type SettingTotalBalance = $Result.DefaultSelection<Prisma.$SettingTotalBalancePayload>
/**
 * Model SettingWastage
 * 
 */
export type SettingWastage = $Result.DefaultSelection<Prisma.$SettingWastagePayload>
/**
 * Model BuffingEntry
 * 
 */
export type BuffingEntry = $Result.DefaultSelection<Prisma.$BuffingEntryPayload>
/**
 * Model BuffingItems
 * 
 */
export type BuffingItems = $Result.DefaultSelection<Prisma.$BuffingItemsPayload>
/**
 * Model BuffingTotalBalance
 * 
 */
export type BuffingTotalBalance = $Result.DefaultSelection<Prisma.$BuffingTotalBalancePayload>
/**
 * Model LotBuffingMapper
 * 
 */
export type LotBuffingMapper = $Result.DefaultSelection<Prisma.$LotBuffingMapperPayload>
/**
 * Model BuffingWastage
 * 
 */
export type BuffingWastage = $Result.DefaultSelection<Prisma.$BuffingWastagePayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ITEMTYPE: {
  Gold: 'Gold',
  Silver: 'Silver'
};

export type ITEMTYPE = (typeof ITEMTYPE)[keyof typeof ITEMTYPE]


export const CASTINGENTRYTYPE: {
  Items: 'Items',
  ScrapItems: 'ScrapItems'
};

export type CASTINGENTRYTYPE = (typeof CASTINGENTRYTYPE)[keyof typeof CASTINGENTRYTYPE]


export const STONEOPTION: {
  WithStone: 'WithStone',
  WithoutStone: 'WithoutStone'
};

export type STONEOPTION = (typeof STONEOPTION)[keyof typeof STONEOPTION]

}

export type ITEMTYPE = $Enums.ITEMTYPE

export const ITEMTYPE: typeof $Enums.ITEMTYPE

export type CASTINGENTRYTYPE = $Enums.CASTINGENTRYTYPE

export const CASTINGENTRYTYPE: typeof $Enums.CASTINGENTRYTYPE

export type STONEOPTION = $Enums.STONEOPTION

export const STONEOPTION: typeof $Enums.STONEOPTION

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AddCustomers
 * const addCustomers = await prisma.addCustomer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AddCustomers
   * const addCustomers = await prisma.addCustomer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.addCustomer`: Exposes CRUD operations for the **AddCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddCustomers
    * const addCustomers = await prisma.addCustomer.findMany()
    * ```
    */
  get addCustomer(): Prisma.AddCustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addCasting`: Exposes CRUD operations for the **AddCasting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddCastings
    * const addCastings = await prisma.addCasting.findMany()
    * ```
    */
  get addCasting(): Prisma.AddCastingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addFiling`: Exposes CRUD operations for the **AddFiling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddFilings
    * const addFilings = await prisma.addFiling.findMany()
    * ```
    */
  get addFiling(): Prisma.AddFilingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addSetting`: Exposes CRUD operations for the **AddSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddSettings
    * const addSettings = await prisma.addSetting.findMany()
    * ```
    */
  get addSetting(): Prisma.AddSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addBuffing`: Exposes CRUD operations for the **AddBuffing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddBuffings
    * const addBuffings = await prisma.addBuffing.findMany()
    * ```
    */
  get addBuffing(): Prisma.AddBuffingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addSupplierItem`: Exposes CRUD operations for the **AddSupplierItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddSupplierItems
    * const addSupplierItems = await prisma.addSupplierItem.findMany()
    * ```
    */
  get addSupplierItem(): Prisma.AddSupplierItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addPurchaseStock`: Exposes CRUD operations for the **AddPurchaseStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddPurchaseStocks
    * const addPurchaseStocks = await prisma.addPurchaseStock.findMany()
    * ```
    */
  get addPurchaseStock(): Prisma.AddPurchaseStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerTransaction`: Exposes CRUD operations for the **CustomerTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerTransactions
    * const customerTransactions = await prisma.customerTransaction.findMany()
    * ```
    */
  get customerTransaction(): Prisma.CustomerTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addItem`: Exposes CRUD operations for the **AddItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddItems
    * const addItems = await prisma.addItem.findMany()
    * ```
    */
  get addItem(): Prisma.AddItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addTouch`: Exposes CRUD operations for the **AddTouch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddTouches
    * const addTouches = await prisma.addTouch.findMany()
    * ```
    */
  get addTouch(): Prisma.AddTouchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.castingEntry`: Exposes CRUD operations for the **CastingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CastingEntries
    * const castingEntries = await prisma.castingEntry.findMany()
    * ```
    */
  get castingEntry(): Prisma.CastingEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.castingItems`: Exposes CRUD operations for the **CastingItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CastingItems
    * const castingItems = await prisma.castingItems.findMany()
    * ```
    */
  get castingItems(): Prisma.CastingItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.castiingTotalBalance`: Exposes CRUD operations for the **CastiingTotalBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CastiingTotalBalances
    * const castiingTotalBalances = await prisma.castiingTotalBalance.findMany()
    * ```
    */
  get castiingTotalBalance(): Prisma.CastiingTotalBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lotInfo`: Exposes CRUD operations for the **LotInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotInfos
    * const lotInfos = await prisma.lotInfo.findMany()
    * ```
    */
  get lotInfo(): Prisma.LotInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filingEntry`: Exposes CRUD operations for the **FilingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilingEntries
    * const filingEntries = await prisma.filingEntry.findMany()
    * ```
    */
  get filingEntry(): Prisma.FilingEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lotFilingMapper`: Exposes CRUD operations for the **LotFilingMapper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotFilingMappers
    * const lotFilingMappers = await prisma.lotFilingMapper.findMany()
    * ```
    */
  get lotFilingMapper(): Prisma.LotFilingMapperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filingItems`: Exposes CRUD operations for the **FilingItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilingItems
    * const filingItems = await prisma.filingItems.findMany()
    * ```
    */
  get filingItems(): Prisma.FilingItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filingTotalBalance`: Exposes CRUD operations for the **FilingTotalBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilingTotalBalances
    * const filingTotalBalances = await prisma.filingTotalBalance.findMany()
    * ```
    */
  get filingTotalBalance(): Prisma.FilingTotalBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filingWastage`: Exposes CRUD operations for the **FilingWastage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilingWastages
    * const filingWastages = await prisma.filingWastage.findMany()
    * ```
    */
  get filingWastage(): Prisma.FilingWastageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settingEntry`: Exposes CRUD operations for the **SettingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingEntries
    * const settingEntries = await prisma.settingEntry.findMany()
    * ```
    */
  get settingEntry(): Prisma.SettingEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settingItems`: Exposes CRUD operations for the **SettingItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingItems
    * const settingItems = await prisma.settingItems.findMany()
    * ```
    */
  get settingItems(): Prisma.SettingItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lotSettingMapper`: Exposes CRUD operations for the **LotSettingMapper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotSettingMappers
    * const lotSettingMappers = await prisma.lotSettingMapper.findMany()
    * ```
    */
  get lotSettingMapper(): Prisma.LotSettingMapperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settingTotalBalance`: Exposes CRUD operations for the **SettingTotalBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingTotalBalances
    * const settingTotalBalances = await prisma.settingTotalBalance.findMany()
    * ```
    */
  get settingTotalBalance(): Prisma.SettingTotalBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settingWastage`: Exposes CRUD operations for the **SettingWastage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingWastages
    * const settingWastages = await prisma.settingWastage.findMany()
    * ```
    */
  get settingWastage(): Prisma.SettingWastageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buffingEntry`: Exposes CRUD operations for the **BuffingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuffingEntries
    * const buffingEntries = await prisma.buffingEntry.findMany()
    * ```
    */
  get buffingEntry(): Prisma.BuffingEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buffingItems`: Exposes CRUD operations for the **BuffingItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuffingItems
    * const buffingItems = await prisma.buffingItems.findMany()
    * ```
    */
  get buffingItems(): Prisma.BuffingItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buffingTotalBalance`: Exposes CRUD operations for the **BuffingTotalBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuffingTotalBalances
    * const buffingTotalBalances = await prisma.buffingTotalBalance.findMany()
    * ```
    */
  get buffingTotalBalance(): Prisma.BuffingTotalBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lotBuffingMapper`: Exposes CRUD operations for the **LotBuffingMapper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotBuffingMappers
    * const lotBuffingMappers = await prisma.lotBuffingMapper.findMany()
    * ```
    */
  get lotBuffingMapper(): Prisma.LotBuffingMapperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buffingWastage`: Exposes CRUD operations for the **BuffingWastage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuffingWastages
    * const buffingWastages = await prisma.buffingWastage.findMany()
    * ```
    */
  get buffingWastage(): Prisma.BuffingWastageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AddCustomer: 'AddCustomer',
    AddCasting: 'AddCasting',
    AddFiling: 'AddFiling',
    AddSetting: 'AddSetting',
    AddBuffing: 'AddBuffing',
    AddSupplierItem: 'AddSupplierItem',
    AddPurchaseStock: 'AddPurchaseStock',
    CustomerTransaction: 'CustomerTransaction',
    AddItem: 'AddItem',
    AddTouch: 'AddTouch',
    CastingEntry: 'CastingEntry',
    CastingItems: 'CastingItems',
    CastiingTotalBalance: 'CastiingTotalBalance',
    LotInfo: 'LotInfo',
    FilingEntry: 'FilingEntry',
    LotFilingMapper: 'LotFilingMapper',
    FilingItems: 'FilingItems',
    FilingTotalBalance: 'FilingTotalBalance',
    FilingWastage: 'FilingWastage',
    SettingEntry: 'SettingEntry',
    SettingItems: 'SettingItems',
    LotSettingMapper: 'LotSettingMapper',
    SettingTotalBalance: 'SettingTotalBalance',
    SettingWastage: 'SettingWastage',
    BuffingEntry: 'BuffingEntry',
    BuffingItems: 'BuffingItems',
    BuffingTotalBalance: 'BuffingTotalBalance',
    LotBuffingMapper: 'LotBuffingMapper',
    BuffingWastage: 'BuffingWastage',
    Stock: 'Stock'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "addCustomer" | "addCasting" | "addFiling" | "addSetting" | "addBuffing" | "addSupplierItem" | "addPurchaseStock" | "customerTransaction" | "addItem" | "addTouch" | "castingEntry" | "castingItems" | "castiingTotalBalance" | "lotInfo" | "filingEntry" | "lotFilingMapper" | "filingItems" | "filingTotalBalance" | "filingWastage" | "settingEntry" | "settingItems" | "lotSettingMapper" | "settingTotalBalance" | "settingWastage" | "buffingEntry" | "buffingItems" | "buffingTotalBalance" | "lotBuffingMapper" | "buffingWastage" | "stock"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AddCustomer: {
        payload: Prisma.$AddCustomerPayload<ExtArgs>
        fields: Prisma.AddCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          findFirst: {
            args: Prisma.AddCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          findMany: {
            args: Prisma.AddCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>[]
          }
          create: {
            args: Prisma.AddCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          createMany: {
            args: Prisma.AddCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          update: {
            args: Prisma.AddCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          deleteMany: {
            args: Prisma.AddCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCustomerPayload>
          }
          aggregate: {
            args: Prisma.AddCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddCustomer>
          }
          groupBy: {
            args: Prisma.AddCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<AddCustomerCountAggregateOutputType> | number
          }
        }
      }
      AddCasting: {
        payload: Prisma.$AddCastingPayload<ExtArgs>
        fields: Prisma.AddCastingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddCastingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddCastingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          findFirst: {
            args: Prisma.AddCastingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddCastingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          findMany: {
            args: Prisma.AddCastingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>[]
          }
          create: {
            args: Prisma.AddCastingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          createMany: {
            args: Prisma.AddCastingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddCastingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          update: {
            args: Prisma.AddCastingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          deleteMany: {
            args: Prisma.AddCastingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddCastingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddCastingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddCastingPayload>
          }
          aggregate: {
            args: Prisma.AddCastingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddCasting>
          }
          groupBy: {
            args: Prisma.AddCastingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddCastingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddCastingCountArgs<ExtArgs>
            result: $Utils.Optional<AddCastingCountAggregateOutputType> | number
          }
        }
      }
      AddFiling: {
        payload: Prisma.$AddFilingPayload<ExtArgs>
        fields: Prisma.AddFilingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddFilingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddFilingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          findFirst: {
            args: Prisma.AddFilingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddFilingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          findMany: {
            args: Prisma.AddFilingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>[]
          }
          create: {
            args: Prisma.AddFilingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          createMany: {
            args: Prisma.AddFilingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddFilingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          update: {
            args: Prisma.AddFilingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          deleteMany: {
            args: Prisma.AddFilingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddFilingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddFilingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddFilingPayload>
          }
          aggregate: {
            args: Prisma.AddFilingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddFiling>
          }
          groupBy: {
            args: Prisma.AddFilingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddFilingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddFilingCountArgs<ExtArgs>
            result: $Utils.Optional<AddFilingCountAggregateOutputType> | number
          }
        }
      }
      AddSetting: {
        payload: Prisma.$AddSettingPayload<ExtArgs>
        fields: Prisma.AddSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          findFirst: {
            args: Prisma.AddSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          findMany: {
            args: Prisma.AddSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>[]
          }
          create: {
            args: Prisma.AddSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          createMany: {
            args: Prisma.AddSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          update: {
            args: Prisma.AddSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          deleteMany: {
            args: Prisma.AddSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSettingPayload>
          }
          aggregate: {
            args: Prisma.AddSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddSetting>
          }
          groupBy: {
            args: Prisma.AddSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddSettingCountArgs<ExtArgs>
            result: $Utils.Optional<AddSettingCountAggregateOutputType> | number
          }
        }
      }
      AddBuffing: {
        payload: Prisma.$AddBuffingPayload<ExtArgs>
        fields: Prisma.AddBuffingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddBuffingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddBuffingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          findFirst: {
            args: Prisma.AddBuffingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddBuffingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          findMany: {
            args: Prisma.AddBuffingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>[]
          }
          create: {
            args: Prisma.AddBuffingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          createMany: {
            args: Prisma.AddBuffingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddBuffingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          update: {
            args: Prisma.AddBuffingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          deleteMany: {
            args: Prisma.AddBuffingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddBuffingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddBuffingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddBuffingPayload>
          }
          aggregate: {
            args: Prisma.AddBuffingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddBuffing>
          }
          groupBy: {
            args: Prisma.AddBuffingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddBuffingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddBuffingCountArgs<ExtArgs>
            result: $Utils.Optional<AddBuffingCountAggregateOutputType> | number
          }
        }
      }
      AddSupplierItem: {
        payload: Prisma.$AddSupplierItemPayload<ExtArgs>
        fields: Prisma.AddSupplierItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddSupplierItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddSupplierItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          findFirst: {
            args: Prisma.AddSupplierItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddSupplierItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          findMany: {
            args: Prisma.AddSupplierItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>[]
          }
          create: {
            args: Prisma.AddSupplierItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          createMany: {
            args: Prisma.AddSupplierItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddSupplierItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          update: {
            args: Prisma.AddSupplierItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          deleteMany: {
            args: Prisma.AddSupplierItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddSupplierItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddSupplierItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddSupplierItemPayload>
          }
          aggregate: {
            args: Prisma.AddSupplierItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddSupplierItem>
          }
          groupBy: {
            args: Prisma.AddSupplierItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddSupplierItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddSupplierItemCountArgs<ExtArgs>
            result: $Utils.Optional<AddSupplierItemCountAggregateOutputType> | number
          }
        }
      }
      AddPurchaseStock: {
        payload: Prisma.$AddPurchaseStockPayload<ExtArgs>
        fields: Prisma.AddPurchaseStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddPurchaseStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddPurchaseStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          findFirst: {
            args: Prisma.AddPurchaseStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddPurchaseStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          findMany: {
            args: Prisma.AddPurchaseStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>[]
          }
          create: {
            args: Prisma.AddPurchaseStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          createMany: {
            args: Prisma.AddPurchaseStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddPurchaseStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          update: {
            args: Prisma.AddPurchaseStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          deleteMany: {
            args: Prisma.AddPurchaseStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddPurchaseStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddPurchaseStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddPurchaseStockPayload>
          }
          aggregate: {
            args: Prisma.AddPurchaseStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddPurchaseStock>
          }
          groupBy: {
            args: Prisma.AddPurchaseStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddPurchaseStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddPurchaseStockCountArgs<ExtArgs>
            result: $Utils.Optional<AddPurchaseStockCountAggregateOutputType> | number
          }
        }
      }
      CustomerTransaction: {
        payload: Prisma.$CustomerTransactionPayload<ExtArgs>
        fields: Prisma.CustomerTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          findFirst: {
            args: Prisma.CustomerTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          findMany: {
            args: Prisma.CustomerTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>[]
          }
          create: {
            args: Prisma.CustomerTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          createMany: {
            args: Prisma.CustomerTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          update: {
            args: Prisma.CustomerTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CustomerTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionPayload>
          }
          aggregate: {
            args: Prisma.CustomerTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerTransaction>
          }
          groupBy: {
            args: Prisma.CustomerTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerTransactionCountAggregateOutputType> | number
          }
        }
      }
      AddItem: {
        payload: Prisma.$AddItemPayload<ExtArgs>
        fields: Prisma.AddItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          findFirst: {
            args: Prisma.AddItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          findMany: {
            args: Prisma.AddItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>[]
          }
          create: {
            args: Prisma.AddItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          createMany: {
            args: Prisma.AddItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          update: {
            args: Prisma.AddItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          deleteMany: {
            args: Prisma.AddItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddItemPayload>
          }
          aggregate: {
            args: Prisma.AddItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddItem>
          }
          groupBy: {
            args: Prisma.AddItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddItemCountArgs<ExtArgs>
            result: $Utils.Optional<AddItemCountAggregateOutputType> | number
          }
        }
      }
      AddTouch: {
        payload: Prisma.$AddTouchPayload<ExtArgs>
        fields: Prisma.AddTouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddTouchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddTouchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          findFirst: {
            args: Prisma.AddTouchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddTouchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          findMany: {
            args: Prisma.AddTouchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>[]
          }
          create: {
            args: Prisma.AddTouchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          createMany: {
            args: Prisma.AddTouchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddTouchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          update: {
            args: Prisma.AddTouchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          deleteMany: {
            args: Prisma.AddTouchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddTouchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddTouchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddTouchPayload>
          }
          aggregate: {
            args: Prisma.AddTouchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddTouch>
          }
          groupBy: {
            args: Prisma.AddTouchGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddTouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddTouchCountArgs<ExtArgs>
            result: $Utils.Optional<AddTouchCountAggregateOutputType> | number
          }
        }
      }
      CastingEntry: {
        payload: Prisma.$CastingEntryPayload<ExtArgs>
        fields: Prisma.CastingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CastingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CastingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          findFirst: {
            args: Prisma.CastingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CastingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          findMany: {
            args: Prisma.CastingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>[]
          }
          create: {
            args: Prisma.CastingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          createMany: {
            args: Prisma.CastingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CastingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          update: {
            args: Prisma.CastingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          deleteMany: {
            args: Prisma.CastingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CastingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CastingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingEntryPayload>
          }
          aggregate: {
            args: Prisma.CastingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCastingEntry>
          }
          groupBy: {
            args: Prisma.CastingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CastingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CastingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CastingEntryCountAggregateOutputType> | number
          }
        }
      }
      CastingItems: {
        payload: Prisma.$CastingItemsPayload<ExtArgs>
        fields: Prisma.CastingItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CastingItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CastingItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          findFirst: {
            args: Prisma.CastingItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CastingItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          findMany: {
            args: Prisma.CastingItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>[]
          }
          create: {
            args: Prisma.CastingItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          createMany: {
            args: Prisma.CastingItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CastingItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          update: {
            args: Prisma.CastingItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          deleteMany: {
            args: Prisma.CastingItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CastingItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CastingItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastingItemsPayload>
          }
          aggregate: {
            args: Prisma.CastingItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCastingItems>
          }
          groupBy: {
            args: Prisma.CastingItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CastingItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CastingItemsCountArgs<ExtArgs>
            result: $Utils.Optional<CastingItemsCountAggregateOutputType> | number
          }
        }
      }
      CastiingTotalBalance: {
        payload: Prisma.$CastiingTotalBalancePayload<ExtArgs>
        fields: Prisma.CastiingTotalBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CastiingTotalBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CastiingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          findFirst: {
            args: Prisma.CastiingTotalBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CastiingTotalBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          findMany: {
            args: Prisma.CastiingTotalBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>[]
          }
          create: {
            args: Prisma.CastiingTotalBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          createMany: {
            args: Prisma.CastiingTotalBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CastiingTotalBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          update: {
            args: Prisma.CastiingTotalBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          deleteMany: {
            args: Prisma.CastiingTotalBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CastiingTotalBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CastiingTotalBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CastiingTotalBalancePayload>
          }
          aggregate: {
            args: Prisma.CastiingTotalBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCastiingTotalBalance>
          }
          groupBy: {
            args: Prisma.CastiingTotalBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CastiingTotalBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CastiingTotalBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<CastiingTotalBalanceCountAggregateOutputType> | number
          }
        }
      }
      LotInfo: {
        payload: Prisma.$LotInfoPayload<ExtArgs>
        fields: Prisma.LotInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          findFirst: {
            args: Prisma.LotInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          findMany: {
            args: Prisma.LotInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>[]
          }
          create: {
            args: Prisma.LotInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          createMany: {
            args: Prisma.LotInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LotInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          update: {
            args: Prisma.LotInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          deleteMany: {
            args: Prisma.LotInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotInfoPayload>
          }
          aggregate: {
            args: Prisma.LotInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotInfo>
          }
          groupBy: {
            args: Prisma.LotInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotInfoCountArgs<ExtArgs>
            result: $Utils.Optional<LotInfoCountAggregateOutputType> | number
          }
        }
      }
      FilingEntry: {
        payload: Prisma.$FilingEntryPayload<ExtArgs>
        fields: Prisma.FilingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          findFirst: {
            args: Prisma.FilingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          findMany: {
            args: Prisma.FilingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>[]
          }
          create: {
            args: Prisma.FilingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          createMany: {
            args: Prisma.FilingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          update: {
            args: Prisma.FilingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          deleteMany: {
            args: Prisma.FilingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingEntryPayload>
          }
          aggregate: {
            args: Prisma.FilingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilingEntry>
          }
          groupBy: {
            args: Prisma.FilingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<FilingEntryCountAggregateOutputType> | number
          }
        }
      }
      LotFilingMapper: {
        payload: Prisma.$LotFilingMapperPayload<ExtArgs>
        fields: Prisma.LotFilingMapperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotFilingMapperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotFilingMapperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          findFirst: {
            args: Prisma.LotFilingMapperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotFilingMapperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          findMany: {
            args: Prisma.LotFilingMapperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>[]
          }
          create: {
            args: Prisma.LotFilingMapperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          createMany: {
            args: Prisma.LotFilingMapperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LotFilingMapperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          update: {
            args: Prisma.LotFilingMapperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          deleteMany: {
            args: Prisma.LotFilingMapperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotFilingMapperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotFilingMapperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotFilingMapperPayload>
          }
          aggregate: {
            args: Prisma.LotFilingMapperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotFilingMapper>
          }
          groupBy: {
            args: Prisma.LotFilingMapperGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotFilingMapperGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotFilingMapperCountArgs<ExtArgs>
            result: $Utils.Optional<LotFilingMapperCountAggregateOutputType> | number
          }
        }
      }
      FilingItems: {
        payload: Prisma.$FilingItemsPayload<ExtArgs>
        fields: Prisma.FilingItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilingItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilingItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          findFirst: {
            args: Prisma.FilingItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilingItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          findMany: {
            args: Prisma.FilingItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>[]
          }
          create: {
            args: Prisma.FilingItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          createMany: {
            args: Prisma.FilingItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilingItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          update: {
            args: Prisma.FilingItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          deleteMany: {
            args: Prisma.FilingItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilingItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilingItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingItemsPayload>
          }
          aggregate: {
            args: Prisma.FilingItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilingItems>
          }
          groupBy: {
            args: Prisma.FilingItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilingItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilingItemsCountArgs<ExtArgs>
            result: $Utils.Optional<FilingItemsCountAggregateOutputType> | number
          }
        }
      }
      FilingTotalBalance: {
        payload: Prisma.$FilingTotalBalancePayload<ExtArgs>
        fields: Prisma.FilingTotalBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilingTotalBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          findFirst: {
            args: Prisma.FilingTotalBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilingTotalBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          findMany: {
            args: Prisma.FilingTotalBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>[]
          }
          create: {
            args: Prisma.FilingTotalBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          createMany: {
            args: Prisma.FilingTotalBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilingTotalBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          update: {
            args: Prisma.FilingTotalBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          deleteMany: {
            args: Prisma.FilingTotalBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilingTotalBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilingTotalBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingTotalBalancePayload>
          }
          aggregate: {
            args: Prisma.FilingTotalBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilingTotalBalance>
          }
          groupBy: {
            args: Prisma.FilingTotalBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilingTotalBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilingTotalBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<FilingTotalBalanceCountAggregateOutputType> | number
          }
        }
      }
      FilingWastage: {
        payload: Prisma.$FilingWastagePayload<ExtArgs>
        fields: Prisma.FilingWastageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilingWastageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilingWastageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          findFirst: {
            args: Prisma.FilingWastageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilingWastageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          findMany: {
            args: Prisma.FilingWastageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>[]
          }
          create: {
            args: Prisma.FilingWastageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          createMany: {
            args: Prisma.FilingWastageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilingWastageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          update: {
            args: Prisma.FilingWastageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          deleteMany: {
            args: Prisma.FilingWastageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilingWastageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilingWastageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilingWastagePayload>
          }
          aggregate: {
            args: Prisma.FilingWastageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilingWastage>
          }
          groupBy: {
            args: Prisma.FilingWastageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilingWastageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilingWastageCountArgs<ExtArgs>
            result: $Utils.Optional<FilingWastageCountAggregateOutputType> | number
          }
        }
      }
      SettingEntry: {
        payload: Prisma.$SettingEntryPayload<ExtArgs>
        fields: Prisma.SettingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          findFirst: {
            args: Prisma.SettingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          findMany: {
            args: Prisma.SettingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>[]
          }
          create: {
            args: Prisma.SettingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          createMany: {
            args: Prisma.SettingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          update: {
            args: Prisma.SettingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          deleteMany: {
            args: Prisma.SettingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingEntryPayload>
          }
          aggregate: {
            args: Prisma.SettingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingEntry>
          }
          groupBy: {
            args: Prisma.SettingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<SettingEntryCountAggregateOutputType> | number
          }
        }
      }
      SettingItems: {
        payload: Prisma.$SettingItemsPayload<ExtArgs>
        fields: Prisma.SettingItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          findFirst: {
            args: Prisma.SettingItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          findMany: {
            args: Prisma.SettingItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>[]
          }
          create: {
            args: Prisma.SettingItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          createMany: {
            args: Prisma.SettingItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          update: {
            args: Prisma.SettingItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          deleteMany: {
            args: Prisma.SettingItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingItemsPayload>
          }
          aggregate: {
            args: Prisma.SettingItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingItems>
          }
          groupBy: {
            args: Prisma.SettingItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingItemsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingItemsCountAggregateOutputType> | number
          }
        }
      }
      LotSettingMapper: {
        payload: Prisma.$LotSettingMapperPayload<ExtArgs>
        fields: Prisma.LotSettingMapperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotSettingMapperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotSettingMapperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          findFirst: {
            args: Prisma.LotSettingMapperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotSettingMapperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          findMany: {
            args: Prisma.LotSettingMapperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>[]
          }
          create: {
            args: Prisma.LotSettingMapperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          createMany: {
            args: Prisma.LotSettingMapperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LotSettingMapperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          update: {
            args: Prisma.LotSettingMapperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          deleteMany: {
            args: Prisma.LotSettingMapperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotSettingMapperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotSettingMapperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotSettingMapperPayload>
          }
          aggregate: {
            args: Prisma.LotSettingMapperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotSettingMapper>
          }
          groupBy: {
            args: Prisma.LotSettingMapperGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotSettingMapperGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotSettingMapperCountArgs<ExtArgs>
            result: $Utils.Optional<LotSettingMapperCountAggregateOutputType> | number
          }
        }
      }
      SettingTotalBalance: {
        payload: Prisma.$SettingTotalBalancePayload<ExtArgs>
        fields: Prisma.SettingTotalBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingTotalBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          findFirst: {
            args: Prisma.SettingTotalBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingTotalBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          findMany: {
            args: Prisma.SettingTotalBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>[]
          }
          create: {
            args: Prisma.SettingTotalBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          createMany: {
            args: Prisma.SettingTotalBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingTotalBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          update: {
            args: Prisma.SettingTotalBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          deleteMany: {
            args: Prisma.SettingTotalBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingTotalBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingTotalBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingTotalBalancePayload>
          }
          aggregate: {
            args: Prisma.SettingTotalBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingTotalBalance>
          }
          groupBy: {
            args: Prisma.SettingTotalBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingTotalBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingTotalBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<SettingTotalBalanceCountAggregateOutputType> | number
          }
        }
      }
      SettingWastage: {
        payload: Prisma.$SettingWastagePayload<ExtArgs>
        fields: Prisma.SettingWastageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingWastageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingWastageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          findFirst: {
            args: Prisma.SettingWastageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingWastageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          findMany: {
            args: Prisma.SettingWastageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>[]
          }
          create: {
            args: Prisma.SettingWastageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          createMany: {
            args: Prisma.SettingWastageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingWastageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          update: {
            args: Prisma.SettingWastageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          deleteMany: {
            args: Prisma.SettingWastageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingWastageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingWastageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingWastagePayload>
          }
          aggregate: {
            args: Prisma.SettingWastageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingWastage>
          }
          groupBy: {
            args: Prisma.SettingWastageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingWastageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingWastageCountArgs<ExtArgs>
            result: $Utils.Optional<SettingWastageCountAggregateOutputType> | number
          }
        }
      }
      BuffingEntry: {
        payload: Prisma.$BuffingEntryPayload<ExtArgs>
        fields: Prisma.BuffingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuffingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuffingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          findFirst: {
            args: Prisma.BuffingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuffingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          findMany: {
            args: Prisma.BuffingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>[]
          }
          create: {
            args: Prisma.BuffingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          createMany: {
            args: Prisma.BuffingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuffingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          update: {
            args: Prisma.BuffingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          deleteMany: {
            args: Prisma.BuffingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuffingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuffingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingEntryPayload>
          }
          aggregate: {
            args: Prisma.BuffingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuffingEntry>
          }
          groupBy: {
            args: Prisma.BuffingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuffingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuffingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<BuffingEntryCountAggregateOutputType> | number
          }
        }
      }
      BuffingItems: {
        payload: Prisma.$BuffingItemsPayload<ExtArgs>
        fields: Prisma.BuffingItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuffingItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuffingItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          findFirst: {
            args: Prisma.BuffingItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuffingItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          findMany: {
            args: Prisma.BuffingItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>[]
          }
          create: {
            args: Prisma.BuffingItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          createMany: {
            args: Prisma.BuffingItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuffingItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          update: {
            args: Prisma.BuffingItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          deleteMany: {
            args: Prisma.BuffingItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuffingItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuffingItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingItemsPayload>
          }
          aggregate: {
            args: Prisma.BuffingItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuffingItems>
          }
          groupBy: {
            args: Prisma.BuffingItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuffingItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuffingItemsCountArgs<ExtArgs>
            result: $Utils.Optional<BuffingItemsCountAggregateOutputType> | number
          }
        }
      }
      BuffingTotalBalance: {
        payload: Prisma.$BuffingTotalBalancePayload<ExtArgs>
        fields: Prisma.BuffingTotalBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuffingTotalBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuffingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          findFirst: {
            args: Prisma.BuffingTotalBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuffingTotalBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          findMany: {
            args: Prisma.BuffingTotalBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>[]
          }
          create: {
            args: Prisma.BuffingTotalBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          createMany: {
            args: Prisma.BuffingTotalBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuffingTotalBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          update: {
            args: Prisma.BuffingTotalBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          deleteMany: {
            args: Prisma.BuffingTotalBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuffingTotalBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuffingTotalBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingTotalBalancePayload>
          }
          aggregate: {
            args: Prisma.BuffingTotalBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuffingTotalBalance>
          }
          groupBy: {
            args: Prisma.BuffingTotalBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuffingTotalBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuffingTotalBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BuffingTotalBalanceCountAggregateOutputType> | number
          }
        }
      }
      LotBuffingMapper: {
        payload: Prisma.$LotBuffingMapperPayload<ExtArgs>
        fields: Prisma.LotBuffingMapperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotBuffingMapperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotBuffingMapperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          findFirst: {
            args: Prisma.LotBuffingMapperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotBuffingMapperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          findMany: {
            args: Prisma.LotBuffingMapperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>[]
          }
          create: {
            args: Prisma.LotBuffingMapperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          createMany: {
            args: Prisma.LotBuffingMapperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LotBuffingMapperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          update: {
            args: Prisma.LotBuffingMapperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          deleteMany: {
            args: Prisma.LotBuffingMapperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotBuffingMapperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotBuffingMapperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBuffingMapperPayload>
          }
          aggregate: {
            args: Prisma.LotBuffingMapperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotBuffingMapper>
          }
          groupBy: {
            args: Prisma.LotBuffingMapperGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotBuffingMapperGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotBuffingMapperCountArgs<ExtArgs>
            result: $Utils.Optional<LotBuffingMapperCountAggregateOutputType> | number
          }
        }
      }
      BuffingWastage: {
        payload: Prisma.$BuffingWastagePayload<ExtArgs>
        fields: Prisma.BuffingWastageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuffingWastageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuffingWastageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          findFirst: {
            args: Prisma.BuffingWastageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuffingWastageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          findMany: {
            args: Prisma.BuffingWastageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>[]
          }
          create: {
            args: Prisma.BuffingWastageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          createMany: {
            args: Prisma.BuffingWastageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuffingWastageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          update: {
            args: Prisma.BuffingWastageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          deleteMany: {
            args: Prisma.BuffingWastageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuffingWastageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuffingWastageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuffingWastagePayload>
          }
          aggregate: {
            args: Prisma.BuffingWastageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuffingWastage>
          }
          groupBy: {
            args: Prisma.BuffingWastageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuffingWastageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuffingWastageCountArgs<ExtArgs>
            result: $Utils.Optional<BuffingWastageCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    addCustomer?: AddCustomerOmit
    addCasting?: AddCastingOmit
    addFiling?: AddFilingOmit
    addSetting?: AddSettingOmit
    addBuffing?: AddBuffingOmit
    addSupplierItem?: AddSupplierItemOmit
    addPurchaseStock?: AddPurchaseStockOmit
    customerTransaction?: CustomerTransactionOmit
    addItem?: AddItemOmit
    addTouch?: AddTouchOmit
    castingEntry?: CastingEntryOmit
    castingItems?: CastingItemsOmit
    castiingTotalBalance?: CastiingTotalBalanceOmit
    lotInfo?: LotInfoOmit
    filingEntry?: FilingEntryOmit
    lotFilingMapper?: LotFilingMapperOmit
    filingItems?: FilingItemsOmit
    filingTotalBalance?: FilingTotalBalanceOmit
    filingWastage?: FilingWastageOmit
    settingEntry?: SettingEntryOmit
    settingItems?: SettingItemsOmit
    lotSettingMapper?: LotSettingMapperOmit
    settingTotalBalance?: SettingTotalBalanceOmit
    settingWastage?: SettingWastageOmit
    buffingEntry?: BuffingEntryOmit
    buffingItems?: BuffingItemsOmit
    buffingTotalBalance?: BuffingTotalBalanceOmit
    lotBuffingMapper?: LotBuffingMapperOmit
    buffingWastage?: BuffingWastageOmit
    stock?: StockOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AddCustomerCountOutputType
   */

  export type AddCustomerCountOutputType = {
    transactions: number
  }

  export type AddCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AddCustomerCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * AddCustomerCountOutputType without action
   */
  export type AddCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomerCountOutputType
     */
    select?: AddCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddCustomerCountOutputType without action
   */
  export type AddCustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTransactionWhereInput
  }


  /**
   * Count Type AddCastingCountOutputType
   */

  export type AddCastingCountOutputType = {
    entries: number
    castingitems: number
    stock: number
  }

  export type AddCastingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | AddCastingCountOutputTypeCountEntriesArgs
    castingitems?: boolean | AddCastingCountOutputTypeCountCastingitemsArgs
    stock?: boolean | AddCastingCountOutputTypeCountStockArgs
  }

  // Custom InputTypes
  /**
   * AddCastingCountOutputType without action
   */
  export type AddCastingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCastingCountOutputType
     */
    select?: AddCastingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddCastingCountOutputType without action
   */
  export type AddCastingCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingEntryWhereInput
  }

  /**
   * AddCastingCountOutputType without action
   */
  export type AddCastingCountOutputTypeCountCastingitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingItemsWhereInput
  }

  /**
   * AddCastingCountOutputType without action
   */
  export type AddCastingCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }


  /**
   * Count Type AddFilingCountOutputType
   */

  export type AddFilingCountOutputType = {
    filingWastages: number
    filings: number
    lotInfo: number
    lotFilingMapper: number
  }

  export type AddFilingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingWastages?: boolean | AddFilingCountOutputTypeCountFilingWastagesArgs
    filings?: boolean | AddFilingCountOutputTypeCountFilingsArgs
    lotInfo?: boolean | AddFilingCountOutputTypeCountLotInfoArgs
    lotFilingMapper?: boolean | AddFilingCountOutputTypeCountLotFilingMapperArgs
  }

  // Custom InputTypes
  /**
   * AddFilingCountOutputType without action
   */
  export type AddFilingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFilingCountOutputType
     */
    select?: AddFilingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddFilingCountOutputType without action
   */
  export type AddFilingCountOutputTypeCountFilingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingWastageWhereInput
  }

  /**
   * AddFilingCountOutputType without action
   */
  export type AddFilingCountOutputTypeCountFilingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingEntryWhereInput
  }

  /**
   * AddFilingCountOutputType without action
   */
  export type AddFilingCountOutputTypeCountLotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotInfoWhereInput
  }

  /**
   * AddFilingCountOutputType without action
   */
  export type AddFilingCountOutputTypeCountLotFilingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotFilingMapperWhereInput
  }


  /**
   * Count Type AddSettingCountOutputType
   */

  export type AddSettingCountOutputType = {
    settings: number
    settingMapper: number
    lotInfo: number
  }

  export type AddSettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | AddSettingCountOutputTypeCountSettingsArgs
    settingMapper?: boolean | AddSettingCountOutputTypeCountSettingMapperArgs
    lotInfo?: boolean | AddSettingCountOutputTypeCountLotInfoArgs
  }

  // Custom InputTypes
  /**
   * AddSettingCountOutputType without action
   */
  export type AddSettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSettingCountOutputType
     */
    select?: AddSettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddSettingCountOutputType without action
   */
  export type AddSettingCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingEntryWhereInput
  }

  /**
   * AddSettingCountOutputType without action
   */
  export type AddSettingCountOutputTypeCountSettingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotSettingMapperWhereInput
  }

  /**
   * AddSettingCountOutputType without action
   */
  export type AddSettingCountOutputTypeCountLotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotInfoWhereInput
  }


  /**
   * Count Type AddBuffingCountOutputType
   */

  export type AddBuffingCountOutputType = {
    buffings: number
    buffingMapper: number
    lotInfo: number
    buffingWastages: number
  }

  export type AddBuffingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffings?: boolean | AddBuffingCountOutputTypeCountBuffingsArgs
    buffingMapper?: boolean | AddBuffingCountOutputTypeCountBuffingMapperArgs
    lotInfo?: boolean | AddBuffingCountOutputTypeCountLotInfoArgs
    buffingWastages?: boolean | AddBuffingCountOutputTypeCountBuffingWastagesArgs
  }

  // Custom InputTypes
  /**
   * AddBuffingCountOutputType without action
   */
  export type AddBuffingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffingCountOutputType
     */
    select?: AddBuffingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddBuffingCountOutputType without action
   */
  export type AddBuffingCountOutputTypeCountBuffingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingEntryWhereInput
  }

  /**
   * AddBuffingCountOutputType without action
   */
  export type AddBuffingCountOutputTypeCountBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
  }

  /**
   * AddBuffingCountOutputType without action
   */
  export type AddBuffingCountOutputTypeCountLotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotInfoWhereInput
  }

  /**
   * AddBuffingCountOutputType without action
   */
  export type AddBuffingCountOutputTypeCountBuffingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingWastageWhereInput
  }


  /**
   * Count Type AddItemCountOutputType
   */

  export type AddItemCountOutputType = {
    casting_items: number
    stock: number
    filing_items: number
    setting_items: number
    buffing_items: number
  }

  export type AddItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    casting_items?: boolean | AddItemCountOutputTypeCountCasting_itemsArgs
    stock?: boolean | AddItemCountOutputTypeCountStockArgs
    filing_items?: boolean | AddItemCountOutputTypeCountFiling_itemsArgs
    setting_items?: boolean | AddItemCountOutputTypeCountSetting_itemsArgs
    buffing_items?: boolean | AddItemCountOutputTypeCountBuffing_itemsArgs
  }

  // Custom InputTypes
  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItemCountOutputType
     */
    select?: AddItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeCountCasting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingItemsWhereInput
  }

  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeCountFiling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }

  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeCountSetting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
  }

  /**
   * AddItemCountOutputType without action
   */
  export type AddItemCountOutputTypeCountBuffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingItemsWhereInput
  }


  /**
   * Count Type AddTouchCountOutputType
   */

  export type AddTouchCountOutputType = {
    casting_entry: number
    casting_items: number
    filing_items: number
    setting_items: number
    buffing_items: number
    stock: number
  }

  export type AddTouchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    casting_entry?: boolean | AddTouchCountOutputTypeCountCasting_entryArgs
    casting_items?: boolean | AddTouchCountOutputTypeCountCasting_itemsArgs
    filing_items?: boolean | AddTouchCountOutputTypeCountFiling_itemsArgs
    setting_items?: boolean | AddTouchCountOutputTypeCountSetting_itemsArgs
    buffing_items?: boolean | AddTouchCountOutputTypeCountBuffing_itemsArgs
    stock?: boolean | AddTouchCountOutputTypeCountStockArgs
  }

  // Custom InputTypes
  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouchCountOutputType
     */
    select?: AddTouchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountCasting_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingEntryWhereInput
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountCasting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingItemsWhereInput
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountFiling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountSetting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountBuffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingItemsWhereInput
  }

  /**
   * AddTouchCountOutputType without action
   */
  export type AddTouchCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }


  /**
   * Count Type CastingEntryCountOutputType
   */

  export type CastingEntryCountOutputType = {
    items: number
    CastiingTotalBalance: number
  }

  export type CastingEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CastingEntryCountOutputTypeCountItemsArgs
    CastiingTotalBalance?: boolean | CastingEntryCountOutputTypeCountCastiingTotalBalanceArgs
  }

  // Custom InputTypes
  /**
   * CastingEntryCountOutputType without action
   */
  export type CastingEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntryCountOutputType
     */
    select?: CastingEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CastingEntryCountOutputType without action
   */
  export type CastingEntryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingItemsWhereInput
  }

  /**
   * CastingEntryCountOutputType without action
   */
  export type CastingEntryCountOutputTypeCountCastiingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastiingTotalBalanceWhereInput
  }


  /**
   * Count Type CastingItemsCountOutputType
   */

  export type CastingItemsCountOutputType = {
    filingEntry: number
    settingEntry: number
    buffingEntry: number
    stock: number
    filingLotMapper: number
  }

  export type CastingItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingEntry?: boolean | CastingItemsCountOutputTypeCountFilingEntryArgs
    settingEntry?: boolean | CastingItemsCountOutputTypeCountSettingEntryArgs
    buffingEntry?: boolean | CastingItemsCountOutputTypeCountBuffingEntryArgs
    stock?: boolean | CastingItemsCountOutputTypeCountStockArgs
    filingLotMapper?: boolean | CastingItemsCountOutputTypeCountFilingLotMapperArgs
  }

  // Custom InputTypes
  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItemsCountOutputType
     */
    select?: CastingItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeCountFilingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingEntryWhereInput
  }

  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeCountSettingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingEntryWhereInput
  }

  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeCountBuffingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingEntryWhereInput
  }

  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * CastingItemsCountOutputType without action
   */
  export type CastingItemsCountOutputTypeCountFilingLotMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotFilingMapperWhereInput
  }


  /**
   * Count Type LotInfoCountOutputType
   */

  export type LotInfoCountOutputType = {
    filingMapper: number
    settingMapper: number
    buffingMapper: number
    filingWastages: number
    buffingWastages: number
  }

  export type LotInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingMapper?: boolean | LotInfoCountOutputTypeCountFilingMapperArgs
    settingMapper?: boolean | LotInfoCountOutputTypeCountSettingMapperArgs
    buffingMapper?: boolean | LotInfoCountOutputTypeCountBuffingMapperArgs
    filingWastages?: boolean | LotInfoCountOutputTypeCountFilingWastagesArgs
    buffingWastages?: boolean | LotInfoCountOutputTypeCountBuffingWastagesArgs
  }

  // Custom InputTypes
  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfoCountOutputType
     */
    select?: LotInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeCountFilingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotFilingMapperWhereInput
  }

  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeCountSettingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotSettingMapperWhereInput
  }

  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeCountBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
  }

  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeCountFilingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingWastageWhereInput
  }

  /**
   * LotInfoCountOutputType without action
   */
  export type LotInfoCountOutputTypeCountBuffingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingWastageWhereInput
  }


  /**
   * Count Type FilingEntryCountOutputType
   */

  export type FilingEntryCountOutputType = {
    filingItems: number
    filingTotalBalance: number
    LotFilingMapper: number
  }

  export type FilingEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingItems?: boolean | FilingEntryCountOutputTypeCountFilingItemsArgs
    filingTotalBalance?: boolean | FilingEntryCountOutputTypeCountFilingTotalBalanceArgs
    LotFilingMapper?: boolean | FilingEntryCountOutputTypeCountLotFilingMapperArgs
  }

  // Custom InputTypes
  /**
   * FilingEntryCountOutputType without action
   */
  export type FilingEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntryCountOutputType
     */
    select?: FilingEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilingEntryCountOutputType without action
   */
  export type FilingEntryCountOutputTypeCountFilingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }

  /**
   * FilingEntryCountOutputType without action
   */
  export type FilingEntryCountOutputTypeCountFilingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingTotalBalanceWhereInput
  }

  /**
   * FilingEntryCountOutputType without action
   */
  export type FilingEntryCountOutputTypeCountLotFilingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotFilingMapperWhereInput
  }


  /**
   * Count Type LotFilingMapperCountOutputType
   */

  export type LotFilingMapperCountOutputType = {
    filing_items: number
  }

  export type LotFilingMapperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filing_items?: boolean | LotFilingMapperCountOutputTypeCountFiling_itemsArgs
  }

  // Custom InputTypes
  /**
   * LotFilingMapperCountOutputType without action
   */
  export type LotFilingMapperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapperCountOutputType
     */
    select?: LotFilingMapperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LotFilingMapperCountOutputType without action
   */
  export type LotFilingMapperCountOutputTypeCountFiling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }


  /**
   * Count Type FilingItemsCountOutputType
   */

  export type FilingItemsCountOutputType = {
    stock: number
    setting_entry: number
    buffing_entry: number
    filing_wastage: number
    lot_setting_mapper: number
    LotBuffingMapper: number
  }

  export type FilingItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | FilingItemsCountOutputTypeCountStockArgs
    setting_entry?: boolean | FilingItemsCountOutputTypeCountSetting_entryArgs
    buffing_entry?: boolean | FilingItemsCountOutputTypeCountBuffing_entryArgs
    filing_wastage?: boolean | FilingItemsCountOutputTypeCountFiling_wastageArgs
    lot_setting_mapper?: boolean | FilingItemsCountOutputTypeCountLot_setting_mapperArgs
    LotBuffingMapper?: boolean | FilingItemsCountOutputTypeCountLotBuffingMapperArgs
  }

  // Custom InputTypes
  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItemsCountOutputType
     */
    select?: FilingItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountSetting_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingEntryWhereInput
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountBuffing_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingEntryWhereInput
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountFiling_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingWastageWhereInput
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountLot_setting_mapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotSettingMapperWhereInput
  }

  /**
   * FilingItemsCountOutputType without action
   */
  export type FilingItemsCountOutputTypeCountLotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
  }


  /**
   * Count Type FilingWastageCountOutputType
   */

  export type FilingWastageCountOutputType = {
    filing_items: number
  }

  export type FilingWastageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filing_items?: boolean | FilingWastageCountOutputTypeCountFiling_itemsArgs
  }

  // Custom InputTypes
  /**
   * FilingWastageCountOutputType without action
   */
  export type FilingWastageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastageCountOutputType
     */
    select?: FilingWastageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilingWastageCountOutputType without action
   */
  export type FilingWastageCountOutputTypeCountFiling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }


  /**
   * Count Type SettingEntryCountOutputType
   */

  export type SettingEntryCountOutputType = {
    filingItems: number
    settingTotalBalance: number
    settingWastage: number
    LotSettingMapper: number
    SettingItems: number
  }

  export type SettingEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingItems?: boolean | SettingEntryCountOutputTypeCountFilingItemsArgs
    settingTotalBalance?: boolean | SettingEntryCountOutputTypeCountSettingTotalBalanceArgs
    settingWastage?: boolean | SettingEntryCountOutputTypeCountSettingWastageArgs
    LotSettingMapper?: boolean | SettingEntryCountOutputTypeCountLotSettingMapperArgs
    SettingItems?: boolean | SettingEntryCountOutputTypeCountSettingItemsArgs
  }

  // Custom InputTypes
  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntryCountOutputType
     */
    select?: SettingEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeCountFilingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }

  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeCountSettingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingTotalBalanceWhereInput
  }

  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeCountSettingWastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWastageWhereInput
  }

  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeCountLotSettingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotSettingMapperWhereInput
  }

  /**
   * SettingEntryCountOutputType without action
   */
  export type SettingEntryCountOutputTypeCountSettingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
  }


  /**
   * Count Type SettingItemsCountOutputType
   */

  export type SettingItemsCountOutputType = {
    setting_wastage: number
    buffing_entry: number
    stock: number
    LotBuffingMapper: number
  }

  export type SettingItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting_wastage?: boolean | SettingItemsCountOutputTypeCountSetting_wastageArgs
    buffing_entry?: boolean | SettingItemsCountOutputTypeCountBuffing_entryArgs
    stock?: boolean | SettingItemsCountOutputTypeCountStockArgs
    LotBuffingMapper?: boolean | SettingItemsCountOutputTypeCountLotBuffingMapperArgs
  }

  // Custom InputTypes
  /**
   * SettingItemsCountOutputType without action
   */
  export type SettingItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItemsCountOutputType
     */
    select?: SettingItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettingItemsCountOutputType without action
   */
  export type SettingItemsCountOutputTypeCountSetting_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWastageWhereInput
  }

  /**
   * SettingItemsCountOutputType without action
   */
  export type SettingItemsCountOutputTypeCountBuffing_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingEntryWhereInput
  }

  /**
   * SettingItemsCountOutputType without action
   */
  export type SettingItemsCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * SettingItemsCountOutputType without action
   */
  export type SettingItemsCountOutputTypeCountLotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
  }


  /**
   * Count Type SettingWastageCountOutputType
   */

  export type SettingWastageCountOutputType = {
    setting_items: number
  }

  export type SettingWastageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting_items?: boolean | SettingWastageCountOutputTypeCountSetting_itemsArgs
  }

  // Custom InputTypes
  /**
   * SettingWastageCountOutputType without action
   */
  export type SettingWastageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastageCountOutputType
     */
    select?: SettingWastageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SettingWastageCountOutputType without action
   */
  export type SettingWastageCountOutputTypeCountSetting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
  }


  /**
   * Count Type BuffingEntryCountOutputType
   */

  export type BuffingEntryCountOutputType = {
    filing_items: number
    setting_items: number
    BuffingTotalBalance: number
    LotBuffingMapper: number
    BuffingItems: number
  }

  export type BuffingEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filing_items?: boolean | BuffingEntryCountOutputTypeCountFiling_itemsArgs
    setting_items?: boolean | BuffingEntryCountOutputTypeCountSetting_itemsArgs
    BuffingTotalBalance?: boolean | BuffingEntryCountOutputTypeCountBuffingTotalBalanceArgs
    LotBuffingMapper?: boolean | BuffingEntryCountOutputTypeCountLotBuffingMapperArgs
    BuffingItems?: boolean | BuffingEntryCountOutputTypeCountBuffingItemsArgs
  }

  // Custom InputTypes
  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntryCountOutputType
     */
    select?: BuffingEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeCountFiling_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
  }

  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeCountSetting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
  }

  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeCountBuffingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingTotalBalanceWhereInput
  }

  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeCountLotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
  }

  /**
   * BuffingEntryCountOutputType without action
   */
  export type BuffingEntryCountOutputTypeCountBuffingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingItemsWhereInput
  }


  /**
   * Count Type BuffingItemsCountOutputType
   */

  export type BuffingItemsCountOutputType = {
    stock: number
    buffing_wastage: number
  }

  export type BuffingItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | BuffingItemsCountOutputTypeCountStockArgs
    buffing_wastage?: boolean | BuffingItemsCountOutputTypeCountBuffing_wastageArgs
  }

  // Custom InputTypes
  /**
   * BuffingItemsCountOutputType without action
   */
  export type BuffingItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItemsCountOutputType
     */
    select?: BuffingItemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuffingItemsCountOutputType without action
   */
  export type BuffingItemsCountOutputTypeCountStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * BuffingItemsCountOutputType without action
   */
  export type BuffingItemsCountOutputTypeCountBuffing_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingWastageWhereInput
  }


  /**
   * Count Type BuffingWastageCountOutputType
   */

  export type BuffingWastageCountOutputType = {
    buffing_items: number
  }

  export type BuffingWastageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffing_items?: boolean | BuffingWastageCountOutputTypeCountBuffing_itemsArgs
  }

  // Custom InputTypes
  /**
   * BuffingWastageCountOutputType without action
   */
  export type BuffingWastageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastageCountOutputType
     */
    select?: BuffingWastageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuffingWastageCountOutputType without action
   */
  export type BuffingWastageCountOutputTypeCountBuffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingItemsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AddCustomer
   */

  export type AggregateAddCustomer = {
    _count: AddCustomerCountAggregateOutputType | null
    _avg: AddCustomerAvgAggregateOutputType | null
    _sum: AddCustomerSumAggregateOutputType | null
    _min: AddCustomerMinAggregateOutputType | null
    _max: AddCustomerMaxAggregateOutputType | null
  }

  export type AddCustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type AddCustomerSumAggregateOutputType = {
    id: number | null
  }

  export type AddCustomerMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddCustomerMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddCustomerCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    phoneNumber: number
    address: number
    email: number
    _all: number
  }


  export type AddCustomerAvgAggregateInputType = {
    id?: true
  }

  export type AddCustomerSumAggregateInputType = {
    id?: true
  }

  export type AddCustomerMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddCustomerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddCustomerCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
    _all?: true
  }

  export type AddCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddCustomer to aggregate.
     */
    where?: AddCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCustomers to fetch.
     */
    orderBy?: AddCustomerOrderByWithRelationInput | AddCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddCustomers
    **/
    _count?: true | AddCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddCustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddCustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddCustomerMaxAggregateInputType
  }

  export type GetAddCustomerAggregateType<T extends AddCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateAddCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddCustomer[P]>
      : GetScalarType<T[P], AggregateAddCustomer[P]>
  }




  export type AddCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddCustomerWhereInput
    orderBy?: AddCustomerOrderByWithAggregationInput | AddCustomerOrderByWithAggregationInput[]
    by: AddCustomerScalarFieldEnum[] | AddCustomerScalarFieldEnum
    having?: AddCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddCustomerCountAggregateInputType | true
    _avg?: AddCustomerAvgAggregateInputType
    _sum?: AddCustomerSumAggregateInputType
    _min?: AddCustomerMinAggregateInputType
    _max?: AddCustomerMaxAggregateInputType
  }

  export type AddCustomerGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    phoneNumber: string | null
    address: string | null
    email: string | null
    _count: AddCustomerCountAggregateOutputType | null
    _avg: AddCustomerAvgAggregateOutputType | null
    _sum: AddCustomerSumAggregateOutputType | null
    _min: AddCustomerMinAggregateOutputType | null
    _max: AddCustomerMaxAggregateOutputType | null
  }

  type GetAddCustomerGroupByPayload<T extends AddCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], AddCustomerGroupByOutputType[P]>
        }
      >
    >


  export type AddCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
    transactions?: boolean | AddCustomer$transactionsArgs<ExtArgs>
    _count?: boolean | AddCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addCustomer"]>



  export type AddCustomerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
  }

  export type AddCustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "phoneNumber" | "address" | "email", ExtArgs["result"]["addCustomer"]>
  export type AddCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AddCustomer$transactionsArgs<ExtArgs>
    _count?: boolean | AddCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddCustomer"
    objects: {
      transactions: Prisma.$CustomerTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      phoneNumber: string | null
      address: string | null
      email: string | null
    }, ExtArgs["result"]["addCustomer"]>
    composites: {}
  }

  type AddCustomerGetPayload<S extends boolean | null | undefined | AddCustomerDefaultArgs> = $Result.GetResult<Prisma.$AddCustomerPayload, S>

  type AddCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddCustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddCustomerCountAggregateInputType | true
    }

  export interface AddCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddCustomer'], meta: { name: 'AddCustomer' } }
    /**
     * Find zero or one AddCustomer that matches the filter.
     * @param {AddCustomerFindUniqueArgs} args - Arguments to find a AddCustomer
     * @example
     * // Get one AddCustomer
     * const addCustomer = await prisma.addCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddCustomerFindUniqueArgs>(args: SelectSubset<T, AddCustomerFindUniqueArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddCustomer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddCustomerFindUniqueOrThrowArgs} args - Arguments to find a AddCustomer
     * @example
     * // Get one AddCustomer
     * const addCustomer = await prisma.addCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, AddCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerFindFirstArgs} args - Arguments to find a AddCustomer
     * @example
     * // Get one AddCustomer
     * const addCustomer = await prisma.addCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddCustomerFindFirstArgs>(args?: SelectSubset<T, AddCustomerFindFirstArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerFindFirstOrThrowArgs} args - Arguments to find a AddCustomer
     * @example
     * // Get one AddCustomer
     * const addCustomer = await prisma.addCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, AddCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddCustomers
     * const addCustomers = await prisma.addCustomer.findMany()
     * 
     * // Get first 10 AddCustomers
     * const addCustomers = await prisma.addCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addCustomerWithIdOnly = await prisma.addCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddCustomerFindManyArgs>(args?: SelectSubset<T, AddCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddCustomer.
     * @param {AddCustomerCreateArgs} args - Arguments to create a AddCustomer.
     * @example
     * // Create one AddCustomer
     * const AddCustomer = await prisma.addCustomer.create({
     *   data: {
     *     // ... data to create a AddCustomer
     *   }
     * })
     * 
     */
    create<T extends AddCustomerCreateArgs>(args: SelectSubset<T, AddCustomerCreateArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddCustomers.
     * @param {AddCustomerCreateManyArgs} args - Arguments to create many AddCustomers.
     * @example
     * // Create many AddCustomers
     * const addCustomer = await prisma.addCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddCustomerCreateManyArgs>(args?: SelectSubset<T, AddCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddCustomer.
     * @param {AddCustomerDeleteArgs} args - Arguments to delete one AddCustomer.
     * @example
     * // Delete one AddCustomer
     * const AddCustomer = await prisma.addCustomer.delete({
     *   where: {
     *     // ... filter to delete one AddCustomer
     *   }
     * })
     * 
     */
    delete<T extends AddCustomerDeleteArgs>(args: SelectSubset<T, AddCustomerDeleteArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddCustomer.
     * @param {AddCustomerUpdateArgs} args - Arguments to update one AddCustomer.
     * @example
     * // Update one AddCustomer
     * const addCustomer = await prisma.addCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddCustomerUpdateArgs>(args: SelectSubset<T, AddCustomerUpdateArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddCustomers.
     * @param {AddCustomerDeleteManyArgs} args - Arguments to filter AddCustomers to delete.
     * @example
     * // Delete a few AddCustomers
     * const { count } = await prisma.addCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddCustomerDeleteManyArgs>(args?: SelectSubset<T, AddCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddCustomers
     * const addCustomer = await prisma.addCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddCustomerUpdateManyArgs>(args: SelectSubset<T, AddCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddCustomer.
     * @param {AddCustomerUpsertArgs} args - Arguments to update or create a AddCustomer.
     * @example
     * // Update or create a AddCustomer
     * const addCustomer = await prisma.addCustomer.upsert({
     *   create: {
     *     // ... data to create a AddCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddCustomer we want to update
     *   }
     * })
     */
    upsert<T extends AddCustomerUpsertArgs>(args: SelectSubset<T, AddCustomerUpsertArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerCountArgs} args - Arguments to filter AddCustomers to count.
     * @example
     * // Count the number of AddCustomers
     * const count = await prisma.addCustomer.count({
     *   where: {
     *     // ... the filter for the AddCustomers we want to count
     *   }
     * })
    **/
    count<T extends AddCustomerCountArgs>(
      args?: Subset<T, AddCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddCustomerAggregateArgs>(args: Subset<T, AddCustomerAggregateArgs>): Prisma.PrismaPromise<GetAddCustomerAggregateType<T>>

    /**
     * Group by AddCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddCustomerGroupByArgs['orderBy'] }
        : { orderBy?: AddCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddCustomer model
   */
  readonly fields: AddCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends AddCustomer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, AddCustomer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddCustomer model
   */
  interface AddCustomerFieldRefs {
    readonly id: FieldRef<"AddCustomer", 'Int'>
    readonly createdAt: FieldRef<"AddCustomer", 'DateTime'>
    readonly name: FieldRef<"AddCustomer", 'String'>
    readonly phoneNumber: FieldRef<"AddCustomer", 'String'>
    readonly address: FieldRef<"AddCustomer", 'String'>
    readonly email: FieldRef<"AddCustomer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddCustomer findUnique
   */
  export type AddCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter, which AddCustomer to fetch.
     */
    where: AddCustomerWhereUniqueInput
  }

  /**
   * AddCustomer findUniqueOrThrow
   */
  export type AddCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter, which AddCustomer to fetch.
     */
    where: AddCustomerWhereUniqueInput
  }

  /**
   * AddCustomer findFirst
   */
  export type AddCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter, which AddCustomer to fetch.
     */
    where?: AddCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCustomers to fetch.
     */
    orderBy?: AddCustomerOrderByWithRelationInput | AddCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddCustomers.
     */
    cursor?: AddCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddCustomers.
     */
    distinct?: AddCustomerScalarFieldEnum | AddCustomerScalarFieldEnum[]
  }

  /**
   * AddCustomer findFirstOrThrow
   */
  export type AddCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter, which AddCustomer to fetch.
     */
    where?: AddCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCustomers to fetch.
     */
    orderBy?: AddCustomerOrderByWithRelationInput | AddCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddCustomers.
     */
    cursor?: AddCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddCustomers.
     */
    distinct?: AddCustomerScalarFieldEnum | AddCustomerScalarFieldEnum[]
  }

  /**
   * AddCustomer findMany
   */
  export type AddCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter, which AddCustomers to fetch.
     */
    where?: AddCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCustomers to fetch.
     */
    orderBy?: AddCustomerOrderByWithRelationInput | AddCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddCustomers.
     */
    cursor?: AddCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCustomers.
     */
    skip?: number
    distinct?: AddCustomerScalarFieldEnum | AddCustomerScalarFieldEnum[]
  }

  /**
   * AddCustomer create
   */
  export type AddCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a AddCustomer.
     */
    data: XOR<AddCustomerCreateInput, AddCustomerUncheckedCreateInput>
  }

  /**
   * AddCustomer createMany
   */
  export type AddCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddCustomers.
     */
    data: AddCustomerCreateManyInput | AddCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddCustomer update
   */
  export type AddCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a AddCustomer.
     */
    data: XOR<AddCustomerUpdateInput, AddCustomerUncheckedUpdateInput>
    /**
     * Choose, which AddCustomer to update.
     */
    where: AddCustomerWhereUniqueInput
  }

  /**
   * AddCustomer updateMany
   */
  export type AddCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddCustomers.
     */
    data: XOR<AddCustomerUpdateManyMutationInput, AddCustomerUncheckedUpdateManyInput>
    /**
     * Filter which AddCustomers to update
     */
    where?: AddCustomerWhereInput
    /**
     * Limit how many AddCustomers to update.
     */
    limit?: number
  }

  /**
   * AddCustomer upsert
   */
  export type AddCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the AddCustomer to update in case it exists.
     */
    where: AddCustomerWhereUniqueInput
    /**
     * In case the AddCustomer found by the `where` argument doesn't exist, create a new AddCustomer with this data.
     */
    create: XOR<AddCustomerCreateInput, AddCustomerUncheckedCreateInput>
    /**
     * In case the AddCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddCustomerUpdateInput, AddCustomerUncheckedUpdateInput>
  }

  /**
   * AddCustomer delete
   */
  export type AddCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
    /**
     * Filter which AddCustomer to delete.
     */
    where: AddCustomerWhereUniqueInput
  }

  /**
   * AddCustomer deleteMany
   */
  export type AddCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddCustomers to delete
     */
    where?: AddCustomerWhereInput
    /**
     * Limit how many AddCustomers to delete.
     */
    limit?: number
  }

  /**
   * AddCustomer.transactions
   */
  export type AddCustomer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    where?: CustomerTransactionWhereInput
    orderBy?: CustomerTransactionOrderByWithRelationInput | CustomerTransactionOrderByWithRelationInput[]
    cursor?: CustomerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerTransactionScalarFieldEnum | CustomerTransactionScalarFieldEnum[]
  }

  /**
   * AddCustomer without action
   */
  export type AddCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCustomer
     */
    select?: AddCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCustomer
     */
    omit?: AddCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCustomerInclude<ExtArgs> | null
  }


  /**
   * Model AddCasting
   */

  export type AggregateAddCasting = {
    _count: AddCastingCountAggregateOutputType | null
    _avg: AddCastingAvgAggregateOutputType | null
    _sum: AddCastingSumAggregateOutputType | null
    _min: AddCastingMinAggregateOutputType | null
    _max: AddCastingMaxAggregateOutputType | null
  }

  export type AddCastingAvgAggregateOutputType = {
    id: number | null
  }

  export type AddCastingSumAggregateOutputType = {
    id: number | null
  }

  export type AddCastingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddCastingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddCastingCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    phoneNumber: number
    address: number
    email: number
    _all: number
  }


  export type AddCastingAvgAggregateInputType = {
    id?: true
  }

  export type AddCastingSumAggregateInputType = {
    id?: true
  }

  export type AddCastingMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddCastingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddCastingCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
    _all?: true
  }

  export type AddCastingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddCasting to aggregate.
     */
    where?: AddCastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCastings to fetch.
     */
    orderBy?: AddCastingOrderByWithRelationInput | AddCastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddCastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCastings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCastings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddCastings
    **/
    _count?: true | AddCastingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddCastingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddCastingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddCastingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddCastingMaxAggregateInputType
  }

  export type GetAddCastingAggregateType<T extends AddCastingAggregateArgs> = {
        [P in keyof T & keyof AggregateAddCasting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddCasting[P]>
      : GetScalarType<T[P], AggregateAddCasting[P]>
  }




  export type AddCastingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddCastingWhereInput
    orderBy?: AddCastingOrderByWithAggregationInput | AddCastingOrderByWithAggregationInput[]
    by: AddCastingScalarFieldEnum[] | AddCastingScalarFieldEnum
    having?: AddCastingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddCastingCountAggregateInputType | true
    _avg?: AddCastingAvgAggregateInputType
    _sum?: AddCastingSumAggregateInputType
    _min?: AddCastingMinAggregateInputType
    _max?: AddCastingMaxAggregateInputType
  }

  export type AddCastingGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    phoneNumber: string | null
    address: string | null
    email: string | null
    _count: AddCastingCountAggregateOutputType | null
    _avg: AddCastingAvgAggregateOutputType | null
    _sum: AddCastingSumAggregateOutputType | null
    _min: AddCastingMinAggregateOutputType | null
    _max: AddCastingMaxAggregateOutputType | null
  }

  type GetAddCastingGroupByPayload<T extends AddCastingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddCastingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddCastingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddCastingGroupByOutputType[P]>
            : GetScalarType<T[P], AddCastingGroupByOutputType[P]>
        }
      >
    >


  export type AddCastingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
    entries?: boolean | AddCasting$entriesArgs<ExtArgs>
    castingitems?: boolean | AddCasting$castingitemsArgs<ExtArgs>
    stock?: boolean | AddCasting$stockArgs<ExtArgs>
    _count?: boolean | AddCastingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addCasting"]>



  export type AddCastingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
  }

  export type AddCastingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "phoneNumber" | "address" | "email", ExtArgs["result"]["addCasting"]>
  export type AddCastingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | AddCasting$entriesArgs<ExtArgs>
    castingitems?: boolean | AddCasting$castingitemsArgs<ExtArgs>
    stock?: boolean | AddCasting$stockArgs<ExtArgs>
    _count?: boolean | AddCastingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddCastingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddCasting"
    objects: {
      entries: Prisma.$CastingEntryPayload<ExtArgs>[]
      castingitems: Prisma.$CastingItemsPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      phoneNumber: string | null
      address: string | null
      email: string | null
    }, ExtArgs["result"]["addCasting"]>
    composites: {}
  }

  type AddCastingGetPayload<S extends boolean | null | undefined | AddCastingDefaultArgs> = $Result.GetResult<Prisma.$AddCastingPayload, S>

  type AddCastingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddCastingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddCastingCountAggregateInputType | true
    }

  export interface AddCastingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddCasting'], meta: { name: 'AddCasting' } }
    /**
     * Find zero or one AddCasting that matches the filter.
     * @param {AddCastingFindUniqueArgs} args - Arguments to find a AddCasting
     * @example
     * // Get one AddCasting
     * const addCasting = await prisma.addCasting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddCastingFindUniqueArgs>(args: SelectSubset<T, AddCastingFindUniqueArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddCasting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddCastingFindUniqueOrThrowArgs} args - Arguments to find a AddCasting
     * @example
     * // Get one AddCasting
     * const addCasting = await prisma.addCasting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddCastingFindUniqueOrThrowArgs>(args: SelectSubset<T, AddCastingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddCasting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingFindFirstArgs} args - Arguments to find a AddCasting
     * @example
     * // Get one AddCasting
     * const addCasting = await prisma.addCasting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddCastingFindFirstArgs>(args?: SelectSubset<T, AddCastingFindFirstArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddCasting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingFindFirstOrThrowArgs} args - Arguments to find a AddCasting
     * @example
     * // Get one AddCasting
     * const addCasting = await prisma.addCasting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddCastingFindFirstOrThrowArgs>(args?: SelectSubset<T, AddCastingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddCastings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddCastings
     * const addCastings = await prisma.addCasting.findMany()
     * 
     * // Get first 10 AddCastings
     * const addCastings = await prisma.addCasting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addCastingWithIdOnly = await prisma.addCasting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddCastingFindManyArgs>(args?: SelectSubset<T, AddCastingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddCasting.
     * @param {AddCastingCreateArgs} args - Arguments to create a AddCasting.
     * @example
     * // Create one AddCasting
     * const AddCasting = await prisma.addCasting.create({
     *   data: {
     *     // ... data to create a AddCasting
     *   }
     * })
     * 
     */
    create<T extends AddCastingCreateArgs>(args: SelectSubset<T, AddCastingCreateArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddCastings.
     * @param {AddCastingCreateManyArgs} args - Arguments to create many AddCastings.
     * @example
     * // Create many AddCastings
     * const addCasting = await prisma.addCasting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddCastingCreateManyArgs>(args?: SelectSubset<T, AddCastingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddCasting.
     * @param {AddCastingDeleteArgs} args - Arguments to delete one AddCasting.
     * @example
     * // Delete one AddCasting
     * const AddCasting = await prisma.addCasting.delete({
     *   where: {
     *     // ... filter to delete one AddCasting
     *   }
     * })
     * 
     */
    delete<T extends AddCastingDeleteArgs>(args: SelectSubset<T, AddCastingDeleteArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddCasting.
     * @param {AddCastingUpdateArgs} args - Arguments to update one AddCasting.
     * @example
     * // Update one AddCasting
     * const addCasting = await prisma.addCasting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddCastingUpdateArgs>(args: SelectSubset<T, AddCastingUpdateArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddCastings.
     * @param {AddCastingDeleteManyArgs} args - Arguments to filter AddCastings to delete.
     * @example
     * // Delete a few AddCastings
     * const { count } = await prisma.addCasting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddCastingDeleteManyArgs>(args?: SelectSubset<T, AddCastingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddCastings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddCastings
     * const addCasting = await prisma.addCasting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddCastingUpdateManyArgs>(args: SelectSubset<T, AddCastingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddCasting.
     * @param {AddCastingUpsertArgs} args - Arguments to update or create a AddCasting.
     * @example
     * // Update or create a AddCasting
     * const addCasting = await prisma.addCasting.upsert({
     *   create: {
     *     // ... data to create a AddCasting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddCasting we want to update
     *   }
     * })
     */
    upsert<T extends AddCastingUpsertArgs>(args: SelectSubset<T, AddCastingUpsertArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddCastings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingCountArgs} args - Arguments to filter AddCastings to count.
     * @example
     * // Count the number of AddCastings
     * const count = await prisma.addCasting.count({
     *   where: {
     *     // ... the filter for the AddCastings we want to count
     *   }
     * })
    **/
    count<T extends AddCastingCountArgs>(
      args?: Subset<T, AddCastingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddCastingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddCasting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddCastingAggregateArgs>(args: Subset<T, AddCastingAggregateArgs>): Prisma.PrismaPromise<GetAddCastingAggregateType<T>>

    /**
     * Group by AddCasting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddCastingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddCastingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddCastingGroupByArgs['orderBy'] }
        : { orderBy?: AddCastingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddCastingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddCastingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddCasting model
   */
  readonly fields: AddCastingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddCasting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddCastingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends AddCasting$entriesArgs<ExtArgs> = {}>(args?: Subset<T, AddCasting$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    castingitems<T extends AddCasting$castingitemsArgs<ExtArgs> = {}>(args?: Subset<T, AddCasting$castingitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends AddCasting$stockArgs<ExtArgs> = {}>(args?: Subset<T, AddCasting$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddCasting model
   */
  interface AddCastingFieldRefs {
    readonly id: FieldRef<"AddCasting", 'Int'>
    readonly createdAt: FieldRef<"AddCasting", 'DateTime'>
    readonly name: FieldRef<"AddCasting", 'String'>
    readonly phoneNumber: FieldRef<"AddCasting", 'String'>
    readonly address: FieldRef<"AddCasting", 'String'>
    readonly email: FieldRef<"AddCasting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddCasting findUnique
   */
  export type AddCastingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter, which AddCasting to fetch.
     */
    where: AddCastingWhereUniqueInput
  }

  /**
   * AddCasting findUniqueOrThrow
   */
  export type AddCastingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter, which AddCasting to fetch.
     */
    where: AddCastingWhereUniqueInput
  }

  /**
   * AddCasting findFirst
   */
  export type AddCastingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter, which AddCasting to fetch.
     */
    where?: AddCastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCastings to fetch.
     */
    orderBy?: AddCastingOrderByWithRelationInput | AddCastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddCastings.
     */
    cursor?: AddCastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCastings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCastings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddCastings.
     */
    distinct?: AddCastingScalarFieldEnum | AddCastingScalarFieldEnum[]
  }

  /**
   * AddCasting findFirstOrThrow
   */
  export type AddCastingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter, which AddCasting to fetch.
     */
    where?: AddCastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCastings to fetch.
     */
    orderBy?: AddCastingOrderByWithRelationInput | AddCastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddCastings.
     */
    cursor?: AddCastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCastings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCastings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddCastings.
     */
    distinct?: AddCastingScalarFieldEnum | AddCastingScalarFieldEnum[]
  }

  /**
   * AddCasting findMany
   */
  export type AddCastingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter, which AddCastings to fetch.
     */
    where?: AddCastingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddCastings to fetch.
     */
    orderBy?: AddCastingOrderByWithRelationInput | AddCastingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddCastings.
     */
    cursor?: AddCastingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddCastings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddCastings.
     */
    skip?: number
    distinct?: AddCastingScalarFieldEnum | AddCastingScalarFieldEnum[]
  }

  /**
   * AddCasting create
   */
  export type AddCastingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * The data needed to create a AddCasting.
     */
    data: XOR<AddCastingCreateInput, AddCastingUncheckedCreateInput>
  }

  /**
   * AddCasting createMany
   */
  export type AddCastingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddCastings.
     */
    data: AddCastingCreateManyInput | AddCastingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddCasting update
   */
  export type AddCastingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * The data needed to update a AddCasting.
     */
    data: XOR<AddCastingUpdateInput, AddCastingUncheckedUpdateInput>
    /**
     * Choose, which AddCasting to update.
     */
    where: AddCastingWhereUniqueInput
  }

  /**
   * AddCasting updateMany
   */
  export type AddCastingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddCastings.
     */
    data: XOR<AddCastingUpdateManyMutationInput, AddCastingUncheckedUpdateManyInput>
    /**
     * Filter which AddCastings to update
     */
    where?: AddCastingWhereInput
    /**
     * Limit how many AddCastings to update.
     */
    limit?: number
  }

  /**
   * AddCasting upsert
   */
  export type AddCastingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * The filter to search for the AddCasting to update in case it exists.
     */
    where: AddCastingWhereUniqueInput
    /**
     * In case the AddCasting found by the `where` argument doesn't exist, create a new AddCasting with this data.
     */
    create: XOR<AddCastingCreateInput, AddCastingUncheckedCreateInput>
    /**
     * In case the AddCasting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddCastingUpdateInput, AddCastingUncheckedUpdateInput>
  }

  /**
   * AddCasting delete
   */
  export type AddCastingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
    /**
     * Filter which AddCasting to delete.
     */
    where: AddCastingWhereUniqueInput
  }

  /**
   * AddCasting deleteMany
   */
  export type AddCastingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddCastings to delete
     */
    where?: AddCastingWhereInput
    /**
     * Limit how many AddCastings to delete.
     */
    limit?: number
  }

  /**
   * AddCasting.entries
   */
  export type AddCasting$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    where?: CastingEntryWhereInput
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    cursor?: CastingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingEntryScalarFieldEnum | CastingEntryScalarFieldEnum[]
  }

  /**
   * AddCasting.castingitems
   */
  export type AddCasting$castingitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    where?: CastingItemsWhereInput
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    cursor?: CastingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * AddCasting.stock
   */
  export type AddCasting$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * AddCasting without action
   */
  export type AddCastingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddCasting
     */
    select?: AddCastingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddCasting
     */
    omit?: AddCastingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddCastingInclude<ExtArgs> | null
  }


  /**
   * Model AddFiling
   */

  export type AggregateAddFiling = {
    _count: AddFilingCountAggregateOutputType | null
    _avg: AddFilingAvgAggregateOutputType | null
    _sum: AddFilingSumAggregateOutputType | null
    _min: AddFilingMinAggregateOutputType | null
    _max: AddFilingMaxAggregateOutputType | null
  }

  export type AddFilingAvgAggregateOutputType = {
    id: number | null
  }

  export type AddFilingSumAggregateOutputType = {
    id: number | null
  }

  export type AddFilingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddFilingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddFilingCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    phoneNumber: number
    address: number
    email: number
    _all: number
  }


  export type AddFilingAvgAggregateInputType = {
    id?: true
  }

  export type AddFilingSumAggregateInputType = {
    id?: true
  }

  export type AddFilingMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddFilingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddFilingCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
    _all?: true
  }

  export type AddFilingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddFiling to aggregate.
     */
    where?: AddFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddFilings to fetch.
     */
    orderBy?: AddFilingOrderByWithRelationInput | AddFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddFilings
    **/
    _count?: true | AddFilingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddFilingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddFilingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddFilingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddFilingMaxAggregateInputType
  }

  export type GetAddFilingAggregateType<T extends AddFilingAggregateArgs> = {
        [P in keyof T & keyof AggregateAddFiling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddFiling[P]>
      : GetScalarType<T[P], AggregateAddFiling[P]>
  }




  export type AddFilingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddFilingWhereInput
    orderBy?: AddFilingOrderByWithAggregationInput | AddFilingOrderByWithAggregationInput[]
    by: AddFilingScalarFieldEnum[] | AddFilingScalarFieldEnum
    having?: AddFilingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddFilingCountAggregateInputType | true
    _avg?: AddFilingAvgAggregateInputType
    _sum?: AddFilingSumAggregateInputType
    _min?: AddFilingMinAggregateInputType
    _max?: AddFilingMaxAggregateInputType
  }

  export type AddFilingGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    phoneNumber: string | null
    address: string | null
    email: string | null
    _count: AddFilingCountAggregateOutputType | null
    _avg: AddFilingAvgAggregateOutputType | null
    _sum: AddFilingSumAggregateOutputType | null
    _min: AddFilingMinAggregateOutputType | null
    _max: AddFilingMaxAggregateOutputType | null
  }

  type GetAddFilingGroupByPayload<T extends AddFilingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddFilingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddFilingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddFilingGroupByOutputType[P]>
            : GetScalarType<T[P], AddFilingGroupByOutputType[P]>
        }
      >
    >


  export type AddFilingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
    filingWastages?: boolean | AddFiling$filingWastagesArgs<ExtArgs>
    filings?: boolean | AddFiling$filingsArgs<ExtArgs>
    lotInfo?: boolean | AddFiling$lotInfoArgs<ExtArgs>
    lotFilingMapper?: boolean | AddFiling$lotFilingMapperArgs<ExtArgs>
    _count?: boolean | AddFilingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addFiling"]>



  export type AddFilingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
  }

  export type AddFilingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "phoneNumber" | "address" | "email", ExtArgs["result"]["addFiling"]>
  export type AddFilingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingWastages?: boolean | AddFiling$filingWastagesArgs<ExtArgs>
    filings?: boolean | AddFiling$filingsArgs<ExtArgs>
    lotInfo?: boolean | AddFiling$lotInfoArgs<ExtArgs>
    lotFilingMapper?: boolean | AddFiling$lotFilingMapperArgs<ExtArgs>
    _count?: boolean | AddFilingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddFilingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddFiling"
    objects: {
      filingWastages: Prisma.$FilingWastagePayload<ExtArgs>[]
      filings: Prisma.$FilingEntryPayload<ExtArgs>[]
      lotInfo: Prisma.$LotInfoPayload<ExtArgs>[]
      lotFilingMapper: Prisma.$LotFilingMapperPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      phoneNumber: string | null
      address: string | null
      email: string | null
    }, ExtArgs["result"]["addFiling"]>
    composites: {}
  }

  type AddFilingGetPayload<S extends boolean | null | undefined | AddFilingDefaultArgs> = $Result.GetResult<Prisma.$AddFilingPayload, S>

  type AddFilingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddFilingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddFilingCountAggregateInputType | true
    }

  export interface AddFilingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddFiling'], meta: { name: 'AddFiling' } }
    /**
     * Find zero or one AddFiling that matches the filter.
     * @param {AddFilingFindUniqueArgs} args - Arguments to find a AddFiling
     * @example
     * // Get one AddFiling
     * const addFiling = await prisma.addFiling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddFilingFindUniqueArgs>(args: SelectSubset<T, AddFilingFindUniqueArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddFiling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddFilingFindUniqueOrThrowArgs} args - Arguments to find a AddFiling
     * @example
     * // Get one AddFiling
     * const addFiling = await prisma.addFiling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddFilingFindUniqueOrThrowArgs>(args: SelectSubset<T, AddFilingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddFiling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingFindFirstArgs} args - Arguments to find a AddFiling
     * @example
     * // Get one AddFiling
     * const addFiling = await prisma.addFiling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddFilingFindFirstArgs>(args?: SelectSubset<T, AddFilingFindFirstArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddFiling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingFindFirstOrThrowArgs} args - Arguments to find a AddFiling
     * @example
     * // Get one AddFiling
     * const addFiling = await prisma.addFiling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddFilingFindFirstOrThrowArgs>(args?: SelectSubset<T, AddFilingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddFilings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddFilings
     * const addFilings = await prisma.addFiling.findMany()
     * 
     * // Get first 10 AddFilings
     * const addFilings = await prisma.addFiling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addFilingWithIdOnly = await prisma.addFiling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddFilingFindManyArgs>(args?: SelectSubset<T, AddFilingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddFiling.
     * @param {AddFilingCreateArgs} args - Arguments to create a AddFiling.
     * @example
     * // Create one AddFiling
     * const AddFiling = await prisma.addFiling.create({
     *   data: {
     *     // ... data to create a AddFiling
     *   }
     * })
     * 
     */
    create<T extends AddFilingCreateArgs>(args: SelectSubset<T, AddFilingCreateArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddFilings.
     * @param {AddFilingCreateManyArgs} args - Arguments to create many AddFilings.
     * @example
     * // Create many AddFilings
     * const addFiling = await prisma.addFiling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddFilingCreateManyArgs>(args?: SelectSubset<T, AddFilingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddFiling.
     * @param {AddFilingDeleteArgs} args - Arguments to delete one AddFiling.
     * @example
     * // Delete one AddFiling
     * const AddFiling = await prisma.addFiling.delete({
     *   where: {
     *     // ... filter to delete one AddFiling
     *   }
     * })
     * 
     */
    delete<T extends AddFilingDeleteArgs>(args: SelectSubset<T, AddFilingDeleteArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddFiling.
     * @param {AddFilingUpdateArgs} args - Arguments to update one AddFiling.
     * @example
     * // Update one AddFiling
     * const addFiling = await prisma.addFiling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddFilingUpdateArgs>(args: SelectSubset<T, AddFilingUpdateArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddFilings.
     * @param {AddFilingDeleteManyArgs} args - Arguments to filter AddFilings to delete.
     * @example
     * // Delete a few AddFilings
     * const { count } = await prisma.addFiling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddFilingDeleteManyArgs>(args?: SelectSubset<T, AddFilingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddFilings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddFilings
     * const addFiling = await prisma.addFiling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddFilingUpdateManyArgs>(args: SelectSubset<T, AddFilingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddFiling.
     * @param {AddFilingUpsertArgs} args - Arguments to update or create a AddFiling.
     * @example
     * // Update or create a AddFiling
     * const addFiling = await prisma.addFiling.upsert({
     *   create: {
     *     // ... data to create a AddFiling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddFiling we want to update
     *   }
     * })
     */
    upsert<T extends AddFilingUpsertArgs>(args: SelectSubset<T, AddFilingUpsertArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddFilings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingCountArgs} args - Arguments to filter AddFilings to count.
     * @example
     * // Count the number of AddFilings
     * const count = await prisma.addFiling.count({
     *   where: {
     *     // ... the filter for the AddFilings we want to count
     *   }
     * })
    **/
    count<T extends AddFilingCountArgs>(
      args?: Subset<T, AddFilingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddFilingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddFiling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddFilingAggregateArgs>(args: Subset<T, AddFilingAggregateArgs>): Prisma.PrismaPromise<GetAddFilingAggregateType<T>>

    /**
     * Group by AddFiling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddFilingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddFilingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddFilingGroupByArgs['orderBy'] }
        : { orderBy?: AddFilingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddFilingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddFilingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddFiling model
   */
  readonly fields: AddFilingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddFiling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddFilingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filingWastages<T extends AddFiling$filingWastagesArgs<ExtArgs> = {}>(args?: Subset<T, AddFiling$filingWastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filings<T extends AddFiling$filingsArgs<ExtArgs> = {}>(args?: Subset<T, AddFiling$filingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lotInfo<T extends AddFiling$lotInfoArgs<ExtArgs> = {}>(args?: Subset<T, AddFiling$lotInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lotFilingMapper<T extends AddFiling$lotFilingMapperArgs<ExtArgs> = {}>(args?: Subset<T, AddFiling$lotFilingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddFiling model
   */
  interface AddFilingFieldRefs {
    readonly id: FieldRef<"AddFiling", 'Int'>
    readonly createdAt: FieldRef<"AddFiling", 'DateTime'>
    readonly name: FieldRef<"AddFiling", 'String'>
    readonly phoneNumber: FieldRef<"AddFiling", 'String'>
    readonly address: FieldRef<"AddFiling", 'String'>
    readonly email: FieldRef<"AddFiling", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddFiling findUnique
   */
  export type AddFilingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter, which AddFiling to fetch.
     */
    where: AddFilingWhereUniqueInput
  }

  /**
   * AddFiling findUniqueOrThrow
   */
  export type AddFilingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter, which AddFiling to fetch.
     */
    where: AddFilingWhereUniqueInput
  }

  /**
   * AddFiling findFirst
   */
  export type AddFilingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter, which AddFiling to fetch.
     */
    where?: AddFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddFilings to fetch.
     */
    orderBy?: AddFilingOrderByWithRelationInput | AddFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddFilings.
     */
    cursor?: AddFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddFilings.
     */
    distinct?: AddFilingScalarFieldEnum | AddFilingScalarFieldEnum[]
  }

  /**
   * AddFiling findFirstOrThrow
   */
  export type AddFilingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter, which AddFiling to fetch.
     */
    where?: AddFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddFilings to fetch.
     */
    orderBy?: AddFilingOrderByWithRelationInput | AddFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddFilings.
     */
    cursor?: AddFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddFilings.
     */
    distinct?: AddFilingScalarFieldEnum | AddFilingScalarFieldEnum[]
  }

  /**
   * AddFiling findMany
   */
  export type AddFilingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter, which AddFilings to fetch.
     */
    where?: AddFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddFilings to fetch.
     */
    orderBy?: AddFilingOrderByWithRelationInput | AddFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddFilings.
     */
    cursor?: AddFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddFilings.
     */
    skip?: number
    distinct?: AddFilingScalarFieldEnum | AddFilingScalarFieldEnum[]
  }

  /**
   * AddFiling create
   */
  export type AddFilingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * The data needed to create a AddFiling.
     */
    data: XOR<AddFilingCreateInput, AddFilingUncheckedCreateInput>
  }

  /**
   * AddFiling createMany
   */
  export type AddFilingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddFilings.
     */
    data: AddFilingCreateManyInput | AddFilingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddFiling update
   */
  export type AddFilingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * The data needed to update a AddFiling.
     */
    data: XOR<AddFilingUpdateInput, AddFilingUncheckedUpdateInput>
    /**
     * Choose, which AddFiling to update.
     */
    where: AddFilingWhereUniqueInput
  }

  /**
   * AddFiling updateMany
   */
  export type AddFilingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddFilings.
     */
    data: XOR<AddFilingUpdateManyMutationInput, AddFilingUncheckedUpdateManyInput>
    /**
     * Filter which AddFilings to update
     */
    where?: AddFilingWhereInput
    /**
     * Limit how many AddFilings to update.
     */
    limit?: number
  }

  /**
   * AddFiling upsert
   */
  export type AddFilingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * The filter to search for the AddFiling to update in case it exists.
     */
    where: AddFilingWhereUniqueInput
    /**
     * In case the AddFiling found by the `where` argument doesn't exist, create a new AddFiling with this data.
     */
    create: XOR<AddFilingCreateInput, AddFilingUncheckedCreateInput>
    /**
     * In case the AddFiling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddFilingUpdateInput, AddFilingUncheckedUpdateInput>
  }

  /**
   * AddFiling delete
   */
  export type AddFilingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    /**
     * Filter which AddFiling to delete.
     */
    where: AddFilingWhereUniqueInput
  }

  /**
   * AddFiling deleteMany
   */
  export type AddFilingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddFilings to delete
     */
    where?: AddFilingWhereInput
    /**
     * Limit how many AddFilings to delete.
     */
    limit?: number
  }

  /**
   * AddFiling.filingWastages
   */
  export type AddFiling$filingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    where?: FilingWastageWhereInput
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    cursor?: FilingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * AddFiling.filings
   */
  export type AddFiling$filingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    where?: FilingEntryWhereInput
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    cursor?: FilingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingEntryScalarFieldEnum | FilingEntryScalarFieldEnum[]
  }

  /**
   * AddFiling.lotInfo
   */
  export type AddFiling$lotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    where?: LotInfoWhereInput
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    cursor?: LotInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * AddFiling.lotFilingMapper
   */
  export type AddFiling$lotFilingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    where?: LotFilingMapperWhereInput
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    cursor?: LotFilingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * AddFiling without action
   */
  export type AddFilingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
  }


  /**
   * Model AddSetting
   */

  export type AggregateAddSetting = {
    _count: AddSettingCountAggregateOutputType | null
    _avg: AddSettingAvgAggregateOutputType | null
    _sum: AddSettingSumAggregateOutputType | null
    _min: AddSettingMinAggregateOutputType | null
    _max: AddSettingMaxAggregateOutputType | null
  }

  export type AddSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type AddSettingSumAggregateOutputType = {
    id: number | null
  }

  export type AddSettingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddSettingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddSettingCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    phoneNumber: number
    address: number
    email: number
    _all: number
  }


  export type AddSettingAvgAggregateInputType = {
    id?: true
  }

  export type AddSettingSumAggregateInputType = {
    id?: true
  }

  export type AddSettingMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddSettingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddSettingCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
    _all?: true
  }

  export type AddSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddSetting to aggregate.
     */
    where?: AddSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSettings to fetch.
     */
    orderBy?: AddSettingOrderByWithRelationInput | AddSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddSettings
    **/
    _count?: true | AddSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddSettingMaxAggregateInputType
  }

  export type GetAddSettingAggregateType<T extends AddSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateAddSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddSetting[P]>
      : GetScalarType<T[P], AggregateAddSetting[P]>
  }




  export type AddSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddSettingWhereInput
    orderBy?: AddSettingOrderByWithAggregationInput | AddSettingOrderByWithAggregationInput[]
    by: AddSettingScalarFieldEnum[] | AddSettingScalarFieldEnum
    having?: AddSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddSettingCountAggregateInputType | true
    _avg?: AddSettingAvgAggregateInputType
    _sum?: AddSettingSumAggregateInputType
    _min?: AddSettingMinAggregateInputType
    _max?: AddSettingMaxAggregateInputType
  }

  export type AddSettingGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    phoneNumber: string | null
    address: string | null
    email: string | null
    _count: AddSettingCountAggregateOutputType | null
    _avg: AddSettingAvgAggregateOutputType | null
    _sum: AddSettingSumAggregateOutputType | null
    _min: AddSettingMinAggregateOutputType | null
    _max: AddSettingMaxAggregateOutputType | null
  }

  type GetAddSettingGroupByPayload<T extends AddSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddSettingGroupByOutputType[P]>
            : GetScalarType<T[P], AddSettingGroupByOutputType[P]>
        }
      >
    >


  export type AddSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
    settings?: boolean | AddSetting$settingsArgs<ExtArgs>
    settingMapper?: boolean | AddSetting$settingMapperArgs<ExtArgs>
    lotInfo?: boolean | AddSetting$lotInfoArgs<ExtArgs>
    _count?: boolean | AddSettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addSetting"]>



  export type AddSettingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
  }

  export type AddSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "phoneNumber" | "address" | "email", ExtArgs["result"]["addSetting"]>
  export type AddSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | AddSetting$settingsArgs<ExtArgs>
    settingMapper?: boolean | AddSetting$settingMapperArgs<ExtArgs>
    lotInfo?: boolean | AddSetting$lotInfoArgs<ExtArgs>
    _count?: boolean | AddSettingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddSetting"
    objects: {
      settings: Prisma.$SettingEntryPayload<ExtArgs>[]
      settingMapper: Prisma.$LotSettingMapperPayload<ExtArgs>[]
      lotInfo: Prisma.$LotInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      phoneNumber: string | null
      address: string | null
      email: string | null
    }, ExtArgs["result"]["addSetting"]>
    composites: {}
  }

  type AddSettingGetPayload<S extends boolean | null | undefined | AddSettingDefaultArgs> = $Result.GetResult<Prisma.$AddSettingPayload, S>

  type AddSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddSettingCountAggregateInputType | true
    }

  export interface AddSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddSetting'], meta: { name: 'AddSetting' } }
    /**
     * Find zero or one AddSetting that matches the filter.
     * @param {AddSettingFindUniqueArgs} args - Arguments to find a AddSetting
     * @example
     * // Get one AddSetting
     * const addSetting = await prisma.addSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddSettingFindUniqueArgs>(args: SelectSubset<T, AddSettingFindUniqueArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddSettingFindUniqueOrThrowArgs} args - Arguments to find a AddSetting
     * @example
     * // Get one AddSetting
     * const addSetting = await prisma.addSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, AddSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingFindFirstArgs} args - Arguments to find a AddSetting
     * @example
     * // Get one AddSetting
     * const addSetting = await prisma.addSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddSettingFindFirstArgs>(args?: SelectSubset<T, AddSettingFindFirstArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingFindFirstOrThrowArgs} args - Arguments to find a AddSetting
     * @example
     * // Get one AddSetting
     * const addSetting = await prisma.addSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, AddSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddSettings
     * const addSettings = await prisma.addSetting.findMany()
     * 
     * // Get first 10 AddSettings
     * const addSettings = await prisma.addSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addSettingWithIdOnly = await prisma.addSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddSettingFindManyArgs>(args?: SelectSubset<T, AddSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddSetting.
     * @param {AddSettingCreateArgs} args - Arguments to create a AddSetting.
     * @example
     * // Create one AddSetting
     * const AddSetting = await prisma.addSetting.create({
     *   data: {
     *     // ... data to create a AddSetting
     *   }
     * })
     * 
     */
    create<T extends AddSettingCreateArgs>(args: SelectSubset<T, AddSettingCreateArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddSettings.
     * @param {AddSettingCreateManyArgs} args - Arguments to create many AddSettings.
     * @example
     * // Create many AddSettings
     * const addSetting = await prisma.addSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddSettingCreateManyArgs>(args?: SelectSubset<T, AddSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddSetting.
     * @param {AddSettingDeleteArgs} args - Arguments to delete one AddSetting.
     * @example
     * // Delete one AddSetting
     * const AddSetting = await prisma.addSetting.delete({
     *   where: {
     *     // ... filter to delete one AddSetting
     *   }
     * })
     * 
     */
    delete<T extends AddSettingDeleteArgs>(args: SelectSubset<T, AddSettingDeleteArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddSetting.
     * @param {AddSettingUpdateArgs} args - Arguments to update one AddSetting.
     * @example
     * // Update one AddSetting
     * const addSetting = await prisma.addSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddSettingUpdateArgs>(args: SelectSubset<T, AddSettingUpdateArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddSettings.
     * @param {AddSettingDeleteManyArgs} args - Arguments to filter AddSettings to delete.
     * @example
     * // Delete a few AddSettings
     * const { count } = await prisma.addSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddSettingDeleteManyArgs>(args?: SelectSubset<T, AddSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddSettings
     * const addSetting = await prisma.addSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddSettingUpdateManyArgs>(args: SelectSubset<T, AddSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddSetting.
     * @param {AddSettingUpsertArgs} args - Arguments to update or create a AddSetting.
     * @example
     * // Update or create a AddSetting
     * const addSetting = await prisma.addSetting.upsert({
     *   create: {
     *     // ... data to create a AddSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddSetting we want to update
     *   }
     * })
     */
    upsert<T extends AddSettingUpsertArgs>(args: SelectSubset<T, AddSettingUpsertArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingCountArgs} args - Arguments to filter AddSettings to count.
     * @example
     * // Count the number of AddSettings
     * const count = await prisma.addSetting.count({
     *   where: {
     *     // ... the filter for the AddSettings we want to count
     *   }
     * })
    **/
    count<T extends AddSettingCountArgs>(
      args?: Subset<T, AddSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddSettingAggregateArgs>(args: Subset<T, AddSettingAggregateArgs>): Prisma.PrismaPromise<GetAddSettingAggregateType<T>>

    /**
     * Group by AddSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddSettingGroupByArgs['orderBy'] }
        : { orderBy?: AddSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddSetting model
   */
  readonly fields: AddSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settings<T extends AddSetting$settingsArgs<ExtArgs> = {}>(args?: Subset<T, AddSetting$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingMapper<T extends AddSetting$settingMapperArgs<ExtArgs> = {}>(args?: Subset<T, AddSetting$settingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lotInfo<T extends AddSetting$lotInfoArgs<ExtArgs> = {}>(args?: Subset<T, AddSetting$lotInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddSetting model
   */
  interface AddSettingFieldRefs {
    readonly id: FieldRef<"AddSetting", 'Int'>
    readonly createdAt: FieldRef<"AddSetting", 'DateTime'>
    readonly name: FieldRef<"AddSetting", 'String'>
    readonly phoneNumber: FieldRef<"AddSetting", 'String'>
    readonly address: FieldRef<"AddSetting", 'String'>
    readonly email: FieldRef<"AddSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddSetting findUnique
   */
  export type AddSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter, which AddSetting to fetch.
     */
    where: AddSettingWhereUniqueInput
  }

  /**
   * AddSetting findUniqueOrThrow
   */
  export type AddSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter, which AddSetting to fetch.
     */
    where: AddSettingWhereUniqueInput
  }

  /**
   * AddSetting findFirst
   */
  export type AddSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter, which AddSetting to fetch.
     */
    where?: AddSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSettings to fetch.
     */
    orderBy?: AddSettingOrderByWithRelationInput | AddSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddSettings.
     */
    cursor?: AddSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddSettings.
     */
    distinct?: AddSettingScalarFieldEnum | AddSettingScalarFieldEnum[]
  }

  /**
   * AddSetting findFirstOrThrow
   */
  export type AddSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter, which AddSetting to fetch.
     */
    where?: AddSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSettings to fetch.
     */
    orderBy?: AddSettingOrderByWithRelationInput | AddSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddSettings.
     */
    cursor?: AddSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddSettings.
     */
    distinct?: AddSettingScalarFieldEnum | AddSettingScalarFieldEnum[]
  }

  /**
   * AddSetting findMany
   */
  export type AddSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter, which AddSettings to fetch.
     */
    where?: AddSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSettings to fetch.
     */
    orderBy?: AddSettingOrderByWithRelationInput | AddSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddSettings.
     */
    cursor?: AddSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSettings.
     */
    skip?: number
    distinct?: AddSettingScalarFieldEnum | AddSettingScalarFieldEnum[]
  }

  /**
   * AddSetting create
   */
  export type AddSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a AddSetting.
     */
    data: XOR<AddSettingCreateInput, AddSettingUncheckedCreateInput>
  }

  /**
   * AddSetting createMany
   */
  export type AddSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddSettings.
     */
    data: AddSettingCreateManyInput | AddSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddSetting update
   */
  export type AddSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a AddSetting.
     */
    data: XOR<AddSettingUpdateInput, AddSettingUncheckedUpdateInput>
    /**
     * Choose, which AddSetting to update.
     */
    where: AddSettingWhereUniqueInput
  }

  /**
   * AddSetting updateMany
   */
  export type AddSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddSettings.
     */
    data: XOR<AddSettingUpdateManyMutationInput, AddSettingUncheckedUpdateManyInput>
    /**
     * Filter which AddSettings to update
     */
    where?: AddSettingWhereInput
    /**
     * Limit how many AddSettings to update.
     */
    limit?: number
  }

  /**
   * AddSetting upsert
   */
  export type AddSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the AddSetting to update in case it exists.
     */
    where: AddSettingWhereUniqueInput
    /**
     * In case the AddSetting found by the `where` argument doesn't exist, create a new AddSetting with this data.
     */
    create: XOR<AddSettingCreateInput, AddSettingUncheckedCreateInput>
    /**
     * In case the AddSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddSettingUpdateInput, AddSettingUncheckedUpdateInput>
  }

  /**
   * AddSetting delete
   */
  export type AddSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    /**
     * Filter which AddSetting to delete.
     */
    where: AddSettingWhereUniqueInput
  }

  /**
   * AddSetting deleteMany
   */
  export type AddSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddSettings to delete
     */
    where?: AddSettingWhereInput
    /**
     * Limit how many AddSettings to delete.
     */
    limit?: number
  }

  /**
   * AddSetting.settings
   */
  export type AddSetting$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    where?: SettingEntryWhereInput
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    cursor?: SettingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * AddSetting.settingMapper
   */
  export type AddSetting$settingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    where?: LotSettingMapperWhereInput
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    cursor?: LotSettingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * AddSetting.lotInfo
   */
  export type AddSetting$lotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    where?: LotInfoWhereInput
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    cursor?: LotInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * AddSetting without action
   */
  export type AddSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
  }


  /**
   * Model AddBuffing
   */

  export type AggregateAddBuffing = {
    _count: AddBuffingCountAggregateOutputType | null
    _avg: AddBuffingAvgAggregateOutputType | null
    _sum: AddBuffingSumAggregateOutputType | null
    _min: AddBuffingMinAggregateOutputType | null
    _max: AddBuffingMaxAggregateOutputType | null
  }

  export type AddBuffingAvgAggregateOutputType = {
    id: number | null
  }

  export type AddBuffingSumAggregateOutputType = {
    id: number | null
  }

  export type AddBuffingMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddBuffingMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    email: string | null
  }

  export type AddBuffingCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    phoneNumber: number
    address: number
    email: number
    _all: number
  }


  export type AddBuffingAvgAggregateInputType = {
    id?: true
  }

  export type AddBuffingSumAggregateInputType = {
    id?: true
  }

  export type AddBuffingMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddBuffingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
  }

  export type AddBuffingCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    phoneNumber?: true
    address?: true
    email?: true
    _all?: true
  }

  export type AddBuffingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddBuffing to aggregate.
     */
    where?: AddBuffingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddBuffings to fetch.
     */
    orderBy?: AddBuffingOrderByWithRelationInput | AddBuffingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddBuffingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddBuffings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddBuffings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddBuffings
    **/
    _count?: true | AddBuffingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddBuffingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddBuffingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddBuffingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddBuffingMaxAggregateInputType
  }

  export type GetAddBuffingAggregateType<T extends AddBuffingAggregateArgs> = {
        [P in keyof T & keyof AggregateAddBuffing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddBuffing[P]>
      : GetScalarType<T[P], AggregateAddBuffing[P]>
  }




  export type AddBuffingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddBuffingWhereInput
    orderBy?: AddBuffingOrderByWithAggregationInput | AddBuffingOrderByWithAggregationInput[]
    by: AddBuffingScalarFieldEnum[] | AddBuffingScalarFieldEnum
    having?: AddBuffingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddBuffingCountAggregateInputType | true
    _avg?: AddBuffingAvgAggregateInputType
    _sum?: AddBuffingSumAggregateInputType
    _min?: AddBuffingMinAggregateInputType
    _max?: AddBuffingMaxAggregateInputType
  }

  export type AddBuffingGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    phoneNumber: string | null
    address: string | null
    email: string | null
    _count: AddBuffingCountAggregateOutputType | null
    _avg: AddBuffingAvgAggregateOutputType | null
    _sum: AddBuffingSumAggregateOutputType | null
    _min: AddBuffingMinAggregateOutputType | null
    _max: AddBuffingMaxAggregateOutputType | null
  }

  type GetAddBuffingGroupByPayload<T extends AddBuffingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddBuffingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddBuffingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddBuffingGroupByOutputType[P]>
            : GetScalarType<T[P], AddBuffingGroupByOutputType[P]>
        }
      >
    >


  export type AddBuffingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
    buffings?: boolean | AddBuffing$buffingsArgs<ExtArgs>
    buffingMapper?: boolean | AddBuffing$buffingMapperArgs<ExtArgs>
    lotInfo?: boolean | AddBuffing$lotInfoArgs<ExtArgs>
    buffingWastages?: boolean | AddBuffing$buffingWastagesArgs<ExtArgs>
    _count?: boolean | AddBuffingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addBuffing"]>



  export type AddBuffingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    email?: boolean
  }

  export type AddBuffingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "phoneNumber" | "address" | "email", ExtArgs["result"]["addBuffing"]>
  export type AddBuffingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffings?: boolean | AddBuffing$buffingsArgs<ExtArgs>
    buffingMapper?: boolean | AddBuffing$buffingMapperArgs<ExtArgs>
    lotInfo?: boolean | AddBuffing$lotInfoArgs<ExtArgs>
    buffingWastages?: boolean | AddBuffing$buffingWastagesArgs<ExtArgs>
    _count?: boolean | AddBuffingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddBuffingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddBuffing"
    objects: {
      buffings: Prisma.$BuffingEntryPayload<ExtArgs>[]
      buffingMapper: Prisma.$LotBuffingMapperPayload<ExtArgs>[]
      lotInfo: Prisma.$LotInfoPayload<ExtArgs>[]
      buffingWastages: Prisma.$BuffingWastagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      phoneNumber: string | null
      address: string | null
      email: string | null
    }, ExtArgs["result"]["addBuffing"]>
    composites: {}
  }

  type AddBuffingGetPayload<S extends boolean | null | undefined | AddBuffingDefaultArgs> = $Result.GetResult<Prisma.$AddBuffingPayload, S>

  type AddBuffingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddBuffingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddBuffingCountAggregateInputType | true
    }

  export interface AddBuffingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddBuffing'], meta: { name: 'AddBuffing' } }
    /**
     * Find zero or one AddBuffing that matches the filter.
     * @param {AddBuffingFindUniqueArgs} args - Arguments to find a AddBuffing
     * @example
     * // Get one AddBuffing
     * const addBuffing = await prisma.addBuffing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddBuffingFindUniqueArgs>(args: SelectSubset<T, AddBuffingFindUniqueArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddBuffing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddBuffingFindUniqueOrThrowArgs} args - Arguments to find a AddBuffing
     * @example
     * // Get one AddBuffing
     * const addBuffing = await prisma.addBuffing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddBuffingFindUniqueOrThrowArgs>(args: SelectSubset<T, AddBuffingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddBuffing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingFindFirstArgs} args - Arguments to find a AddBuffing
     * @example
     * // Get one AddBuffing
     * const addBuffing = await prisma.addBuffing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddBuffingFindFirstArgs>(args?: SelectSubset<T, AddBuffingFindFirstArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddBuffing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingFindFirstOrThrowArgs} args - Arguments to find a AddBuffing
     * @example
     * // Get one AddBuffing
     * const addBuffing = await prisma.addBuffing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddBuffingFindFirstOrThrowArgs>(args?: SelectSubset<T, AddBuffingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddBuffings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddBuffings
     * const addBuffings = await prisma.addBuffing.findMany()
     * 
     * // Get first 10 AddBuffings
     * const addBuffings = await prisma.addBuffing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addBuffingWithIdOnly = await prisma.addBuffing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddBuffingFindManyArgs>(args?: SelectSubset<T, AddBuffingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddBuffing.
     * @param {AddBuffingCreateArgs} args - Arguments to create a AddBuffing.
     * @example
     * // Create one AddBuffing
     * const AddBuffing = await prisma.addBuffing.create({
     *   data: {
     *     // ... data to create a AddBuffing
     *   }
     * })
     * 
     */
    create<T extends AddBuffingCreateArgs>(args: SelectSubset<T, AddBuffingCreateArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddBuffings.
     * @param {AddBuffingCreateManyArgs} args - Arguments to create many AddBuffings.
     * @example
     * // Create many AddBuffings
     * const addBuffing = await prisma.addBuffing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddBuffingCreateManyArgs>(args?: SelectSubset<T, AddBuffingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddBuffing.
     * @param {AddBuffingDeleteArgs} args - Arguments to delete one AddBuffing.
     * @example
     * // Delete one AddBuffing
     * const AddBuffing = await prisma.addBuffing.delete({
     *   where: {
     *     // ... filter to delete one AddBuffing
     *   }
     * })
     * 
     */
    delete<T extends AddBuffingDeleteArgs>(args: SelectSubset<T, AddBuffingDeleteArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddBuffing.
     * @param {AddBuffingUpdateArgs} args - Arguments to update one AddBuffing.
     * @example
     * // Update one AddBuffing
     * const addBuffing = await prisma.addBuffing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddBuffingUpdateArgs>(args: SelectSubset<T, AddBuffingUpdateArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddBuffings.
     * @param {AddBuffingDeleteManyArgs} args - Arguments to filter AddBuffings to delete.
     * @example
     * // Delete a few AddBuffings
     * const { count } = await prisma.addBuffing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddBuffingDeleteManyArgs>(args?: SelectSubset<T, AddBuffingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddBuffings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddBuffings
     * const addBuffing = await prisma.addBuffing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddBuffingUpdateManyArgs>(args: SelectSubset<T, AddBuffingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddBuffing.
     * @param {AddBuffingUpsertArgs} args - Arguments to update or create a AddBuffing.
     * @example
     * // Update or create a AddBuffing
     * const addBuffing = await prisma.addBuffing.upsert({
     *   create: {
     *     // ... data to create a AddBuffing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddBuffing we want to update
     *   }
     * })
     */
    upsert<T extends AddBuffingUpsertArgs>(args: SelectSubset<T, AddBuffingUpsertArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddBuffings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingCountArgs} args - Arguments to filter AddBuffings to count.
     * @example
     * // Count the number of AddBuffings
     * const count = await prisma.addBuffing.count({
     *   where: {
     *     // ... the filter for the AddBuffings we want to count
     *   }
     * })
    **/
    count<T extends AddBuffingCountArgs>(
      args?: Subset<T, AddBuffingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddBuffingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddBuffing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddBuffingAggregateArgs>(args: Subset<T, AddBuffingAggregateArgs>): Prisma.PrismaPromise<GetAddBuffingAggregateType<T>>

    /**
     * Group by AddBuffing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddBuffingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddBuffingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddBuffingGroupByArgs['orderBy'] }
        : { orderBy?: AddBuffingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddBuffingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddBuffingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddBuffing model
   */
  readonly fields: AddBuffingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddBuffing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddBuffingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buffings<T extends AddBuffing$buffingsArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffing$buffingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingMapper<T extends AddBuffing$buffingMapperArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffing$buffingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lotInfo<T extends AddBuffing$lotInfoArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffing$lotInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingWastages<T extends AddBuffing$buffingWastagesArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffing$buffingWastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddBuffing model
   */
  interface AddBuffingFieldRefs {
    readonly id: FieldRef<"AddBuffing", 'Int'>
    readonly createdAt: FieldRef<"AddBuffing", 'DateTime'>
    readonly name: FieldRef<"AddBuffing", 'String'>
    readonly phoneNumber: FieldRef<"AddBuffing", 'String'>
    readonly address: FieldRef<"AddBuffing", 'String'>
    readonly email: FieldRef<"AddBuffing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddBuffing findUnique
   */
  export type AddBuffingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter, which AddBuffing to fetch.
     */
    where: AddBuffingWhereUniqueInput
  }

  /**
   * AddBuffing findUniqueOrThrow
   */
  export type AddBuffingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter, which AddBuffing to fetch.
     */
    where: AddBuffingWhereUniqueInput
  }

  /**
   * AddBuffing findFirst
   */
  export type AddBuffingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter, which AddBuffing to fetch.
     */
    where?: AddBuffingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddBuffings to fetch.
     */
    orderBy?: AddBuffingOrderByWithRelationInput | AddBuffingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddBuffings.
     */
    cursor?: AddBuffingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddBuffings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddBuffings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddBuffings.
     */
    distinct?: AddBuffingScalarFieldEnum | AddBuffingScalarFieldEnum[]
  }

  /**
   * AddBuffing findFirstOrThrow
   */
  export type AddBuffingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter, which AddBuffing to fetch.
     */
    where?: AddBuffingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddBuffings to fetch.
     */
    orderBy?: AddBuffingOrderByWithRelationInput | AddBuffingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddBuffings.
     */
    cursor?: AddBuffingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddBuffings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddBuffings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddBuffings.
     */
    distinct?: AddBuffingScalarFieldEnum | AddBuffingScalarFieldEnum[]
  }

  /**
   * AddBuffing findMany
   */
  export type AddBuffingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter, which AddBuffings to fetch.
     */
    where?: AddBuffingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddBuffings to fetch.
     */
    orderBy?: AddBuffingOrderByWithRelationInput | AddBuffingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddBuffings.
     */
    cursor?: AddBuffingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddBuffings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddBuffings.
     */
    skip?: number
    distinct?: AddBuffingScalarFieldEnum | AddBuffingScalarFieldEnum[]
  }

  /**
   * AddBuffing create
   */
  export type AddBuffingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * The data needed to create a AddBuffing.
     */
    data: XOR<AddBuffingCreateInput, AddBuffingUncheckedCreateInput>
  }

  /**
   * AddBuffing createMany
   */
  export type AddBuffingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddBuffings.
     */
    data: AddBuffingCreateManyInput | AddBuffingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddBuffing update
   */
  export type AddBuffingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * The data needed to update a AddBuffing.
     */
    data: XOR<AddBuffingUpdateInput, AddBuffingUncheckedUpdateInput>
    /**
     * Choose, which AddBuffing to update.
     */
    where: AddBuffingWhereUniqueInput
  }

  /**
   * AddBuffing updateMany
   */
  export type AddBuffingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddBuffings.
     */
    data: XOR<AddBuffingUpdateManyMutationInput, AddBuffingUncheckedUpdateManyInput>
    /**
     * Filter which AddBuffings to update
     */
    where?: AddBuffingWhereInput
    /**
     * Limit how many AddBuffings to update.
     */
    limit?: number
  }

  /**
   * AddBuffing upsert
   */
  export type AddBuffingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * The filter to search for the AddBuffing to update in case it exists.
     */
    where: AddBuffingWhereUniqueInput
    /**
     * In case the AddBuffing found by the `where` argument doesn't exist, create a new AddBuffing with this data.
     */
    create: XOR<AddBuffingCreateInput, AddBuffingUncheckedCreateInput>
    /**
     * In case the AddBuffing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddBuffingUpdateInput, AddBuffingUncheckedUpdateInput>
  }

  /**
   * AddBuffing delete
   */
  export type AddBuffingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    /**
     * Filter which AddBuffing to delete.
     */
    where: AddBuffingWhereUniqueInput
  }

  /**
   * AddBuffing deleteMany
   */
  export type AddBuffingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddBuffings to delete
     */
    where?: AddBuffingWhereInput
    /**
     * Limit how many AddBuffings to delete.
     */
    limit?: number
  }

  /**
   * AddBuffing.buffings
   */
  export type AddBuffing$buffingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    where?: BuffingEntryWhereInput
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    cursor?: BuffingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * AddBuffing.buffingMapper
   */
  export type AddBuffing$buffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    cursor?: LotBuffingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * AddBuffing.lotInfo
   */
  export type AddBuffing$lotInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    where?: LotInfoWhereInput
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    cursor?: LotInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * AddBuffing.buffingWastages
   */
  export type AddBuffing$buffingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    where?: BuffingWastageWhereInput
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    cursor?: BuffingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * AddBuffing without action
   */
  export type AddBuffingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
  }


  /**
   * Model AddSupplierItem
   */

  export type AggregateAddSupplierItem = {
    _count: AddSupplierItemCountAggregateOutputType | null
    _avg: AddSupplierItemAvgAggregateOutputType | null
    _sum: AddSupplierItemSumAggregateOutputType | null
    _min: AddSupplierItemMinAggregateOutputType | null
    _max: AddSupplierItemMaxAggregateOutputType | null
  }

  export type AddSupplierItemAvgAggregateOutputType = {
    id: number | null
  }

  export type AddSupplierItemSumAggregateOutputType = {
    id: number | null
  }

  export type AddSupplierItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
  }

  export type AddSupplierItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
  }

  export type AddSupplierItemCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    email: number
    phoneNumber: number
    address: number
    _all: number
  }


  export type AddSupplierItemAvgAggregateInputType = {
    id?: true
  }

  export type AddSupplierItemSumAggregateInputType = {
    id?: true
  }

  export type AddSupplierItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    email?: true
    phoneNumber?: true
    address?: true
  }

  export type AddSupplierItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    email?: true
    phoneNumber?: true
    address?: true
  }

  export type AddSupplierItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    email?: true
    phoneNumber?: true
    address?: true
    _all?: true
  }

  export type AddSupplierItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddSupplierItem to aggregate.
     */
    where?: AddSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSupplierItems to fetch.
     */
    orderBy?: AddSupplierItemOrderByWithRelationInput | AddSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddSupplierItems
    **/
    _count?: true | AddSupplierItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddSupplierItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddSupplierItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddSupplierItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddSupplierItemMaxAggregateInputType
  }

  export type GetAddSupplierItemAggregateType<T extends AddSupplierItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAddSupplierItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddSupplierItem[P]>
      : GetScalarType<T[P], AggregateAddSupplierItem[P]>
  }




  export type AddSupplierItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddSupplierItemWhereInput
    orderBy?: AddSupplierItemOrderByWithAggregationInput | AddSupplierItemOrderByWithAggregationInput[]
    by: AddSupplierItemScalarFieldEnum[] | AddSupplierItemScalarFieldEnum
    having?: AddSupplierItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddSupplierItemCountAggregateInputType | true
    _avg?: AddSupplierItemAvgAggregateInputType
    _sum?: AddSupplierItemSumAggregateInputType
    _min?: AddSupplierItemMinAggregateInputType
    _max?: AddSupplierItemMaxAggregateInputType
  }

  export type AddSupplierItemGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    email: string | null
    phoneNumber: string | null
    address: string | null
    _count: AddSupplierItemCountAggregateOutputType | null
    _avg: AddSupplierItemAvgAggregateOutputType | null
    _sum: AddSupplierItemSumAggregateOutputType | null
    _min: AddSupplierItemMinAggregateOutputType | null
    _max: AddSupplierItemMaxAggregateOutputType | null
  }

  type GetAddSupplierItemGroupByPayload<T extends AddSupplierItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddSupplierItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddSupplierItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddSupplierItemGroupByOutputType[P]>
            : GetScalarType<T[P], AddSupplierItemGroupByOutputType[P]>
        }
      >
    >


  export type AddSupplierItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
  }, ExtArgs["result"]["addSupplierItem"]>



  export type AddSupplierItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
  }

  export type AddSupplierItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "email" | "phoneNumber" | "address", ExtArgs["result"]["addSupplierItem"]>

  export type $AddSupplierItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddSupplierItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      email: string | null
      phoneNumber: string | null
      address: string | null
    }, ExtArgs["result"]["addSupplierItem"]>
    composites: {}
  }

  type AddSupplierItemGetPayload<S extends boolean | null | undefined | AddSupplierItemDefaultArgs> = $Result.GetResult<Prisma.$AddSupplierItemPayload, S>

  type AddSupplierItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddSupplierItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddSupplierItemCountAggregateInputType | true
    }

  export interface AddSupplierItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddSupplierItem'], meta: { name: 'AddSupplierItem' } }
    /**
     * Find zero or one AddSupplierItem that matches the filter.
     * @param {AddSupplierItemFindUniqueArgs} args - Arguments to find a AddSupplierItem
     * @example
     * // Get one AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddSupplierItemFindUniqueArgs>(args: SelectSubset<T, AddSupplierItemFindUniqueArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddSupplierItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddSupplierItemFindUniqueOrThrowArgs} args - Arguments to find a AddSupplierItem
     * @example
     * // Get one AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddSupplierItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AddSupplierItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddSupplierItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemFindFirstArgs} args - Arguments to find a AddSupplierItem
     * @example
     * // Get one AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddSupplierItemFindFirstArgs>(args?: SelectSubset<T, AddSupplierItemFindFirstArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddSupplierItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemFindFirstOrThrowArgs} args - Arguments to find a AddSupplierItem
     * @example
     * // Get one AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddSupplierItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AddSupplierItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddSupplierItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddSupplierItems
     * const addSupplierItems = await prisma.addSupplierItem.findMany()
     * 
     * // Get first 10 AddSupplierItems
     * const addSupplierItems = await prisma.addSupplierItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addSupplierItemWithIdOnly = await prisma.addSupplierItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddSupplierItemFindManyArgs>(args?: SelectSubset<T, AddSupplierItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddSupplierItem.
     * @param {AddSupplierItemCreateArgs} args - Arguments to create a AddSupplierItem.
     * @example
     * // Create one AddSupplierItem
     * const AddSupplierItem = await prisma.addSupplierItem.create({
     *   data: {
     *     // ... data to create a AddSupplierItem
     *   }
     * })
     * 
     */
    create<T extends AddSupplierItemCreateArgs>(args: SelectSubset<T, AddSupplierItemCreateArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddSupplierItems.
     * @param {AddSupplierItemCreateManyArgs} args - Arguments to create many AddSupplierItems.
     * @example
     * // Create many AddSupplierItems
     * const addSupplierItem = await prisma.addSupplierItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddSupplierItemCreateManyArgs>(args?: SelectSubset<T, AddSupplierItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddSupplierItem.
     * @param {AddSupplierItemDeleteArgs} args - Arguments to delete one AddSupplierItem.
     * @example
     * // Delete one AddSupplierItem
     * const AddSupplierItem = await prisma.addSupplierItem.delete({
     *   where: {
     *     // ... filter to delete one AddSupplierItem
     *   }
     * })
     * 
     */
    delete<T extends AddSupplierItemDeleteArgs>(args: SelectSubset<T, AddSupplierItemDeleteArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddSupplierItem.
     * @param {AddSupplierItemUpdateArgs} args - Arguments to update one AddSupplierItem.
     * @example
     * // Update one AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddSupplierItemUpdateArgs>(args: SelectSubset<T, AddSupplierItemUpdateArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddSupplierItems.
     * @param {AddSupplierItemDeleteManyArgs} args - Arguments to filter AddSupplierItems to delete.
     * @example
     * // Delete a few AddSupplierItems
     * const { count } = await prisma.addSupplierItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddSupplierItemDeleteManyArgs>(args?: SelectSubset<T, AddSupplierItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddSupplierItems
     * const addSupplierItem = await prisma.addSupplierItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddSupplierItemUpdateManyArgs>(args: SelectSubset<T, AddSupplierItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddSupplierItem.
     * @param {AddSupplierItemUpsertArgs} args - Arguments to update or create a AddSupplierItem.
     * @example
     * // Update or create a AddSupplierItem
     * const addSupplierItem = await prisma.addSupplierItem.upsert({
     *   create: {
     *     // ... data to create a AddSupplierItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddSupplierItem we want to update
     *   }
     * })
     */
    upsert<T extends AddSupplierItemUpsertArgs>(args: SelectSubset<T, AddSupplierItemUpsertArgs<ExtArgs>>): Prisma__AddSupplierItemClient<$Result.GetResult<Prisma.$AddSupplierItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddSupplierItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemCountArgs} args - Arguments to filter AddSupplierItems to count.
     * @example
     * // Count the number of AddSupplierItems
     * const count = await prisma.addSupplierItem.count({
     *   where: {
     *     // ... the filter for the AddSupplierItems we want to count
     *   }
     * })
    **/
    count<T extends AddSupplierItemCountArgs>(
      args?: Subset<T, AddSupplierItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddSupplierItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddSupplierItemAggregateArgs>(args: Subset<T, AddSupplierItemAggregateArgs>): Prisma.PrismaPromise<GetAddSupplierItemAggregateType<T>>

    /**
     * Group by AddSupplierItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddSupplierItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddSupplierItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddSupplierItemGroupByArgs['orderBy'] }
        : { orderBy?: AddSupplierItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddSupplierItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddSupplierItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddSupplierItem model
   */
  readonly fields: AddSupplierItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddSupplierItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddSupplierItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddSupplierItem model
   */
  interface AddSupplierItemFieldRefs {
    readonly id: FieldRef<"AddSupplierItem", 'Int'>
    readonly createdAt: FieldRef<"AddSupplierItem", 'DateTime'>
    readonly name: FieldRef<"AddSupplierItem", 'String'>
    readonly email: FieldRef<"AddSupplierItem", 'String'>
    readonly phoneNumber: FieldRef<"AddSupplierItem", 'String'>
    readonly address: FieldRef<"AddSupplierItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddSupplierItem findUnique
   */
  export type AddSupplierItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter, which AddSupplierItem to fetch.
     */
    where: AddSupplierItemWhereUniqueInput
  }

  /**
   * AddSupplierItem findUniqueOrThrow
   */
  export type AddSupplierItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter, which AddSupplierItem to fetch.
     */
    where: AddSupplierItemWhereUniqueInput
  }

  /**
   * AddSupplierItem findFirst
   */
  export type AddSupplierItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter, which AddSupplierItem to fetch.
     */
    where?: AddSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSupplierItems to fetch.
     */
    orderBy?: AddSupplierItemOrderByWithRelationInput | AddSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddSupplierItems.
     */
    cursor?: AddSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddSupplierItems.
     */
    distinct?: AddSupplierItemScalarFieldEnum | AddSupplierItemScalarFieldEnum[]
  }

  /**
   * AddSupplierItem findFirstOrThrow
   */
  export type AddSupplierItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter, which AddSupplierItem to fetch.
     */
    where?: AddSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSupplierItems to fetch.
     */
    orderBy?: AddSupplierItemOrderByWithRelationInput | AddSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddSupplierItems.
     */
    cursor?: AddSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSupplierItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddSupplierItems.
     */
    distinct?: AddSupplierItemScalarFieldEnum | AddSupplierItemScalarFieldEnum[]
  }

  /**
   * AddSupplierItem findMany
   */
  export type AddSupplierItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter, which AddSupplierItems to fetch.
     */
    where?: AddSupplierItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddSupplierItems to fetch.
     */
    orderBy?: AddSupplierItemOrderByWithRelationInput | AddSupplierItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddSupplierItems.
     */
    cursor?: AddSupplierItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddSupplierItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddSupplierItems.
     */
    skip?: number
    distinct?: AddSupplierItemScalarFieldEnum | AddSupplierItemScalarFieldEnum[]
  }

  /**
   * AddSupplierItem create
   */
  export type AddSupplierItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * The data needed to create a AddSupplierItem.
     */
    data: XOR<AddSupplierItemCreateInput, AddSupplierItemUncheckedCreateInput>
  }

  /**
   * AddSupplierItem createMany
   */
  export type AddSupplierItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddSupplierItems.
     */
    data: AddSupplierItemCreateManyInput | AddSupplierItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddSupplierItem update
   */
  export type AddSupplierItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * The data needed to update a AddSupplierItem.
     */
    data: XOR<AddSupplierItemUpdateInput, AddSupplierItemUncheckedUpdateInput>
    /**
     * Choose, which AddSupplierItem to update.
     */
    where: AddSupplierItemWhereUniqueInput
  }

  /**
   * AddSupplierItem updateMany
   */
  export type AddSupplierItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddSupplierItems.
     */
    data: XOR<AddSupplierItemUpdateManyMutationInput, AddSupplierItemUncheckedUpdateManyInput>
    /**
     * Filter which AddSupplierItems to update
     */
    where?: AddSupplierItemWhereInput
    /**
     * Limit how many AddSupplierItems to update.
     */
    limit?: number
  }

  /**
   * AddSupplierItem upsert
   */
  export type AddSupplierItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * The filter to search for the AddSupplierItem to update in case it exists.
     */
    where: AddSupplierItemWhereUniqueInput
    /**
     * In case the AddSupplierItem found by the `where` argument doesn't exist, create a new AddSupplierItem with this data.
     */
    create: XOR<AddSupplierItemCreateInput, AddSupplierItemUncheckedCreateInput>
    /**
     * In case the AddSupplierItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddSupplierItemUpdateInput, AddSupplierItemUncheckedUpdateInput>
  }

  /**
   * AddSupplierItem delete
   */
  export type AddSupplierItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
    /**
     * Filter which AddSupplierItem to delete.
     */
    where: AddSupplierItemWhereUniqueInput
  }

  /**
   * AddSupplierItem deleteMany
   */
  export type AddSupplierItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddSupplierItems to delete
     */
    where?: AddSupplierItemWhereInput
    /**
     * Limit how many AddSupplierItems to delete.
     */
    limit?: number
  }

  /**
   * AddSupplierItem without action
   */
  export type AddSupplierItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSupplierItem
     */
    select?: AddSupplierItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSupplierItem
     */
    omit?: AddSupplierItemOmit<ExtArgs> | null
  }


  /**
   * Model AddPurchaseStock
   */

  export type AggregateAddPurchaseStock = {
    _count: AddPurchaseStockCountAggregateOutputType | null
    _avg: AddPurchaseStockAvgAggregateOutputType | null
    _sum: AddPurchaseStockSumAggregateOutputType | null
    _min: AddPurchaseStockMinAggregateOutputType | null
    _max: AddPurchaseStockMaxAggregateOutputType | null
  }

  export type AddPurchaseStockAvgAggregateOutputType = {
    id: number | null
    goldWeight: number | null
    goldTouch: number | null
    goldPurity: number | null
    goldRate: number | null
    goldtotalValue: number | null
    silverWeight: number | null
    silverTouch: number | null
    silverPurity: number | null
    silverRate: number | null
    silvertotalValue: number | null
  }

  export type AddPurchaseStockSumAggregateOutputType = {
    id: number | null
    goldWeight: number | null
    goldTouch: number | null
    goldPurity: number | null
    goldRate: number | null
    goldtotalValue: number | null
    silverWeight: number | null
    silverTouch: number | null
    silverPurity: number | null
    silverRate: number | null
    silvertotalValue: number | null
  }

  export type AddPurchaseStockMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    item: $Enums.ITEMTYPE | null
    goldWeight: number | null
    goldTouch: number | null
    goldPurity: number | null
    goldRate: number | null
    goldtotalValue: number | null
    silverWeight: number | null
    silverTouch: number | null
    silverPurity: number | null
    silverRate: number | null
    silvertotalValue: number | null
  }

  export type AddPurchaseStockMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
    item: $Enums.ITEMTYPE | null
    goldWeight: number | null
    goldTouch: number | null
    goldPurity: number | null
    goldRate: number | null
    goldtotalValue: number | null
    silverWeight: number | null
    silverTouch: number | null
    silverPurity: number | null
    silverRate: number | null
    silvertotalValue: number | null
  }

  export type AddPurchaseStockCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    item: number
    goldWeight: number
    goldTouch: number
    goldPurity: number
    goldRate: number
    goldtotalValue: number
    silverWeight: number
    silverTouch: number
    silverPurity: number
    silverRate: number
    silvertotalValue: number
    _all: number
  }


  export type AddPurchaseStockAvgAggregateInputType = {
    id?: true
    goldWeight?: true
    goldTouch?: true
    goldPurity?: true
    goldRate?: true
    goldtotalValue?: true
    silverWeight?: true
    silverTouch?: true
    silverPurity?: true
    silverRate?: true
    silvertotalValue?: true
  }

  export type AddPurchaseStockSumAggregateInputType = {
    id?: true
    goldWeight?: true
    goldTouch?: true
    goldPurity?: true
    goldRate?: true
    goldtotalValue?: true
    silverWeight?: true
    silverTouch?: true
    silverPurity?: true
    silverRate?: true
    silvertotalValue?: true
  }

  export type AddPurchaseStockMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    item?: true
    goldWeight?: true
    goldTouch?: true
    goldPurity?: true
    goldRate?: true
    goldtotalValue?: true
    silverWeight?: true
    silverTouch?: true
    silverPurity?: true
    silverRate?: true
    silvertotalValue?: true
  }

  export type AddPurchaseStockMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    item?: true
    goldWeight?: true
    goldTouch?: true
    goldPurity?: true
    goldRate?: true
    goldtotalValue?: true
    silverWeight?: true
    silverTouch?: true
    silverPurity?: true
    silverRate?: true
    silvertotalValue?: true
  }

  export type AddPurchaseStockCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    item?: true
    goldWeight?: true
    goldTouch?: true
    goldPurity?: true
    goldRate?: true
    goldtotalValue?: true
    silverWeight?: true
    silverTouch?: true
    silverPurity?: true
    silverRate?: true
    silvertotalValue?: true
    _all?: true
  }

  export type AddPurchaseStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddPurchaseStock to aggregate.
     */
    where?: AddPurchaseStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddPurchaseStocks to fetch.
     */
    orderBy?: AddPurchaseStockOrderByWithRelationInput | AddPurchaseStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddPurchaseStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddPurchaseStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddPurchaseStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddPurchaseStocks
    **/
    _count?: true | AddPurchaseStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddPurchaseStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddPurchaseStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddPurchaseStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddPurchaseStockMaxAggregateInputType
  }

  export type GetAddPurchaseStockAggregateType<T extends AddPurchaseStockAggregateArgs> = {
        [P in keyof T & keyof AggregateAddPurchaseStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddPurchaseStock[P]>
      : GetScalarType<T[P], AggregateAddPurchaseStock[P]>
  }




  export type AddPurchaseStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddPurchaseStockWhereInput
    orderBy?: AddPurchaseStockOrderByWithAggregationInput | AddPurchaseStockOrderByWithAggregationInput[]
    by: AddPurchaseStockScalarFieldEnum[] | AddPurchaseStockScalarFieldEnum
    having?: AddPurchaseStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddPurchaseStockCountAggregateInputType | true
    _avg?: AddPurchaseStockAvgAggregateInputType
    _sum?: AddPurchaseStockSumAggregateInputType
    _min?: AddPurchaseStockMinAggregateInputType
    _max?: AddPurchaseStockMaxAggregateInputType
  }

  export type AddPurchaseStockGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    item: $Enums.ITEMTYPE
    goldWeight: number | null
    goldTouch: number | null
    goldPurity: number | null
    goldRate: number | null
    goldtotalValue: number | null
    silverWeight: number | null
    silverTouch: number | null
    silverPurity: number | null
    silverRate: number | null
    silvertotalValue: number | null
    _count: AddPurchaseStockCountAggregateOutputType | null
    _avg: AddPurchaseStockAvgAggregateOutputType | null
    _sum: AddPurchaseStockSumAggregateOutputType | null
    _min: AddPurchaseStockMinAggregateOutputType | null
    _max: AddPurchaseStockMaxAggregateOutputType | null
  }

  type GetAddPurchaseStockGroupByPayload<T extends AddPurchaseStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddPurchaseStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddPurchaseStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddPurchaseStockGroupByOutputType[P]>
            : GetScalarType<T[P], AddPurchaseStockGroupByOutputType[P]>
        }
      >
    >


  export type AddPurchaseStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    item?: boolean
    goldWeight?: boolean
    goldTouch?: boolean
    goldPurity?: boolean
    goldRate?: boolean
    goldtotalValue?: boolean
    silverWeight?: boolean
    silverTouch?: boolean
    silverPurity?: boolean
    silverRate?: boolean
    silvertotalValue?: boolean
  }, ExtArgs["result"]["addPurchaseStock"]>



  export type AddPurchaseStockSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    item?: boolean
    goldWeight?: boolean
    goldTouch?: boolean
    goldPurity?: boolean
    goldRate?: boolean
    goldtotalValue?: boolean
    silverWeight?: boolean
    silverTouch?: boolean
    silverPurity?: boolean
    silverRate?: boolean
    silvertotalValue?: boolean
  }

  export type AddPurchaseStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "item" | "goldWeight" | "goldTouch" | "goldPurity" | "goldRate" | "goldtotalValue" | "silverWeight" | "silverTouch" | "silverPurity" | "silverRate" | "silvertotalValue", ExtArgs["result"]["addPurchaseStock"]>

  export type $AddPurchaseStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddPurchaseStock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
      item: $Enums.ITEMTYPE
      goldWeight: number | null
      goldTouch: number | null
      goldPurity: number | null
      goldRate: number | null
      goldtotalValue: number | null
      silverWeight: number | null
      silverTouch: number | null
      silverPurity: number | null
      silverRate: number | null
      silvertotalValue: number | null
    }, ExtArgs["result"]["addPurchaseStock"]>
    composites: {}
  }

  type AddPurchaseStockGetPayload<S extends boolean | null | undefined | AddPurchaseStockDefaultArgs> = $Result.GetResult<Prisma.$AddPurchaseStockPayload, S>

  type AddPurchaseStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddPurchaseStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddPurchaseStockCountAggregateInputType | true
    }

  export interface AddPurchaseStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddPurchaseStock'], meta: { name: 'AddPurchaseStock' } }
    /**
     * Find zero or one AddPurchaseStock that matches the filter.
     * @param {AddPurchaseStockFindUniqueArgs} args - Arguments to find a AddPurchaseStock
     * @example
     * // Get one AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddPurchaseStockFindUniqueArgs>(args: SelectSubset<T, AddPurchaseStockFindUniqueArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddPurchaseStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddPurchaseStockFindUniqueOrThrowArgs} args - Arguments to find a AddPurchaseStock
     * @example
     * // Get one AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddPurchaseStockFindUniqueOrThrowArgs>(args: SelectSubset<T, AddPurchaseStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddPurchaseStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockFindFirstArgs} args - Arguments to find a AddPurchaseStock
     * @example
     * // Get one AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddPurchaseStockFindFirstArgs>(args?: SelectSubset<T, AddPurchaseStockFindFirstArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddPurchaseStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockFindFirstOrThrowArgs} args - Arguments to find a AddPurchaseStock
     * @example
     * // Get one AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddPurchaseStockFindFirstOrThrowArgs>(args?: SelectSubset<T, AddPurchaseStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddPurchaseStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddPurchaseStocks
     * const addPurchaseStocks = await prisma.addPurchaseStock.findMany()
     * 
     * // Get first 10 AddPurchaseStocks
     * const addPurchaseStocks = await prisma.addPurchaseStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addPurchaseStockWithIdOnly = await prisma.addPurchaseStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddPurchaseStockFindManyArgs>(args?: SelectSubset<T, AddPurchaseStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddPurchaseStock.
     * @param {AddPurchaseStockCreateArgs} args - Arguments to create a AddPurchaseStock.
     * @example
     * // Create one AddPurchaseStock
     * const AddPurchaseStock = await prisma.addPurchaseStock.create({
     *   data: {
     *     // ... data to create a AddPurchaseStock
     *   }
     * })
     * 
     */
    create<T extends AddPurchaseStockCreateArgs>(args: SelectSubset<T, AddPurchaseStockCreateArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddPurchaseStocks.
     * @param {AddPurchaseStockCreateManyArgs} args - Arguments to create many AddPurchaseStocks.
     * @example
     * // Create many AddPurchaseStocks
     * const addPurchaseStock = await prisma.addPurchaseStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddPurchaseStockCreateManyArgs>(args?: SelectSubset<T, AddPurchaseStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddPurchaseStock.
     * @param {AddPurchaseStockDeleteArgs} args - Arguments to delete one AddPurchaseStock.
     * @example
     * // Delete one AddPurchaseStock
     * const AddPurchaseStock = await prisma.addPurchaseStock.delete({
     *   where: {
     *     // ... filter to delete one AddPurchaseStock
     *   }
     * })
     * 
     */
    delete<T extends AddPurchaseStockDeleteArgs>(args: SelectSubset<T, AddPurchaseStockDeleteArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddPurchaseStock.
     * @param {AddPurchaseStockUpdateArgs} args - Arguments to update one AddPurchaseStock.
     * @example
     * // Update one AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddPurchaseStockUpdateArgs>(args: SelectSubset<T, AddPurchaseStockUpdateArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddPurchaseStocks.
     * @param {AddPurchaseStockDeleteManyArgs} args - Arguments to filter AddPurchaseStocks to delete.
     * @example
     * // Delete a few AddPurchaseStocks
     * const { count } = await prisma.addPurchaseStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddPurchaseStockDeleteManyArgs>(args?: SelectSubset<T, AddPurchaseStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddPurchaseStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddPurchaseStocks
     * const addPurchaseStock = await prisma.addPurchaseStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddPurchaseStockUpdateManyArgs>(args: SelectSubset<T, AddPurchaseStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddPurchaseStock.
     * @param {AddPurchaseStockUpsertArgs} args - Arguments to update or create a AddPurchaseStock.
     * @example
     * // Update or create a AddPurchaseStock
     * const addPurchaseStock = await prisma.addPurchaseStock.upsert({
     *   create: {
     *     // ... data to create a AddPurchaseStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddPurchaseStock we want to update
     *   }
     * })
     */
    upsert<T extends AddPurchaseStockUpsertArgs>(args: SelectSubset<T, AddPurchaseStockUpsertArgs<ExtArgs>>): Prisma__AddPurchaseStockClient<$Result.GetResult<Prisma.$AddPurchaseStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddPurchaseStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockCountArgs} args - Arguments to filter AddPurchaseStocks to count.
     * @example
     * // Count the number of AddPurchaseStocks
     * const count = await prisma.addPurchaseStock.count({
     *   where: {
     *     // ... the filter for the AddPurchaseStocks we want to count
     *   }
     * })
    **/
    count<T extends AddPurchaseStockCountArgs>(
      args?: Subset<T, AddPurchaseStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddPurchaseStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddPurchaseStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddPurchaseStockAggregateArgs>(args: Subset<T, AddPurchaseStockAggregateArgs>): Prisma.PrismaPromise<GetAddPurchaseStockAggregateType<T>>

    /**
     * Group by AddPurchaseStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddPurchaseStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddPurchaseStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddPurchaseStockGroupByArgs['orderBy'] }
        : { orderBy?: AddPurchaseStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddPurchaseStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddPurchaseStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddPurchaseStock model
   */
  readonly fields: AddPurchaseStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddPurchaseStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddPurchaseStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddPurchaseStock model
   */
  interface AddPurchaseStockFieldRefs {
    readonly id: FieldRef<"AddPurchaseStock", 'Int'>
    readonly createdAt: FieldRef<"AddPurchaseStock", 'DateTime'>
    readonly name: FieldRef<"AddPurchaseStock", 'String'>
    readonly item: FieldRef<"AddPurchaseStock", 'ITEMTYPE'>
    readonly goldWeight: FieldRef<"AddPurchaseStock", 'Int'>
    readonly goldTouch: FieldRef<"AddPurchaseStock", 'Float'>
    readonly goldPurity: FieldRef<"AddPurchaseStock", 'Float'>
    readonly goldRate: FieldRef<"AddPurchaseStock", 'Float'>
    readonly goldtotalValue: FieldRef<"AddPurchaseStock", 'Float'>
    readonly silverWeight: FieldRef<"AddPurchaseStock", 'Int'>
    readonly silverTouch: FieldRef<"AddPurchaseStock", 'Float'>
    readonly silverPurity: FieldRef<"AddPurchaseStock", 'Float'>
    readonly silverRate: FieldRef<"AddPurchaseStock", 'Float'>
    readonly silvertotalValue: FieldRef<"AddPurchaseStock", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AddPurchaseStock findUnique
   */
  export type AddPurchaseStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter, which AddPurchaseStock to fetch.
     */
    where: AddPurchaseStockWhereUniqueInput
  }

  /**
   * AddPurchaseStock findUniqueOrThrow
   */
  export type AddPurchaseStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter, which AddPurchaseStock to fetch.
     */
    where: AddPurchaseStockWhereUniqueInput
  }

  /**
   * AddPurchaseStock findFirst
   */
  export type AddPurchaseStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter, which AddPurchaseStock to fetch.
     */
    where?: AddPurchaseStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddPurchaseStocks to fetch.
     */
    orderBy?: AddPurchaseStockOrderByWithRelationInput | AddPurchaseStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddPurchaseStocks.
     */
    cursor?: AddPurchaseStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddPurchaseStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddPurchaseStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddPurchaseStocks.
     */
    distinct?: AddPurchaseStockScalarFieldEnum | AddPurchaseStockScalarFieldEnum[]
  }

  /**
   * AddPurchaseStock findFirstOrThrow
   */
  export type AddPurchaseStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter, which AddPurchaseStock to fetch.
     */
    where?: AddPurchaseStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddPurchaseStocks to fetch.
     */
    orderBy?: AddPurchaseStockOrderByWithRelationInput | AddPurchaseStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddPurchaseStocks.
     */
    cursor?: AddPurchaseStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddPurchaseStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddPurchaseStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddPurchaseStocks.
     */
    distinct?: AddPurchaseStockScalarFieldEnum | AddPurchaseStockScalarFieldEnum[]
  }

  /**
   * AddPurchaseStock findMany
   */
  export type AddPurchaseStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter, which AddPurchaseStocks to fetch.
     */
    where?: AddPurchaseStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddPurchaseStocks to fetch.
     */
    orderBy?: AddPurchaseStockOrderByWithRelationInput | AddPurchaseStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddPurchaseStocks.
     */
    cursor?: AddPurchaseStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddPurchaseStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddPurchaseStocks.
     */
    skip?: number
    distinct?: AddPurchaseStockScalarFieldEnum | AddPurchaseStockScalarFieldEnum[]
  }

  /**
   * AddPurchaseStock create
   */
  export type AddPurchaseStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * The data needed to create a AddPurchaseStock.
     */
    data: XOR<AddPurchaseStockCreateInput, AddPurchaseStockUncheckedCreateInput>
  }

  /**
   * AddPurchaseStock createMany
   */
  export type AddPurchaseStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddPurchaseStocks.
     */
    data: AddPurchaseStockCreateManyInput | AddPurchaseStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddPurchaseStock update
   */
  export type AddPurchaseStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * The data needed to update a AddPurchaseStock.
     */
    data: XOR<AddPurchaseStockUpdateInput, AddPurchaseStockUncheckedUpdateInput>
    /**
     * Choose, which AddPurchaseStock to update.
     */
    where: AddPurchaseStockWhereUniqueInput
  }

  /**
   * AddPurchaseStock updateMany
   */
  export type AddPurchaseStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddPurchaseStocks.
     */
    data: XOR<AddPurchaseStockUpdateManyMutationInput, AddPurchaseStockUncheckedUpdateManyInput>
    /**
     * Filter which AddPurchaseStocks to update
     */
    where?: AddPurchaseStockWhereInput
    /**
     * Limit how many AddPurchaseStocks to update.
     */
    limit?: number
  }

  /**
   * AddPurchaseStock upsert
   */
  export type AddPurchaseStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * The filter to search for the AddPurchaseStock to update in case it exists.
     */
    where: AddPurchaseStockWhereUniqueInput
    /**
     * In case the AddPurchaseStock found by the `where` argument doesn't exist, create a new AddPurchaseStock with this data.
     */
    create: XOR<AddPurchaseStockCreateInput, AddPurchaseStockUncheckedCreateInput>
    /**
     * In case the AddPurchaseStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddPurchaseStockUpdateInput, AddPurchaseStockUncheckedUpdateInput>
  }

  /**
   * AddPurchaseStock delete
   */
  export type AddPurchaseStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
    /**
     * Filter which AddPurchaseStock to delete.
     */
    where: AddPurchaseStockWhereUniqueInput
  }

  /**
   * AddPurchaseStock deleteMany
   */
  export type AddPurchaseStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddPurchaseStocks to delete
     */
    where?: AddPurchaseStockWhereInput
    /**
     * Limit how many AddPurchaseStocks to delete.
     */
    limit?: number
  }

  /**
   * AddPurchaseStock without action
   */
  export type AddPurchaseStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddPurchaseStock
     */
    select?: AddPurchaseStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddPurchaseStock
     */
    omit?: AddPurchaseStockOmit<ExtArgs> | null
  }


  /**
   * Model CustomerTransaction
   */

  export type AggregateCustomerTransaction = {
    _count: CustomerTransactionCountAggregateOutputType | null
    _avg: CustomerTransactionAvgAggregateOutputType | null
    _sum: CustomerTransactionSumAggregateOutputType | null
    _min: CustomerTransactionMinAggregateOutputType | null
    _max: CustomerTransactionMaxAggregateOutputType | null
  }

  export type CustomerTransactionAvgAggregateOutputType = {
    id: number | null
    value: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    customerId: number | null
  }

  export type CustomerTransactionSumAggregateOutputType = {
    id: number | null
    value: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    customerId: number | null
  }

  export type CustomerTransactionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    value: number | null
    type: string | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    customerId: number | null
  }

  export type CustomerTransactionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    value: number | null
    type: string | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    customerId: number | null
  }

  export type CustomerTransactionCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    value: number
    type: number
    touch: number
    purity: number
    goldRate: number
    customerId: number
    _all: number
  }


  export type CustomerTransactionAvgAggregateInputType = {
    id?: true
    value?: true
    touch?: true
    purity?: true
    goldRate?: true
    customerId?: true
  }

  export type CustomerTransactionSumAggregateInputType = {
    id?: true
    value?: true
    touch?: true
    purity?: true
    goldRate?: true
    customerId?: true
  }

  export type CustomerTransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    value?: true
    type?: true
    touch?: true
    purity?: true
    goldRate?: true
    customerId?: true
  }

  export type CustomerTransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    value?: true
    type?: true
    touch?: true
    purity?: true
    goldRate?: true
    customerId?: true
  }

  export type CustomerTransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    value?: true
    type?: true
    touch?: true
    purity?: true
    goldRate?: true
    customerId?: true
    _all?: true
  }

  export type CustomerTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTransaction to aggregate.
     */
    where?: CustomerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionOrderByWithRelationInput | CustomerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerTransactions
    **/
    _count?: true | CustomerTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerTransactionMaxAggregateInputType
  }

  export type GetCustomerTransactionAggregateType<T extends CustomerTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerTransaction[P]>
      : GetScalarType<T[P], AggregateCustomerTransaction[P]>
  }




  export type CustomerTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTransactionWhereInput
    orderBy?: CustomerTransactionOrderByWithAggregationInput | CustomerTransactionOrderByWithAggregationInput[]
    by: CustomerTransactionScalarFieldEnum[] | CustomerTransactionScalarFieldEnum
    having?: CustomerTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerTransactionCountAggregateInputType | true
    _avg?: CustomerTransactionAvgAggregateInputType
    _sum?: CustomerTransactionSumAggregateInputType
    _min?: CustomerTransactionMinAggregateInputType
    _max?: CustomerTransactionMaxAggregateInputType
  }

  export type CustomerTransactionGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    value: number
    type: string
    touch: number | null
    purity: number | null
    goldRate: number | null
    customerId: number
    _count: CustomerTransactionCountAggregateOutputType | null
    _avg: CustomerTransactionAvgAggregateOutputType | null
    _sum: CustomerTransactionSumAggregateOutputType | null
    _min: CustomerTransactionMinAggregateOutputType | null
    _max: CustomerTransactionMaxAggregateOutputType | null
  }

  type GetCustomerTransactionGroupByPayload<T extends CustomerTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    value?: boolean
    type?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    customerId?: boolean
    customer?: boolean | AddCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerTransaction"]>



  export type CustomerTransactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    value?: boolean
    type?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    customerId?: boolean
  }

  export type CustomerTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "date" | "value" | "type" | "touch" | "purity" | "goldRate" | "customerId", ExtArgs["result"]["customerTransaction"]>
  export type CustomerTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AddCustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerTransaction"
    objects: {
      customer: Prisma.$AddCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      date: Date
      value: number
      type: string
      touch: number | null
      purity: number | null
      goldRate: number | null
      customerId: number
    }, ExtArgs["result"]["customerTransaction"]>
    composites: {}
  }

  type CustomerTransactionGetPayload<S extends boolean | null | undefined | CustomerTransactionDefaultArgs> = $Result.GetResult<Prisma.$CustomerTransactionPayload, S>

  type CustomerTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerTransactionCountAggregateInputType | true
    }

  export interface CustomerTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerTransaction'], meta: { name: 'CustomerTransaction' } }
    /**
     * Find zero or one CustomerTransaction that matches the filter.
     * @param {CustomerTransactionFindUniqueArgs} args - Arguments to find a CustomerTransaction
     * @example
     * // Get one CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerTransactionFindUniqueArgs>(args: SelectSubset<T, CustomerTransactionFindUniqueArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerTransactionFindUniqueOrThrowArgs} args - Arguments to find a CustomerTransaction
     * @example
     * // Get one CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionFindFirstArgs} args - Arguments to find a CustomerTransaction
     * @example
     * // Get one CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerTransactionFindFirstArgs>(args?: SelectSubset<T, CustomerTransactionFindFirstArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionFindFirstOrThrowArgs} args - Arguments to find a CustomerTransaction
     * @example
     * // Get one CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerTransactions
     * const customerTransactions = await prisma.customerTransaction.findMany()
     * 
     * // Get first 10 CustomerTransactions
     * const customerTransactions = await prisma.customerTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerTransactionWithIdOnly = await prisma.customerTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerTransactionFindManyArgs>(args?: SelectSubset<T, CustomerTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerTransaction.
     * @param {CustomerTransactionCreateArgs} args - Arguments to create a CustomerTransaction.
     * @example
     * // Create one CustomerTransaction
     * const CustomerTransaction = await prisma.customerTransaction.create({
     *   data: {
     *     // ... data to create a CustomerTransaction
     *   }
     * })
     * 
     */
    create<T extends CustomerTransactionCreateArgs>(args: SelectSubset<T, CustomerTransactionCreateArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerTransactions.
     * @param {CustomerTransactionCreateManyArgs} args - Arguments to create many CustomerTransactions.
     * @example
     * // Create many CustomerTransactions
     * const customerTransaction = await prisma.customerTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerTransactionCreateManyArgs>(args?: SelectSubset<T, CustomerTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerTransaction.
     * @param {CustomerTransactionDeleteArgs} args - Arguments to delete one CustomerTransaction.
     * @example
     * // Delete one CustomerTransaction
     * const CustomerTransaction = await prisma.customerTransaction.delete({
     *   where: {
     *     // ... filter to delete one CustomerTransaction
     *   }
     * })
     * 
     */
    delete<T extends CustomerTransactionDeleteArgs>(args: SelectSubset<T, CustomerTransactionDeleteArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerTransaction.
     * @param {CustomerTransactionUpdateArgs} args - Arguments to update one CustomerTransaction.
     * @example
     * // Update one CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerTransactionUpdateArgs>(args: SelectSubset<T, CustomerTransactionUpdateArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerTransactions.
     * @param {CustomerTransactionDeleteManyArgs} args - Arguments to filter CustomerTransactions to delete.
     * @example
     * // Delete a few CustomerTransactions
     * const { count } = await prisma.customerTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerTransactionDeleteManyArgs>(args?: SelectSubset<T, CustomerTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerTransactions
     * const customerTransaction = await prisma.customerTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerTransactionUpdateManyArgs>(args: SelectSubset<T, CustomerTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerTransaction.
     * @param {CustomerTransactionUpsertArgs} args - Arguments to update or create a CustomerTransaction.
     * @example
     * // Update or create a CustomerTransaction
     * const customerTransaction = await prisma.customerTransaction.upsert({
     *   create: {
     *     // ... data to create a CustomerTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CustomerTransactionUpsertArgs>(args: SelectSubset<T, CustomerTransactionUpsertArgs<ExtArgs>>): Prisma__CustomerTransactionClient<$Result.GetResult<Prisma.$CustomerTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionCountArgs} args - Arguments to filter CustomerTransactions to count.
     * @example
     * // Count the number of CustomerTransactions
     * const count = await prisma.customerTransaction.count({
     *   where: {
     *     // ... the filter for the CustomerTransactions we want to count
     *   }
     * })
    **/
    count<T extends CustomerTransactionCountArgs>(
      args?: Subset<T, CustomerTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerTransactionAggregateArgs>(args: Subset<T, CustomerTransactionAggregateArgs>): Prisma.PrismaPromise<GetCustomerTransactionAggregateType<T>>

    /**
     * Group by CustomerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerTransaction model
   */
  readonly fields: CustomerTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends AddCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddCustomerDefaultArgs<ExtArgs>>): Prisma__AddCustomerClient<$Result.GetResult<Prisma.$AddCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerTransaction model
   */
  interface CustomerTransactionFieldRefs {
    readonly id: FieldRef<"CustomerTransaction", 'Int'>
    readonly createdAt: FieldRef<"CustomerTransaction", 'DateTime'>
    readonly date: FieldRef<"CustomerTransaction", 'DateTime'>
    readonly value: FieldRef<"CustomerTransaction", 'Float'>
    readonly type: FieldRef<"CustomerTransaction", 'String'>
    readonly touch: FieldRef<"CustomerTransaction", 'Float'>
    readonly purity: FieldRef<"CustomerTransaction", 'Float'>
    readonly goldRate: FieldRef<"CustomerTransaction", 'Float'>
    readonly customerId: FieldRef<"CustomerTransaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CustomerTransaction findUnique
   */
  export type CustomerTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransaction to fetch.
     */
    where: CustomerTransactionWhereUniqueInput
  }

  /**
   * CustomerTransaction findUniqueOrThrow
   */
  export type CustomerTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransaction to fetch.
     */
    where: CustomerTransactionWhereUniqueInput
  }

  /**
   * CustomerTransaction findFirst
   */
  export type CustomerTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransaction to fetch.
     */
    where?: CustomerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionOrderByWithRelationInput | CustomerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTransactions.
     */
    cursor?: CustomerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTransactions.
     */
    distinct?: CustomerTransactionScalarFieldEnum | CustomerTransactionScalarFieldEnum[]
  }

  /**
   * CustomerTransaction findFirstOrThrow
   */
  export type CustomerTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransaction to fetch.
     */
    where?: CustomerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionOrderByWithRelationInput | CustomerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTransactions.
     */
    cursor?: CustomerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTransactions.
     */
    distinct?: CustomerTransactionScalarFieldEnum | CustomerTransactionScalarFieldEnum[]
  }

  /**
   * CustomerTransaction findMany
   */
  export type CustomerTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where?: CustomerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionOrderByWithRelationInput | CustomerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerTransactions.
     */
    cursor?: CustomerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    distinct?: CustomerTransactionScalarFieldEnum | CustomerTransactionScalarFieldEnum[]
  }

  /**
   * CustomerTransaction create
   */
  export type CustomerTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerTransaction.
     */
    data: XOR<CustomerTransactionCreateInput, CustomerTransactionUncheckedCreateInput>
  }

  /**
   * CustomerTransaction createMany
   */
  export type CustomerTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerTransactions.
     */
    data: CustomerTransactionCreateManyInput | CustomerTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerTransaction update
   */
  export type CustomerTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerTransaction.
     */
    data: XOR<CustomerTransactionUpdateInput, CustomerTransactionUncheckedUpdateInput>
    /**
     * Choose, which CustomerTransaction to update.
     */
    where: CustomerTransactionWhereUniqueInput
  }

  /**
   * CustomerTransaction updateMany
   */
  export type CustomerTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerTransactions.
     */
    data: XOR<CustomerTransactionUpdateManyMutationInput, CustomerTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTransactions to update
     */
    where?: CustomerTransactionWhereInput
    /**
     * Limit how many CustomerTransactions to update.
     */
    limit?: number
  }

  /**
   * CustomerTransaction upsert
   */
  export type CustomerTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerTransaction to update in case it exists.
     */
    where: CustomerTransactionWhereUniqueInput
    /**
     * In case the CustomerTransaction found by the `where` argument doesn't exist, create a new CustomerTransaction with this data.
     */
    create: XOR<CustomerTransactionCreateInput, CustomerTransactionUncheckedCreateInput>
    /**
     * In case the CustomerTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerTransactionUpdateInput, CustomerTransactionUncheckedUpdateInput>
  }

  /**
   * CustomerTransaction delete
   */
  export type CustomerTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
    /**
     * Filter which CustomerTransaction to delete.
     */
    where: CustomerTransactionWhereUniqueInput
  }

  /**
   * CustomerTransaction deleteMany
   */
  export type CustomerTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTransactions to delete
     */
    where?: CustomerTransactionWhereInput
    /**
     * Limit how many CustomerTransactions to delete.
     */
    limit?: number
  }

  /**
   * CustomerTransaction without action
   */
  export type CustomerTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransaction
     */
    select?: CustomerTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerTransaction
     */
    omit?: CustomerTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTransactionInclude<ExtArgs> | null
  }


  /**
   * Model AddItem
   */

  export type AggregateAddItem = {
    _count: AddItemCountAggregateOutputType | null
    _avg: AddItemAvgAggregateOutputType | null
    _sum: AddItemSumAggregateOutputType | null
    _min: AddItemMinAggregateOutputType | null
    _max: AddItemMaxAggregateOutputType | null
  }

  export type AddItemAvgAggregateOutputType = {
    id: number | null
  }

  export type AddItemSumAggregateOutputType = {
    id: number | null
  }

  export type AddItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
  }

  export type AddItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    name: string | null
  }

  export type AddItemCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    _all: number
  }


  export type AddItemAvgAggregateInputType = {
    id?: true
  }

  export type AddItemSumAggregateInputType = {
    id?: true
  }

  export type AddItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
  }

  export type AddItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
  }

  export type AddItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    _all?: true
  }

  export type AddItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddItem to aggregate.
     */
    where?: AddItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddItems to fetch.
     */
    orderBy?: AddItemOrderByWithRelationInput | AddItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddItems
    **/
    _count?: true | AddItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddItemMaxAggregateInputType
  }

  export type GetAddItemAggregateType<T extends AddItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAddItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddItem[P]>
      : GetScalarType<T[P], AggregateAddItem[P]>
  }




  export type AddItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddItemWhereInput
    orderBy?: AddItemOrderByWithAggregationInput | AddItemOrderByWithAggregationInput[]
    by: AddItemScalarFieldEnum[] | AddItemScalarFieldEnum
    having?: AddItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddItemCountAggregateInputType | true
    _avg?: AddItemAvgAggregateInputType
    _sum?: AddItemSumAggregateInputType
    _min?: AddItemMinAggregateInputType
    _max?: AddItemMaxAggregateInputType
  }

  export type AddItemGroupByOutputType = {
    id: number
    createdAt: Date
    name: string
    _count: AddItemCountAggregateOutputType | null
    _avg: AddItemAvgAggregateOutputType | null
    _sum: AddItemSumAggregateOutputType | null
    _min: AddItemMinAggregateOutputType | null
    _max: AddItemMaxAggregateOutputType | null
  }

  type GetAddItemGroupByPayload<T extends AddItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddItemGroupByOutputType[P]>
            : GetScalarType<T[P], AddItemGroupByOutputType[P]>
        }
      >
    >


  export type AddItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    casting_items?: boolean | AddItem$casting_itemsArgs<ExtArgs>
    stock?: boolean | AddItem$stockArgs<ExtArgs>
    filing_items?: boolean | AddItem$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | AddItem$setting_itemsArgs<ExtArgs>
    buffing_items?: boolean | AddItem$buffing_itemsArgs<ExtArgs>
    _count?: boolean | AddItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addItem"]>



  export type AddItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
  }

  export type AddItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name", ExtArgs["result"]["addItem"]>
  export type AddItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    casting_items?: boolean | AddItem$casting_itemsArgs<ExtArgs>
    stock?: boolean | AddItem$stockArgs<ExtArgs>
    filing_items?: boolean | AddItem$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | AddItem$setting_itemsArgs<ExtArgs>
    buffing_items?: boolean | AddItem$buffing_itemsArgs<ExtArgs>
    _count?: boolean | AddItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddItem"
    objects: {
      casting_items: Prisma.$CastingItemsPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs>[]
      filing_items: Prisma.$FilingItemsPayload<ExtArgs>[]
      setting_items: Prisma.$SettingItemsPayload<ExtArgs>[]
      buffing_items: Prisma.$BuffingItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      name: string
    }, ExtArgs["result"]["addItem"]>
    composites: {}
  }

  type AddItemGetPayload<S extends boolean | null | undefined | AddItemDefaultArgs> = $Result.GetResult<Prisma.$AddItemPayload, S>

  type AddItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddItemCountAggregateInputType | true
    }

  export interface AddItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddItem'], meta: { name: 'AddItem' } }
    /**
     * Find zero or one AddItem that matches the filter.
     * @param {AddItemFindUniqueArgs} args - Arguments to find a AddItem
     * @example
     * // Get one AddItem
     * const addItem = await prisma.addItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddItemFindUniqueArgs>(args: SelectSubset<T, AddItemFindUniqueArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddItemFindUniqueOrThrowArgs} args - Arguments to find a AddItem
     * @example
     * // Get one AddItem
     * const addItem = await prisma.addItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AddItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemFindFirstArgs} args - Arguments to find a AddItem
     * @example
     * // Get one AddItem
     * const addItem = await prisma.addItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddItemFindFirstArgs>(args?: SelectSubset<T, AddItemFindFirstArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemFindFirstOrThrowArgs} args - Arguments to find a AddItem
     * @example
     * // Get one AddItem
     * const addItem = await prisma.addItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AddItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddItems
     * const addItems = await prisma.addItem.findMany()
     * 
     * // Get first 10 AddItems
     * const addItems = await prisma.addItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addItemWithIdOnly = await prisma.addItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddItemFindManyArgs>(args?: SelectSubset<T, AddItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddItem.
     * @param {AddItemCreateArgs} args - Arguments to create a AddItem.
     * @example
     * // Create one AddItem
     * const AddItem = await prisma.addItem.create({
     *   data: {
     *     // ... data to create a AddItem
     *   }
     * })
     * 
     */
    create<T extends AddItemCreateArgs>(args: SelectSubset<T, AddItemCreateArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddItems.
     * @param {AddItemCreateManyArgs} args - Arguments to create many AddItems.
     * @example
     * // Create many AddItems
     * const addItem = await prisma.addItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddItemCreateManyArgs>(args?: SelectSubset<T, AddItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddItem.
     * @param {AddItemDeleteArgs} args - Arguments to delete one AddItem.
     * @example
     * // Delete one AddItem
     * const AddItem = await prisma.addItem.delete({
     *   where: {
     *     // ... filter to delete one AddItem
     *   }
     * })
     * 
     */
    delete<T extends AddItemDeleteArgs>(args: SelectSubset<T, AddItemDeleteArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddItem.
     * @param {AddItemUpdateArgs} args - Arguments to update one AddItem.
     * @example
     * // Update one AddItem
     * const addItem = await prisma.addItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddItemUpdateArgs>(args: SelectSubset<T, AddItemUpdateArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddItems.
     * @param {AddItemDeleteManyArgs} args - Arguments to filter AddItems to delete.
     * @example
     * // Delete a few AddItems
     * const { count } = await prisma.addItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddItemDeleteManyArgs>(args?: SelectSubset<T, AddItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddItems
     * const addItem = await prisma.addItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddItemUpdateManyArgs>(args: SelectSubset<T, AddItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddItem.
     * @param {AddItemUpsertArgs} args - Arguments to update or create a AddItem.
     * @example
     * // Update or create a AddItem
     * const addItem = await prisma.addItem.upsert({
     *   create: {
     *     // ... data to create a AddItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddItem we want to update
     *   }
     * })
     */
    upsert<T extends AddItemUpsertArgs>(args: SelectSubset<T, AddItemUpsertArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemCountArgs} args - Arguments to filter AddItems to count.
     * @example
     * // Count the number of AddItems
     * const count = await prisma.addItem.count({
     *   where: {
     *     // ... the filter for the AddItems we want to count
     *   }
     * })
    **/
    count<T extends AddItemCountArgs>(
      args?: Subset<T, AddItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddItemAggregateArgs>(args: Subset<T, AddItemAggregateArgs>): Prisma.PrismaPromise<GetAddItemAggregateType<T>>

    /**
     * Group by AddItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddItemGroupByArgs['orderBy'] }
        : { orderBy?: AddItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddItem model
   */
  readonly fields: AddItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    casting_items<T extends AddItem$casting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddItem$casting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends AddItem$stockArgs<ExtArgs> = {}>(args?: Subset<T, AddItem$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filing_items<T extends AddItem$filing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddItem$filing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    setting_items<T extends AddItem$setting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddItem$setting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffing_items<T extends AddItem$buffing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddItem$buffing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddItem model
   */
  interface AddItemFieldRefs {
    readonly id: FieldRef<"AddItem", 'Int'>
    readonly createdAt: FieldRef<"AddItem", 'DateTime'>
    readonly name: FieldRef<"AddItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddItem findUnique
   */
  export type AddItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter, which AddItem to fetch.
     */
    where: AddItemWhereUniqueInput
  }

  /**
   * AddItem findUniqueOrThrow
   */
  export type AddItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter, which AddItem to fetch.
     */
    where: AddItemWhereUniqueInput
  }

  /**
   * AddItem findFirst
   */
  export type AddItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter, which AddItem to fetch.
     */
    where?: AddItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddItems to fetch.
     */
    orderBy?: AddItemOrderByWithRelationInput | AddItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddItems.
     */
    cursor?: AddItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddItems.
     */
    distinct?: AddItemScalarFieldEnum | AddItemScalarFieldEnum[]
  }

  /**
   * AddItem findFirstOrThrow
   */
  export type AddItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter, which AddItem to fetch.
     */
    where?: AddItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddItems to fetch.
     */
    orderBy?: AddItemOrderByWithRelationInput | AddItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddItems.
     */
    cursor?: AddItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddItems.
     */
    distinct?: AddItemScalarFieldEnum | AddItemScalarFieldEnum[]
  }

  /**
   * AddItem findMany
   */
  export type AddItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter, which AddItems to fetch.
     */
    where?: AddItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddItems to fetch.
     */
    orderBy?: AddItemOrderByWithRelationInput | AddItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddItems.
     */
    cursor?: AddItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddItems.
     */
    skip?: number
    distinct?: AddItemScalarFieldEnum | AddItemScalarFieldEnum[]
  }

  /**
   * AddItem create
   */
  export type AddItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AddItem.
     */
    data: XOR<AddItemCreateInput, AddItemUncheckedCreateInput>
  }

  /**
   * AddItem createMany
   */
  export type AddItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddItems.
     */
    data: AddItemCreateManyInput | AddItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddItem update
   */
  export type AddItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AddItem.
     */
    data: XOR<AddItemUpdateInput, AddItemUncheckedUpdateInput>
    /**
     * Choose, which AddItem to update.
     */
    where: AddItemWhereUniqueInput
  }

  /**
   * AddItem updateMany
   */
  export type AddItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddItems.
     */
    data: XOR<AddItemUpdateManyMutationInput, AddItemUncheckedUpdateManyInput>
    /**
     * Filter which AddItems to update
     */
    where?: AddItemWhereInput
    /**
     * Limit how many AddItems to update.
     */
    limit?: number
  }

  /**
   * AddItem upsert
   */
  export type AddItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AddItem to update in case it exists.
     */
    where: AddItemWhereUniqueInput
    /**
     * In case the AddItem found by the `where` argument doesn't exist, create a new AddItem with this data.
     */
    create: XOR<AddItemCreateInput, AddItemUncheckedCreateInput>
    /**
     * In case the AddItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddItemUpdateInput, AddItemUncheckedUpdateInput>
  }

  /**
   * AddItem delete
   */
  export type AddItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
    /**
     * Filter which AddItem to delete.
     */
    where: AddItemWhereUniqueInput
  }

  /**
   * AddItem deleteMany
   */
  export type AddItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddItems to delete
     */
    where?: AddItemWhereInput
    /**
     * Limit how many AddItems to delete.
     */
    limit?: number
  }

  /**
   * AddItem.casting_items
   */
  export type AddItem$casting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    where?: CastingItemsWhereInput
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    cursor?: CastingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * AddItem.stock
   */
  export type AddItem$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * AddItem.filing_items
   */
  export type AddItem$filing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * AddItem.setting_items
   */
  export type AddItem$setting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    cursor?: SettingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * AddItem.buffing_items
   */
  export type AddItem$buffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    where?: BuffingItemsWhereInput
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    cursor?: BuffingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * AddItem without action
   */
  export type AddItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddItem
     */
    select?: AddItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddItem
     */
    omit?: AddItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddItemInclude<ExtArgs> | null
  }


  /**
   * Model AddTouch
   */

  export type AggregateAddTouch = {
    _count: AddTouchCountAggregateOutputType | null
    _avg: AddTouchAvgAggregateOutputType | null
    _sum: AddTouchSumAggregateOutputType | null
    _min: AddTouchMinAggregateOutputType | null
    _max: AddTouchMaxAggregateOutputType | null
  }

  export type AddTouchAvgAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type AddTouchSumAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type AddTouchMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    touch: number | null
  }

  export type AddTouchMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    touch: number | null
  }

  export type AddTouchCountAggregateOutputType = {
    id: number
    createdAt: number
    touch: number
    _all: number
  }


  export type AddTouchAvgAggregateInputType = {
    id?: true
    touch?: true
  }

  export type AddTouchSumAggregateInputType = {
    id?: true
    touch?: true
  }

  export type AddTouchMinAggregateInputType = {
    id?: true
    createdAt?: true
    touch?: true
  }

  export type AddTouchMaxAggregateInputType = {
    id?: true
    createdAt?: true
    touch?: true
  }

  export type AddTouchCountAggregateInputType = {
    id?: true
    createdAt?: true
    touch?: true
    _all?: true
  }

  export type AddTouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddTouch to aggregate.
     */
    where?: AddTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddTouches to fetch.
     */
    orderBy?: AddTouchOrderByWithRelationInput | AddTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddTouches
    **/
    _count?: true | AddTouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddTouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddTouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddTouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddTouchMaxAggregateInputType
  }

  export type GetAddTouchAggregateType<T extends AddTouchAggregateArgs> = {
        [P in keyof T & keyof AggregateAddTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddTouch[P]>
      : GetScalarType<T[P], AggregateAddTouch[P]>
  }




  export type AddTouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddTouchWhereInput
    orderBy?: AddTouchOrderByWithAggregationInput | AddTouchOrderByWithAggregationInput[]
    by: AddTouchScalarFieldEnum[] | AddTouchScalarFieldEnum
    having?: AddTouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddTouchCountAggregateInputType | true
    _avg?: AddTouchAvgAggregateInputType
    _sum?: AddTouchSumAggregateInputType
    _min?: AddTouchMinAggregateInputType
    _max?: AddTouchMaxAggregateInputType
  }

  export type AddTouchGroupByOutputType = {
    id: number
    createdAt: Date
    touch: number
    _count: AddTouchCountAggregateOutputType | null
    _avg: AddTouchAvgAggregateOutputType | null
    _sum: AddTouchSumAggregateOutputType | null
    _min: AddTouchMinAggregateOutputType | null
    _max: AddTouchMaxAggregateOutputType | null
  }

  type GetAddTouchGroupByPayload<T extends AddTouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddTouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddTouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddTouchGroupByOutputType[P]>
            : GetScalarType<T[P], AddTouchGroupByOutputType[P]>
        }
      >
    >


  export type AddTouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    touch?: boolean
    casting_entry?: boolean | AddTouch$casting_entryArgs<ExtArgs>
    casting_items?: boolean | AddTouch$casting_itemsArgs<ExtArgs>
    filing_items?: boolean | AddTouch$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | AddTouch$setting_itemsArgs<ExtArgs>
    buffing_items?: boolean | AddTouch$buffing_itemsArgs<ExtArgs>
    stock?: boolean | AddTouch$stockArgs<ExtArgs>
    _count?: boolean | AddTouchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addTouch"]>



  export type AddTouchSelectScalar = {
    id?: boolean
    createdAt?: boolean
    touch?: boolean
  }

  export type AddTouchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "touch", ExtArgs["result"]["addTouch"]>
  export type AddTouchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    casting_entry?: boolean | AddTouch$casting_entryArgs<ExtArgs>
    casting_items?: boolean | AddTouch$casting_itemsArgs<ExtArgs>
    filing_items?: boolean | AddTouch$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | AddTouch$setting_itemsArgs<ExtArgs>
    buffing_items?: boolean | AddTouch$buffing_itemsArgs<ExtArgs>
    stock?: boolean | AddTouch$stockArgs<ExtArgs>
    _count?: boolean | AddTouchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AddTouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddTouch"
    objects: {
      casting_entry: Prisma.$CastingEntryPayload<ExtArgs>[]
      casting_items: Prisma.$CastingItemsPayload<ExtArgs>[]
      filing_items: Prisma.$FilingItemsPayload<ExtArgs>[]
      setting_items: Prisma.$SettingItemsPayload<ExtArgs>[]
      buffing_items: Prisma.$BuffingItemsPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      touch: number
    }, ExtArgs["result"]["addTouch"]>
    composites: {}
  }

  type AddTouchGetPayload<S extends boolean | null | undefined | AddTouchDefaultArgs> = $Result.GetResult<Prisma.$AddTouchPayload, S>

  type AddTouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddTouchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddTouchCountAggregateInputType | true
    }

  export interface AddTouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddTouch'], meta: { name: 'AddTouch' } }
    /**
     * Find zero or one AddTouch that matches the filter.
     * @param {AddTouchFindUniqueArgs} args - Arguments to find a AddTouch
     * @example
     * // Get one AddTouch
     * const addTouch = await prisma.addTouch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddTouchFindUniqueArgs>(args: SelectSubset<T, AddTouchFindUniqueArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddTouch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddTouchFindUniqueOrThrowArgs} args - Arguments to find a AddTouch
     * @example
     * // Get one AddTouch
     * const addTouch = await prisma.addTouch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddTouchFindUniqueOrThrowArgs>(args: SelectSubset<T, AddTouchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddTouch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchFindFirstArgs} args - Arguments to find a AddTouch
     * @example
     * // Get one AddTouch
     * const addTouch = await prisma.addTouch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddTouchFindFirstArgs>(args?: SelectSubset<T, AddTouchFindFirstArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddTouch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchFindFirstOrThrowArgs} args - Arguments to find a AddTouch
     * @example
     * // Get one AddTouch
     * const addTouch = await prisma.addTouch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddTouchFindFirstOrThrowArgs>(args?: SelectSubset<T, AddTouchFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddTouches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddTouches
     * const addTouches = await prisma.addTouch.findMany()
     * 
     * // Get first 10 AddTouches
     * const addTouches = await prisma.addTouch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addTouchWithIdOnly = await prisma.addTouch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddTouchFindManyArgs>(args?: SelectSubset<T, AddTouchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddTouch.
     * @param {AddTouchCreateArgs} args - Arguments to create a AddTouch.
     * @example
     * // Create one AddTouch
     * const AddTouch = await prisma.addTouch.create({
     *   data: {
     *     // ... data to create a AddTouch
     *   }
     * })
     * 
     */
    create<T extends AddTouchCreateArgs>(args: SelectSubset<T, AddTouchCreateArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddTouches.
     * @param {AddTouchCreateManyArgs} args - Arguments to create many AddTouches.
     * @example
     * // Create many AddTouches
     * const addTouch = await prisma.addTouch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddTouchCreateManyArgs>(args?: SelectSubset<T, AddTouchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddTouch.
     * @param {AddTouchDeleteArgs} args - Arguments to delete one AddTouch.
     * @example
     * // Delete one AddTouch
     * const AddTouch = await prisma.addTouch.delete({
     *   where: {
     *     // ... filter to delete one AddTouch
     *   }
     * })
     * 
     */
    delete<T extends AddTouchDeleteArgs>(args: SelectSubset<T, AddTouchDeleteArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddTouch.
     * @param {AddTouchUpdateArgs} args - Arguments to update one AddTouch.
     * @example
     * // Update one AddTouch
     * const addTouch = await prisma.addTouch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddTouchUpdateArgs>(args: SelectSubset<T, AddTouchUpdateArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddTouches.
     * @param {AddTouchDeleteManyArgs} args - Arguments to filter AddTouches to delete.
     * @example
     * // Delete a few AddTouches
     * const { count } = await prisma.addTouch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddTouchDeleteManyArgs>(args?: SelectSubset<T, AddTouchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddTouches
     * const addTouch = await prisma.addTouch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddTouchUpdateManyArgs>(args: SelectSubset<T, AddTouchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddTouch.
     * @param {AddTouchUpsertArgs} args - Arguments to update or create a AddTouch.
     * @example
     * // Update or create a AddTouch
     * const addTouch = await prisma.addTouch.upsert({
     *   create: {
     *     // ... data to create a AddTouch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddTouch we want to update
     *   }
     * })
     */
    upsert<T extends AddTouchUpsertArgs>(args: SelectSubset<T, AddTouchUpsertArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchCountArgs} args - Arguments to filter AddTouches to count.
     * @example
     * // Count the number of AddTouches
     * const count = await prisma.addTouch.count({
     *   where: {
     *     // ... the filter for the AddTouches we want to count
     *   }
     * })
    **/
    count<T extends AddTouchCountArgs>(
      args?: Subset<T, AddTouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddTouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddTouchAggregateArgs>(args: Subset<T, AddTouchAggregateArgs>): Prisma.PrismaPromise<GetAddTouchAggregateType<T>>

    /**
     * Group by AddTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddTouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddTouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddTouchGroupByArgs['orderBy'] }
        : { orderBy?: AddTouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddTouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddTouch model
   */
  readonly fields: AddTouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddTouch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddTouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    casting_entry<T extends AddTouch$casting_entryArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$casting_entryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casting_items<T extends AddTouch$casting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$casting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filing_items<T extends AddTouch$filing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$filing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    setting_items<T extends AddTouch$setting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$setting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffing_items<T extends AddTouch$buffing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$buffing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends AddTouch$stockArgs<ExtArgs> = {}>(args?: Subset<T, AddTouch$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddTouch model
   */
  interface AddTouchFieldRefs {
    readonly id: FieldRef<"AddTouch", 'Int'>
    readonly createdAt: FieldRef<"AddTouch", 'DateTime'>
    readonly touch: FieldRef<"AddTouch", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AddTouch findUnique
   */
  export type AddTouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter, which AddTouch to fetch.
     */
    where: AddTouchWhereUniqueInput
  }

  /**
   * AddTouch findUniqueOrThrow
   */
  export type AddTouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter, which AddTouch to fetch.
     */
    where: AddTouchWhereUniqueInput
  }

  /**
   * AddTouch findFirst
   */
  export type AddTouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter, which AddTouch to fetch.
     */
    where?: AddTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddTouches to fetch.
     */
    orderBy?: AddTouchOrderByWithRelationInput | AddTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddTouches.
     */
    cursor?: AddTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddTouches.
     */
    distinct?: AddTouchScalarFieldEnum | AddTouchScalarFieldEnum[]
  }

  /**
   * AddTouch findFirstOrThrow
   */
  export type AddTouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter, which AddTouch to fetch.
     */
    where?: AddTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddTouches to fetch.
     */
    orderBy?: AddTouchOrderByWithRelationInput | AddTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddTouches.
     */
    cursor?: AddTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddTouches.
     */
    distinct?: AddTouchScalarFieldEnum | AddTouchScalarFieldEnum[]
  }

  /**
   * AddTouch findMany
   */
  export type AddTouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter, which AddTouches to fetch.
     */
    where?: AddTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddTouches to fetch.
     */
    orderBy?: AddTouchOrderByWithRelationInput | AddTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddTouches.
     */
    cursor?: AddTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddTouches.
     */
    skip?: number
    distinct?: AddTouchScalarFieldEnum | AddTouchScalarFieldEnum[]
  }

  /**
   * AddTouch create
   */
  export type AddTouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * The data needed to create a AddTouch.
     */
    data: XOR<AddTouchCreateInput, AddTouchUncheckedCreateInput>
  }

  /**
   * AddTouch createMany
   */
  export type AddTouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddTouches.
     */
    data: AddTouchCreateManyInput | AddTouchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddTouch update
   */
  export type AddTouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * The data needed to update a AddTouch.
     */
    data: XOR<AddTouchUpdateInput, AddTouchUncheckedUpdateInput>
    /**
     * Choose, which AddTouch to update.
     */
    where: AddTouchWhereUniqueInput
  }

  /**
   * AddTouch updateMany
   */
  export type AddTouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddTouches.
     */
    data: XOR<AddTouchUpdateManyMutationInput, AddTouchUncheckedUpdateManyInput>
    /**
     * Filter which AddTouches to update
     */
    where?: AddTouchWhereInput
    /**
     * Limit how many AddTouches to update.
     */
    limit?: number
  }

  /**
   * AddTouch upsert
   */
  export type AddTouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * The filter to search for the AddTouch to update in case it exists.
     */
    where: AddTouchWhereUniqueInput
    /**
     * In case the AddTouch found by the `where` argument doesn't exist, create a new AddTouch with this data.
     */
    create: XOR<AddTouchCreateInput, AddTouchUncheckedCreateInput>
    /**
     * In case the AddTouch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddTouchUpdateInput, AddTouchUncheckedUpdateInput>
  }

  /**
   * AddTouch delete
   */
  export type AddTouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
    /**
     * Filter which AddTouch to delete.
     */
    where: AddTouchWhereUniqueInput
  }

  /**
   * AddTouch deleteMany
   */
  export type AddTouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddTouches to delete
     */
    where?: AddTouchWhereInput
    /**
     * Limit how many AddTouches to delete.
     */
    limit?: number
  }

  /**
   * AddTouch.casting_entry
   */
  export type AddTouch$casting_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    where?: CastingEntryWhereInput
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    cursor?: CastingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingEntryScalarFieldEnum | CastingEntryScalarFieldEnum[]
  }

  /**
   * AddTouch.casting_items
   */
  export type AddTouch$casting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    where?: CastingItemsWhereInput
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    cursor?: CastingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * AddTouch.filing_items
   */
  export type AddTouch$filing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * AddTouch.setting_items
   */
  export type AddTouch$setting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    cursor?: SettingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * AddTouch.buffing_items
   */
  export type AddTouch$buffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    where?: BuffingItemsWhereInput
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    cursor?: BuffingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * AddTouch.stock
   */
  export type AddTouch$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * AddTouch without action
   */
  export type AddTouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddTouch
     */
    select?: AddTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddTouch
     */
    omit?: AddTouchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddTouchInclude<ExtArgs> | null
  }


  /**
   * Model CastingEntry
   */

  export type AggregateCastingEntry = {
    _count: CastingEntryCountAggregateOutputType | null
    _avg: CastingEntryAvgAggregateOutputType | null
    _sum: CastingEntrySumAggregateOutputType | null
    _min: CastingEntryMinAggregateOutputType | null
    _max: CastingEntryMaxAggregateOutputType | null
  }

  export type CastingEntryAvgAggregateOutputType = {
    id: number | null
    given_gold: number | null
    touch_id: number | null
    purity: number | null
    final_touch: number | null
    pure_value: number | null
    copper: number | null
    final_weight: number | null
    casting_customer_id: number | null
  }

  export type CastingEntrySumAggregateOutputType = {
    id: number | null
    given_gold: number | null
    touch_id: number | null
    purity: number | null
    final_touch: number | null
    pure_value: number | null
    copper: number | null
    final_weight: number | null
    casting_customer_id: number | null
  }

  export type CastingEntryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    given_gold: number | null
    touch_id: number | null
    purity: number | null
    final_touch: number | null
    pure_value: number | null
    copper: number | null
    final_weight: number | null
    casting_customer_id: number | null
  }

  export type CastingEntryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    date: Date | null
    given_gold: number | null
    touch_id: number | null
    purity: number | null
    final_touch: number | null
    pure_value: number | null
    copper: number | null
    final_weight: number | null
    casting_customer_id: number | null
  }

  export type CastingEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    _all: number
  }


  export type CastingEntryAvgAggregateInputType = {
    id?: true
    given_gold?: true
    touch_id?: true
    purity?: true
    final_touch?: true
    pure_value?: true
    copper?: true
    final_weight?: true
    casting_customer_id?: true
  }

  export type CastingEntrySumAggregateInputType = {
    id?: true
    given_gold?: true
    touch_id?: true
    purity?: true
    final_touch?: true
    pure_value?: true
    copper?: true
    final_weight?: true
    casting_customer_id?: true
  }

  export type CastingEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    given_gold?: true
    touch_id?: true
    purity?: true
    final_touch?: true
    pure_value?: true
    copper?: true
    final_weight?: true
    casting_customer_id?: true
  }

  export type CastingEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    given_gold?: true
    touch_id?: true
    purity?: true
    final_touch?: true
    pure_value?: true
    copper?: true
    final_weight?: true
    casting_customer_id?: true
  }

  export type CastingEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    given_gold?: true
    touch_id?: true
    purity?: true
    final_touch?: true
    pure_value?: true
    copper?: true
    final_weight?: true
    casting_customer_id?: true
    _all?: true
  }

  export type CastingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastingEntry to aggregate.
     */
    where?: CastingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingEntries to fetch.
     */
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CastingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CastingEntries
    **/
    _count?: true | CastingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CastingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CastingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CastingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CastingEntryMaxAggregateInputType
  }

  export type GetCastingEntryAggregateType<T extends CastingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCastingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCastingEntry[P]>
      : GetScalarType<T[P], AggregateCastingEntry[P]>
  }




  export type CastingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingEntryWhereInput
    orderBy?: CastingEntryOrderByWithAggregationInput | CastingEntryOrderByWithAggregationInput[]
    by: CastingEntryScalarFieldEnum[] | CastingEntryScalarFieldEnum
    having?: CastingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CastingEntryCountAggregateInputType | true
    _avg?: CastingEntryAvgAggregateInputType
    _sum?: CastingEntrySumAggregateInputType
    _min?: CastingEntryMinAggregateInputType
    _max?: CastingEntryMaxAggregateInputType
  }

  export type CastingEntryGroupByOutputType = {
    id: number
    createdAt: Date
    date: Date
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    _count: CastingEntryCountAggregateOutputType | null
    _avg: CastingEntryAvgAggregateOutputType | null
    _sum: CastingEntrySumAggregateOutputType | null
    _min: CastingEntryMinAggregateOutputType | null
    _max: CastingEntryMaxAggregateOutputType | null
  }

  type GetCastingEntryGroupByPayload<T extends CastingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CastingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CastingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CastingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CastingEntryGroupByOutputType[P]>
        }
      >
    >


  export type CastingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    given_gold?: boolean
    touch_id?: boolean
    purity?: boolean
    final_touch?: boolean
    pure_value?: boolean
    copper?: boolean
    final_weight?: boolean
    casting_customer_id?: boolean
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
    items?: boolean | CastingEntry$itemsArgs<ExtArgs>
    CastiingTotalBalance?: boolean | CastingEntry$CastiingTotalBalanceArgs<ExtArgs>
    _count?: boolean | CastingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["castingEntry"]>



  export type CastingEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    given_gold?: boolean
    touch_id?: boolean
    purity?: boolean
    final_touch?: boolean
    pure_value?: boolean
    copper?: boolean
    final_weight?: boolean
    casting_customer_id?: boolean
  }

  export type CastingEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "date" | "given_gold" | "touch_id" | "purity" | "final_touch" | "pure_value" | "copper" | "final_weight" | "casting_customer_id", ExtArgs["result"]["castingEntry"]>
  export type CastingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
    items?: boolean | CastingEntry$itemsArgs<ExtArgs>
    CastiingTotalBalance?: boolean | CastingEntry$CastiingTotalBalanceArgs<ExtArgs>
    _count?: boolean | CastingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CastingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CastingEntry"
    objects: {
      touch: Prisma.$AddTouchPayload<ExtArgs>
      casting_customer: Prisma.$AddCastingPayload<ExtArgs>
      items: Prisma.$CastingItemsPayload<ExtArgs>[]
      CastiingTotalBalance: Prisma.$CastiingTotalBalancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      date: Date
      given_gold: number
      touch_id: number
      purity: number
      final_touch: number
      pure_value: number
      copper: number
      final_weight: number
      casting_customer_id: number
    }, ExtArgs["result"]["castingEntry"]>
    composites: {}
  }

  type CastingEntryGetPayload<S extends boolean | null | undefined | CastingEntryDefaultArgs> = $Result.GetResult<Prisma.$CastingEntryPayload, S>

  type CastingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CastingEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CastingEntryCountAggregateInputType | true
    }

  export interface CastingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CastingEntry'], meta: { name: 'CastingEntry' } }
    /**
     * Find zero or one CastingEntry that matches the filter.
     * @param {CastingEntryFindUniqueArgs} args - Arguments to find a CastingEntry
     * @example
     * // Get one CastingEntry
     * const castingEntry = await prisma.castingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CastingEntryFindUniqueArgs>(args: SelectSubset<T, CastingEntryFindUniqueArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CastingEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CastingEntryFindUniqueOrThrowArgs} args - Arguments to find a CastingEntry
     * @example
     * // Get one CastingEntry
     * const castingEntry = await prisma.castingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CastingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CastingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryFindFirstArgs} args - Arguments to find a CastingEntry
     * @example
     * // Get one CastingEntry
     * const castingEntry = await prisma.castingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CastingEntryFindFirstArgs>(args?: SelectSubset<T, CastingEntryFindFirstArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryFindFirstOrThrowArgs} args - Arguments to find a CastingEntry
     * @example
     * // Get one CastingEntry
     * const castingEntry = await prisma.castingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CastingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CastingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CastingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CastingEntries
     * const castingEntries = await prisma.castingEntry.findMany()
     * 
     * // Get first 10 CastingEntries
     * const castingEntries = await prisma.castingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const castingEntryWithIdOnly = await prisma.castingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CastingEntryFindManyArgs>(args?: SelectSubset<T, CastingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CastingEntry.
     * @param {CastingEntryCreateArgs} args - Arguments to create a CastingEntry.
     * @example
     * // Create one CastingEntry
     * const CastingEntry = await prisma.castingEntry.create({
     *   data: {
     *     // ... data to create a CastingEntry
     *   }
     * })
     * 
     */
    create<T extends CastingEntryCreateArgs>(args: SelectSubset<T, CastingEntryCreateArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CastingEntries.
     * @param {CastingEntryCreateManyArgs} args - Arguments to create many CastingEntries.
     * @example
     * // Create many CastingEntries
     * const castingEntry = await prisma.castingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CastingEntryCreateManyArgs>(args?: SelectSubset<T, CastingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CastingEntry.
     * @param {CastingEntryDeleteArgs} args - Arguments to delete one CastingEntry.
     * @example
     * // Delete one CastingEntry
     * const CastingEntry = await prisma.castingEntry.delete({
     *   where: {
     *     // ... filter to delete one CastingEntry
     *   }
     * })
     * 
     */
    delete<T extends CastingEntryDeleteArgs>(args: SelectSubset<T, CastingEntryDeleteArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CastingEntry.
     * @param {CastingEntryUpdateArgs} args - Arguments to update one CastingEntry.
     * @example
     * // Update one CastingEntry
     * const castingEntry = await prisma.castingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CastingEntryUpdateArgs>(args: SelectSubset<T, CastingEntryUpdateArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CastingEntries.
     * @param {CastingEntryDeleteManyArgs} args - Arguments to filter CastingEntries to delete.
     * @example
     * // Delete a few CastingEntries
     * const { count } = await prisma.castingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CastingEntryDeleteManyArgs>(args?: SelectSubset<T, CastingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CastingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CastingEntries
     * const castingEntry = await prisma.castingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CastingEntryUpdateManyArgs>(args: SelectSubset<T, CastingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CastingEntry.
     * @param {CastingEntryUpsertArgs} args - Arguments to update or create a CastingEntry.
     * @example
     * // Update or create a CastingEntry
     * const castingEntry = await prisma.castingEntry.upsert({
     *   create: {
     *     // ... data to create a CastingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CastingEntry we want to update
     *   }
     * })
     */
    upsert<T extends CastingEntryUpsertArgs>(args: SelectSubset<T, CastingEntryUpsertArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CastingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryCountArgs} args - Arguments to filter CastingEntries to count.
     * @example
     * // Count the number of CastingEntries
     * const count = await prisma.castingEntry.count({
     *   where: {
     *     // ... the filter for the CastingEntries we want to count
     *   }
     * })
    **/
    count<T extends CastingEntryCountArgs>(
      args?: Subset<T, CastingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CastingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CastingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CastingEntryAggregateArgs>(args: Subset<T, CastingEntryAggregateArgs>): Prisma.PrismaPromise<GetCastingEntryAggregateType<T>>

    /**
     * Group by CastingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CastingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CastingEntryGroupByArgs['orderBy'] }
        : { orderBy?: CastingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CastingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCastingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CastingEntry model
   */
  readonly fields: CastingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CastingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CastingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    casting_customer<T extends AddCastingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddCastingDefaultArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends CastingEntry$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CastingEntry$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CastiingTotalBalance<T extends CastingEntry$CastiingTotalBalanceArgs<ExtArgs> = {}>(args?: Subset<T, CastingEntry$CastiingTotalBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CastingEntry model
   */
  interface CastingEntryFieldRefs {
    readonly id: FieldRef<"CastingEntry", 'Int'>
    readonly createdAt: FieldRef<"CastingEntry", 'DateTime'>
    readonly date: FieldRef<"CastingEntry", 'DateTime'>
    readonly given_gold: FieldRef<"CastingEntry", 'Float'>
    readonly touch_id: FieldRef<"CastingEntry", 'Int'>
    readonly purity: FieldRef<"CastingEntry", 'Float'>
    readonly final_touch: FieldRef<"CastingEntry", 'Float'>
    readonly pure_value: FieldRef<"CastingEntry", 'Float'>
    readonly copper: FieldRef<"CastingEntry", 'Float'>
    readonly final_weight: FieldRef<"CastingEntry", 'Float'>
    readonly casting_customer_id: FieldRef<"CastingEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CastingEntry findUnique
   */
  export type CastingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter, which CastingEntry to fetch.
     */
    where: CastingEntryWhereUniqueInput
  }

  /**
   * CastingEntry findUniqueOrThrow
   */
  export type CastingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter, which CastingEntry to fetch.
     */
    where: CastingEntryWhereUniqueInput
  }

  /**
   * CastingEntry findFirst
   */
  export type CastingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter, which CastingEntry to fetch.
     */
    where?: CastingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingEntries to fetch.
     */
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastingEntries.
     */
    cursor?: CastingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastingEntries.
     */
    distinct?: CastingEntryScalarFieldEnum | CastingEntryScalarFieldEnum[]
  }

  /**
   * CastingEntry findFirstOrThrow
   */
  export type CastingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter, which CastingEntry to fetch.
     */
    where?: CastingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingEntries to fetch.
     */
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastingEntries.
     */
    cursor?: CastingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastingEntries.
     */
    distinct?: CastingEntryScalarFieldEnum | CastingEntryScalarFieldEnum[]
  }

  /**
   * CastingEntry findMany
   */
  export type CastingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter, which CastingEntries to fetch.
     */
    where?: CastingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingEntries to fetch.
     */
    orderBy?: CastingEntryOrderByWithRelationInput | CastingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CastingEntries.
     */
    cursor?: CastingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingEntries.
     */
    skip?: number
    distinct?: CastingEntryScalarFieldEnum | CastingEntryScalarFieldEnum[]
  }

  /**
   * CastingEntry create
   */
  export type CastingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a CastingEntry.
     */
    data: XOR<CastingEntryCreateInput, CastingEntryUncheckedCreateInput>
  }

  /**
   * CastingEntry createMany
   */
  export type CastingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CastingEntries.
     */
    data: CastingEntryCreateManyInput | CastingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CastingEntry update
   */
  export type CastingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a CastingEntry.
     */
    data: XOR<CastingEntryUpdateInput, CastingEntryUncheckedUpdateInput>
    /**
     * Choose, which CastingEntry to update.
     */
    where: CastingEntryWhereUniqueInput
  }

  /**
   * CastingEntry updateMany
   */
  export type CastingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CastingEntries.
     */
    data: XOR<CastingEntryUpdateManyMutationInput, CastingEntryUncheckedUpdateManyInput>
    /**
     * Filter which CastingEntries to update
     */
    where?: CastingEntryWhereInput
    /**
     * Limit how many CastingEntries to update.
     */
    limit?: number
  }

  /**
   * CastingEntry upsert
   */
  export type CastingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the CastingEntry to update in case it exists.
     */
    where: CastingEntryWhereUniqueInput
    /**
     * In case the CastingEntry found by the `where` argument doesn't exist, create a new CastingEntry with this data.
     */
    create: XOR<CastingEntryCreateInput, CastingEntryUncheckedCreateInput>
    /**
     * In case the CastingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CastingEntryUpdateInput, CastingEntryUncheckedUpdateInput>
  }

  /**
   * CastingEntry delete
   */
  export type CastingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
    /**
     * Filter which CastingEntry to delete.
     */
    where: CastingEntryWhereUniqueInput
  }

  /**
   * CastingEntry deleteMany
   */
  export type CastingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastingEntries to delete
     */
    where?: CastingEntryWhereInput
    /**
     * Limit how many CastingEntries to delete.
     */
    limit?: number
  }

  /**
   * CastingEntry.items
   */
  export type CastingEntry$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    where?: CastingItemsWhereInput
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    cursor?: CastingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * CastingEntry.CastiingTotalBalance
   */
  export type CastingEntry$CastiingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    where?: CastiingTotalBalanceWhereInput
    orderBy?: CastiingTotalBalanceOrderByWithRelationInput | CastiingTotalBalanceOrderByWithRelationInput[]
    cursor?: CastiingTotalBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CastiingTotalBalanceScalarFieldEnum | CastiingTotalBalanceScalarFieldEnum[]
  }

  /**
   * CastingEntry without action
   */
  export type CastingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingEntry
     */
    select?: CastingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingEntry
     */
    omit?: CastingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingEntryInclude<ExtArgs> | null
  }


  /**
   * Model CastingItems
   */

  export type AggregateCastingItems = {
    _count: CastingItemsCountAggregateOutputType | null
    _avg: CastingItemsAvgAggregateOutputType | null
    _sum: CastingItemsSumAggregateOutputType | null
    _min: CastingItemsMinAggregateOutputType | null
    _max: CastingItemsMaxAggregateOutputType | null
  }

  export type CastingItemsAvgAggregateOutputType = {
    id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    casting_entry_id: number | null
    casting_customer_id: number | null
  }

  export type CastingItemsSumAggregateOutputType = {
    id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    casting_entry_id: number | null
    casting_customer_id: number | null
  }

  export type CastingItemsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    casting_entry_id: number | null
    casting_customer_id: number | null
  }

  export type CastingItemsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    casting_entry_id: number | null
    casting_customer_id: number | null
  }

  export type CastingItemsCountAggregateOutputType = {
    id: number
    createdAt: number
    type: number
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: number
    casting_entry_id: number
    casting_customer_id: number
    _all: number
  }


  export type CastingItemsAvgAggregateInputType = {
    id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    casting_entry_id?: true
    casting_customer_id?: true
  }

  export type CastingItemsSumAggregateInputType = {
    id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    casting_entry_id?: true
    casting_customer_id?: true
  }

  export type CastingItemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_entry_id?: true
    casting_customer_id?: true
  }

  export type CastingItemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_entry_id?: true
    casting_customer_id?: true
  }

  export type CastingItemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_entry_id?: true
    casting_customer_id?: true
    _all?: true
  }

  export type CastingItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastingItems to aggregate.
     */
    where?: CastingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingItems to fetch.
     */
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CastingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CastingItems
    **/
    _count?: true | CastingItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CastingItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CastingItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CastingItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CastingItemsMaxAggregateInputType
  }

  export type GetCastingItemsAggregateType<T extends CastingItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCastingItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCastingItems[P]>
      : GetScalarType<T[P], AggregateCastingItems[P]>
  }




  export type CastingItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastingItemsWhereInput
    orderBy?: CastingItemsOrderByWithAggregationInput | CastingItemsOrderByWithAggregationInput[]
    by: CastingItemsScalarFieldEnum[] | CastingItemsScalarFieldEnum
    having?: CastingItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CastingItemsCountAggregateInputType | true
    _avg?: CastingItemsAvgAggregateInputType
    _sum?: CastingItemsSumAggregateInputType
    _min?: CastingItemsMinAggregateInputType
    _max?: CastingItemsMaxAggregateInputType
  }

  export type CastingItemsGroupByOutputType = {
    id: number
    createdAt: Date
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: string | null
    casting_entry_id: number
    casting_customer_id: number
    _count: CastingItemsCountAggregateOutputType | null
    _avg: CastingItemsAvgAggregateOutputType | null
    _sum: CastingItemsSumAggregateOutputType | null
    _min: CastingItemsMinAggregateOutputType | null
    _max: CastingItemsMaxAggregateOutputType | null
  }

  type GetCastingItemsGroupByPayload<T extends CastingItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CastingItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CastingItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CastingItemsGroupByOutputType[P]>
            : GetScalarType<T[P], CastingItemsGroupByOutputType[P]>
        }
      >
    >


  export type CastingItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    casting_entry_id?: boolean
    casting_customer_id?: boolean
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    castingEntry?: boolean | CastingEntryDefaultArgs<ExtArgs>
    filingEntry?: boolean | CastingItems$filingEntryArgs<ExtArgs>
    settingEntry?: boolean | CastingItems$settingEntryArgs<ExtArgs>
    buffingEntry?: boolean | CastingItems$buffingEntryArgs<ExtArgs>
    stock?: boolean | CastingItems$stockArgs<ExtArgs>
    filingLotMapper?: boolean | CastingItems$filingLotMapperArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
    _count?: boolean | CastingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["castingItems"]>



  export type CastingItemsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    type?: boolean
    item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    casting_entry_id?: boolean
    casting_customer_id?: boolean
  }

  export type CastingItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "type" | "item_id" | "weight" | "touch_id" | "item_purity" | "remarks" | "casting_entry_id" | "casting_customer_id", ExtArgs["result"]["castingItems"]>
  export type CastingItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    castingEntry?: boolean | CastingEntryDefaultArgs<ExtArgs>
    filingEntry?: boolean | CastingItems$filingEntryArgs<ExtArgs>
    settingEntry?: boolean | CastingItems$settingEntryArgs<ExtArgs>
    buffingEntry?: boolean | CastingItems$buffingEntryArgs<ExtArgs>
    stock?: boolean | CastingItems$stockArgs<ExtArgs>
    filingLotMapper?: boolean | CastingItems$filingLotMapperArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
    _count?: boolean | CastingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CastingItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CastingItems"
    objects: {
      touch: Prisma.$AddTouchPayload<ExtArgs>
      item: Prisma.$AddItemPayload<ExtArgs>
      castingEntry: Prisma.$CastingEntryPayload<ExtArgs>
      filingEntry: Prisma.$FilingEntryPayload<ExtArgs>[]
      settingEntry: Prisma.$SettingEntryPayload<ExtArgs>[]
      buffingEntry: Prisma.$BuffingEntryPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs>[]
      filingLotMapper: Prisma.$LotFilingMapperPayload<ExtArgs>[]
      casting_customer: Prisma.$AddCastingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      type: $Enums.CASTINGENTRYTYPE
      item_id: number
      weight: number
      touch_id: number
      item_purity: number
      remarks: string | null
      casting_entry_id: number
      casting_customer_id: number
    }, ExtArgs["result"]["castingItems"]>
    composites: {}
  }

  type CastingItemsGetPayload<S extends boolean | null | undefined | CastingItemsDefaultArgs> = $Result.GetResult<Prisma.$CastingItemsPayload, S>

  type CastingItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CastingItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CastingItemsCountAggregateInputType | true
    }

  export interface CastingItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CastingItems'], meta: { name: 'CastingItems' } }
    /**
     * Find zero or one CastingItems that matches the filter.
     * @param {CastingItemsFindUniqueArgs} args - Arguments to find a CastingItems
     * @example
     * // Get one CastingItems
     * const castingItems = await prisma.castingItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CastingItemsFindUniqueArgs>(args: SelectSubset<T, CastingItemsFindUniqueArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CastingItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CastingItemsFindUniqueOrThrowArgs} args - Arguments to find a CastingItems
     * @example
     * // Get one CastingItems
     * const castingItems = await prisma.castingItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CastingItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, CastingItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsFindFirstArgs} args - Arguments to find a CastingItems
     * @example
     * // Get one CastingItems
     * const castingItems = await prisma.castingItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CastingItemsFindFirstArgs>(args?: SelectSubset<T, CastingItemsFindFirstArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastingItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsFindFirstOrThrowArgs} args - Arguments to find a CastingItems
     * @example
     * // Get one CastingItems
     * const castingItems = await prisma.castingItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CastingItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, CastingItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CastingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CastingItems
     * const castingItems = await prisma.castingItems.findMany()
     * 
     * // Get first 10 CastingItems
     * const castingItems = await prisma.castingItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const castingItemsWithIdOnly = await prisma.castingItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CastingItemsFindManyArgs>(args?: SelectSubset<T, CastingItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CastingItems.
     * @param {CastingItemsCreateArgs} args - Arguments to create a CastingItems.
     * @example
     * // Create one CastingItems
     * const CastingItems = await prisma.castingItems.create({
     *   data: {
     *     // ... data to create a CastingItems
     *   }
     * })
     * 
     */
    create<T extends CastingItemsCreateArgs>(args: SelectSubset<T, CastingItemsCreateArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CastingItems.
     * @param {CastingItemsCreateManyArgs} args - Arguments to create many CastingItems.
     * @example
     * // Create many CastingItems
     * const castingItems = await prisma.castingItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CastingItemsCreateManyArgs>(args?: SelectSubset<T, CastingItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CastingItems.
     * @param {CastingItemsDeleteArgs} args - Arguments to delete one CastingItems.
     * @example
     * // Delete one CastingItems
     * const CastingItems = await prisma.castingItems.delete({
     *   where: {
     *     // ... filter to delete one CastingItems
     *   }
     * })
     * 
     */
    delete<T extends CastingItemsDeleteArgs>(args: SelectSubset<T, CastingItemsDeleteArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CastingItems.
     * @param {CastingItemsUpdateArgs} args - Arguments to update one CastingItems.
     * @example
     * // Update one CastingItems
     * const castingItems = await prisma.castingItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CastingItemsUpdateArgs>(args: SelectSubset<T, CastingItemsUpdateArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CastingItems.
     * @param {CastingItemsDeleteManyArgs} args - Arguments to filter CastingItems to delete.
     * @example
     * // Delete a few CastingItems
     * const { count } = await prisma.castingItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CastingItemsDeleteManyArgs>(args?: SelectSubset<T, CastingItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CastingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CastingItems
     * const castingItems = await prisma.castingItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CastingItemsUpdateManyArgs>(args: SelectSubset<T, CastingItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CastingItems.
     * @param {CastingItemsUpsertArgs} args - Arguments to update or create a CastingItems.
     * @example
     * // Update or create a CastingItems
     * const castingItems = await prisma.castingItems.upsert({
     *   create: {
     *     // ... data to create a CastingItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CastingItems we want to update
     *   }
     * })
     */
    upsert<T extends CastingItemsUpsertArgs>(args: SelectSubset<T, CastingItemsUpsertArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CastingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsCountArgs} args - Arguments to filter CastingItems to count.
     * @example
     * // Count the number of CastingItems
     * const count = await prisma.castingItems.count({
     *   where: {
     *     // ... the filter for the CastingItems we want to count
     *   }
     * })
    **/
    count<T extends CastingItemsCountArgs>(
      args?: Subset<T, CastingItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CastingItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CastingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CastingItemsAggregateArgs>(args: Subset<T, CastingItemsAggregateArgs>): Prisma.PrismaPromise<GetCastingItemsAggregateType<T>>

    /**
     * Group by CastingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastingItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CastingItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CastingItemsGroupByArgs['orderBy'] }
        : { orderBy?: CastingItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CastingItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCastingItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CastingItems model
   */
  readonly fields: CastingItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CastingItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CastingItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends AddItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddItemDefaultArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    castingEntry<T extends CastingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingEntryDefaultArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filingEntry<T extends CastingItems$filingEntryArgs<ExtArgs> = {}>(args?: Subset<T, CastingItems$filingEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingEntry<T extends CastingItems$settingEntryArgs<ExtArgs> = {}>(args?: Subset<T, CastingItems$settingEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingEntry<T extends CastingItems$buffingEntryArgs<ExtArgs> = {}>(args?: Subset<T, CastingItems$buffingEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends CastingItems$stockArgs<ExtArgs> = {}>(args?: Subset<T, CastingItems$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filingLotMapper<T extends CastingItems$filingLotMapperArgs<ExtArgs> = {}>(args?: Subset<T, CastingItems$filingLotMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casting_customer<T extends AddCastingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddCastingDefaultArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CastingItems model
   */
  interface CastingItemsFieldRefs {
    readonly id: FieldRef<"CastingItems", 'Int'>
    readonly createdAt: FieldRef<"CastingItems", 'DateTime'>
    readonly type: FieldRef<"CastingItems", 'CASTINGENTRYTYPE'>
    readonly item_id: FieldRef<"CastingItems", 'Int'>
    readonly weight: FieldRef<"CastingItems", 'Float'>
    readonly touch_id: FieldRef<"CastingItems", 'Int'>
    readonly item_purity: FieldRef<"CastingItems", 'Float'>
    readonly remarks: FieldRef<"CastingItems", 'String'>
    readonly casting_entry_id: FieldRef<"CastingItems", 'Int'>
    readonly casting_customer_id: FieldRef<"CastingItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CastingItems findUnique
   */
  export type CastingItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter, which CastingItems to fetch.
     */
    where: CastingItemsWhereUniqueInput
  }

  /**
   * CastingItems findUniqueOrThrow
   */
  export type CastingItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter, which CastingItems to fetch.
     */
    where: CastingItemsWhereUniqueInput
  }

  /**
   * CastingItems findFirst
   */
  export type CastingItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter, which CastingItems to fetch.
     */
    where?: CastingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingItems to fetch.
     */
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastingItems.
     */
    cursor?: CastingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastingItems.
     */
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * CastingItems findFirstOrThrow
   */
  export type CastingItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter, which CastingItems to fetch.
     */
    where?: CastingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingItems to fetch.
     */
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastingItems.
     */
    cursor?: CastingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastingItems.
     */
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * CastingItems findMany
   */
  export type CastingItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter, which CastingItems to fetch.
     */
    where?: CastingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastingItems to fetch.
     */
    orderBy?: CastingItemsOrderByWithRelationInput | CastingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CastingItems.
     */
    cursor?: CastingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastingItems.
     */
    skip?: number
    distinct?: CastingItemsScalarFieldEnum | CastingItemsScalarFieldEnum[]
  }

  /**
   * CastingItems create
   */
  export type CastingItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a CastingItems.
     */
    data: XOR<CastingItemsCreateInput, CastingItemsUncheckedCreateInput>
  }

  /**
   * CastingItems createMany
   */
  export type CastingItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CastingItems.
     */
    data: CastingItemsCreateManyInput | CastingItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CastingItems update
   */
  export type CastingItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a CastingItems.
     */
    data: XOR<CastingItemsUpdateInput, CastingItemsUncheckedUpdateInput>
    /**
     * Choose, which CastingItems to update.
     */
    where: CastingItemsWhereUniqueInput
  }

  /**
   * CastingItems updateMany
   */
  export type CastingItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CastingItems.
     */
    data: XOR<CastingItemsUpdateManyMutationInput, CastingItemsUncheckedUpdateManyInput>
    /**
     * Filter which CastingItems to update
     */
    where?: CastingItemsWhereInput
    /**
     * Limit how many CastingItems to update.
     */
    limit?: number
  }

  /**
   * CastingItems upsert
   */
  export type CastingItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the CastingItems to update in case it exists.
     */
    where: CastingItemsWhereUniqueInput
    /**
     * In case the CastingItems found by the `where` argument doesn't exist, create a new CastingItems with this data.
     */
    create: XOR<CastingItemsCreateInput, CastingItemsUncheckedCreateInput>
    /**
     * In case the CastingItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CastingItemsUpdateInput, CastingItemsUncheckedUpdateInput>
  }

  /**
   * CastingItems delete
   */
  export type CastingItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    /**
     * Filter which CastingItems to delete.
     */
    where: CastingItemsWhereUniqueInput
  }

  /**
   * CastingItems deleteMany
   */
  export type CastingItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastingItems to delete
     */
    where?: CastingItemsWhereInput
    /**
     * Limit how many CastingItems to delete.
     */
    limit?: number
  }

  /**
   * CastingItems.filingEntry
   */
  export type CastingItems$filingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    where?: FilingEntryWhereInput
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    cursor?: FilingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingEntryScalarFieldEnum | FilingEntryScalarFieldEnum[]
  }

  /**
   * CastingItems.settingEntry
   */
  export type CastingItems$settingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    where?: SettingEntryWhereInput
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    cursor?: SettingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * CastingItems.buffingEntry
   */
  export type CastingItems$buffingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    where?: BuffingEntryWhereInput
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    cursor?: BuffingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * CastingItems.stock
   */
  export type CastingItems$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * CastingItems.filingLotMapper
   */
  export type CastingItems$filingLotMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    where?: LotFilingMapperWhereInput
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    cursor?: LotFilingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * CastingItems without action
   */
  export type CastingItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
  }


  /**
   * Model CastiingTotalBalance
   */

  export type AggregateCastiingTotalBalance = {
    _count: CastiingTotalBalanceCountAggregateOutputType | null
    _avg: CastiingTotalBalanceAvgAggregateOutputType | null
    _sum: CastiingTotalBalanceSumAggregateOutputType | null
    _min: CastiingTotalBalanceMinAggregateOutputType | null
    _max: CastiingTotalBalanceMaxAggregateOutputType | null
  }

  export type CastiingTotalBalanceAvgAggregateOutputType = {
    id: number | null
    total_item_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    total_wastage: number | null
    item_entry: number | null
  }

  export type CastiingTotalBalanceSumAggregateOutputType = {
    id: number | null
    total_item_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    total_wastage: number | null
    item_entry: number | null
  }

  export type CastiingTotalBalanceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_item_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    total_wastage: number | null
    item_entry: number | null
  }

  export type CastiingTotalBalanceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_item_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    total_wastage: number | null
    item_entry: number | null
  }

  export type CastiingTotalBalanceCountAggregateOutputType = {
    id: number
    createdAt: number
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight: number
    total_wastage: number
    item_entry: number
    _all: number
  }


  export type CastiingTotalBalanceAvgAggregateInputType = {
    id?: true
    total_item_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    total_wastage?: true
    item_entry?: true
  }

  export type CastiingTotalBalanceSumAggregateInputType = {
    id?: true
    total_item_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    total_wastage?: true
    item_entry?: true
  }

  export type CastiingTotalBalanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    total_item_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    total_wastage?: true
    item_entry?: true
  }

  export type CastiingTotalBalanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    total_item_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    total_wastage?: true
    item_entry?: true
  }

  export type CastiingTotalBalanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    total_item_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    total_wastage?: true
    item_entry?: true
    _all?: true
  }

  export type CastiingTotalBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastiingTotalBalance to aggregate.
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastiingTotalBalances to fetch.
     */
    orderBy?: CastiingTotalBalanceOrderByWithRelationInput | CastiingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CastiingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastiingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastiingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CastiingTotalBalances
    **/
    _count?: true | CastiingTotalBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CastiingTotalBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CastiingTotalBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CastiingTotalBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CastiingTotalBalanceMaxAggregateInputType
  }

  export type GetCastiingTotalBalanceAggregateType<T extends CastiingTotalBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCastiingTotalBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCastiingTotalBalance[P]>
      : GetScalarType<T[P], AggregateCastiingTotalBalance[P]>
  }




  export type CastiingTotalBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CastiingTotalBalanceWhereInput
    orderBy?: CastiingTotalBalanceOrderByWithAggregationInput | CastiingTotalBalanceOrderByWithAggregationInput[]
    by: CastiingTotalBalanceScalarFieldEnum[] | CastiingTotalBalanceScalarFieldEnum
    having?: CastiingTotalBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CastiingTotalBalanceCountAggregateInputType | true
    _avg?: CastiingTotalBalanceAvgAggregateInputType
    _sum?: CastiingTotalBalanceSumAggregateInputType
    _min?: CastiingTotalBalanceMinAggregateInputType
    _max?: CastiingTotalBalanceMaxAggregateInputType
  }

  export type CastiingTotalBalanceGroupByOutputType = {
    id: number
    createdAt: Date
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight: number | null
    total_wastage: number
    item_entry: number
    _count: CastiingTotalBalanceCountAggregateOutputType | null
    _avg: CastiingTotalBalanceAvgAggregateOutputType | null
    _sum: CastiingTotalBalanceSumAggregateOutputType | null
    _min: CastiingTotalBalanceMinAggregateOutputType | null
    _max: CastiingTotalBalanceMaxAggregateOutputType | null
  }

  type GetCastiingTotalBalanceGroupByPayload<T extends CastiingTotalBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CastiingTotalBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CastiingTotalBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CastiingTotalBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], CastiingTotalBalanceGroupByOutputType[P]>
        }
      >
    >


  export type CastiingTotalBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    total_item_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    total_wastage?: boolean
    item_entry?: boolean
    item_entry_id?: boolean | CastingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["castiingTotalBalance"]>



  export type CastiingTotalBalanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    total_item_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    total_wastage?: boolean
    item_entry?: boolean
  }

  export type CastiingTotalBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "total_item_weight" | "current_balance_weight" | "total_scrap_weight" | "total_wastage" | "item_entry", ExtArgs["result"]["castiingTotalBalance"]>
  export type CastiingTotalBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item_entry_id?: boolean | CastingEntryDefaultArgs<ExtArgs>
  }

  export type $CastiingTotalBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CastiingTotalBalance"
    objects: {
      item_entry_id: Prisma.$CastingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      total_item_weight: number
      current_balance_weight: number
      total_scrap_weight: number | null
      total_wastage: number
      item_entry: number
    }, ExtArgs["result"]["castiingTotalBalance"]>
    composites: {}
  }

  type CastiingTotalBalanceGetPayload<S extends boolean | null | undefined | CastiingTotalBalanceDefaultArgs> = $Result.GetResult<Prisma.$CastiingTotalBalancePayload, S>

  type CastiingTotalBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CastiingTotalBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CastiingTotalBalanceCountAggregateInputType | true
    }

  export interface CastiingTotalBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CastiingTotalBalance'], meta: { name: 'CastiingTotalBalance' } }
    /**
     * Find zero or one CastiingTotalBalance that matches the filter.
     * @param {CastiingTotalBalanceFindUniqueArgs} args - Arguments to find a CastiingTotalBalance
     * @example
     * // Get one CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CastiingTotalBalanceFindUniqueArgs>(args: SelectSubset<T, CastiingTotalBalanceFindUniqueArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CastiingTotalBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CastiingTotalBalanceFindUniqueOrThrowArgs} args - Arguments to find a CastiingTotalBalance
     * @example
     * // Get one CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CastiingTotalBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, CastiingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastiingTotalBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceFindFirstArgs} args - Arguments to find a CastiingTotalBalance
     * @example
     * // Get one CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CastiingTotalBalanceFindFirstArgs>(args?: SelectSubset<T, CastiingTotalBalanceFindFirstArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CastiingTotalBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceFindFirstOrThrowArgs} args - Arguments to find a CastiingTotalBalance
     * @example
     * // Get one CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CastiingTotalBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, CastiingTotalBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CastiingTotalBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CastiingTotalBalances
     * const castiingTotalBalances = await prisma.castiingTotalBalance.findMany()
     * 
     * // Get first 10 CastiingTotalBalances
     * const castiingTotalBalances = await prisma.castiingTotalBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const castiingTotalBalanceWithIdOnly = await prisma.castiingTotalBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CastiingTotalBalanceFindManyArgs>(args?: SelectSubset<T, CastiingTotalBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CastiingTotalBalance.
     * @param {CastiingTotalBalanceCreateArgs} args - Arguments to create a CastiingTotalBalance.
     * @example
     * // Create one CastiingTotalBalance
     * const CastiingTotalBalance = await prisma.castiingTotalBalance.create({
     *   data: {
     *     // ... data to create a CastiingTotalBalance
     *   }
     * })
     * 
     */
    create<T extends CastiingTotalBalanceCreateArgs>(args: SelectSubset<T, CastiingTotalBalanceCreateArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CastiingTotalBalances.
     * @param {CastiingTotalBalanceCreateManyArgs} args - Arguments to create many CastiingTotalBalances.
     * @example
     * // Create many CastiingTotalBalances
     * const castiingTotalBalance = await prisma.castiingTotalBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CastiingTotalBalanceCreateManyArgs>(args?: SelectSubset<T, CastiingTotalBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CastiingTotalBalance.
     * @param {CastiingTotalBalanceDeleteArgs} args - Arguments to delete one CastiingTotalBalance.
     * @example
     * // Delete one CastiingTotalBalance
     * const CastiingTotalBalance = await prisma.castiingTotalBalance.delete({
     *   where: {
     *     // ... filter to delete one CastiingTotalBalance
     *   }
     * })
     * 
     */
    delete<T extends CastiingTotalBalanceDeleteArgs>(args: SelectSubset<T, CastiingTotalBalanceDeleteArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CastiingTotalBalance.
     * @param {CastiingTotalBalanceUpdateArgs} args - Arguments to update one CastiingTotalBalance.
     * @example
     * // Update one CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CastiingTotalBalanceUpdateArgs>(args: SelectSubset<T, CastiingTotalBalanceUpdateArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CastiingTotalBalances.
     * @param {CastiingTotalBalanceDeleteManyArgs} args - Arguments to filter CastiingTotalBalances to delete.
     * @example
     * // Delete a few CastiingTotalBalances
     * const { count } = await prisma.castiingTotalBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CastiingTotalBalanceDeleteManyArgs>(args?: SelectSubset<T, CastiingTotalBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CastiingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CastiingTotalBalances
     * const castiingTotalBalance = await prisma.castiingTotalBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CastiingTotalBalanceUpdateManyArgs>(args: SelectSubset<T, CastiingTotalBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CastiingTotalBalance.
     * @param {CastiingTotalBalanceUpsertArgs} args - Arguments to update or create a CastiingTotalBalance.
     * @example
     * // Update or create a CastiingTotalBalance
     * const castiingTotalBalance = await prisma.castiingTotalBalance.upsert({
     *   create: {
     *     // ... data to create a CastiingTotalBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CastiingTotalBalance we want to update
     *   }
     * })
     */
    upsert<T extends CastiingTotalBalanceUpsertArgs>(args: SelectSubset<T, CastiingTotalBalanceUpsertArgs<ExtArgs>>): Prisma__CastiingTotalBalanceClient<$Result.GetResult<Prisma.$CastiingTotalBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CastiingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceCountArgs} args - Arguments to filter CastiingTotalBalances to count.
     * @example
     * // Count the number of CastiingTotalBalances
     * const count = await prisma.castiingTotalBalance.count({
     *   where: {
     *     // ... the filter for the CastiingTotalBalances we want to count
     *   }
     * })
    **/
    count<T extends CastiingTotalBalanceCountArgs>(
      args?: Subset<T, CastiingTotalBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CastiingTotalBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CastiingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CastiingTotalBalanceAggregateArgs>(args: Subset<T, CastiingTotalBalanceAggregateArgs>): Prisma.PrismaPromise<GetCastiingTotalBalanceAggregateType<T>>

    /**
     * Group by CastiingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CastiingTotalBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CastiingTotalBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CastiingTotalBalanceGroupByArgs['orderBy'] }
        : { orderBy?: CastiingTotalBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CastiingTotalBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCastiingTotalBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CastiingTotalBalance model
   */
  readonly fields: CastiingTotalBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CastiingTotalBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CastiingTotalBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item_entry_id<T extends CastingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingEntryDefaultArgs<ExtArgs>>): Prisma__CastingEntryClient<$Result.GetResult<Prisma.$CastingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CastiingTotalBalance model
   */
  interface CastiingTotalBalanceFieldRefs {
    readonly id: FieldRef<"CastiingTotalBalance", 'Int'>
    readonly createdAt: FieldRef<"CastiingTotalBalance", 'DateTime'>
    readonly total_item_weight: FieldRef<"CastiingTotalBalance", 'Float'>
    readonly current_balance_weight: FieldRef<"CastiingTotalBalance", 'Float'>
    readonly total_scrap_weight: FieldRef<"CastiingTotalBalance", 'Float'>
    readonly total_wastage: FieldRef<"CastiingTotalBalance", 'Float'>
    readonly item_entry: FieldRef<"CastiingTotalBalance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CastiingTotalBalance findUnique
   */
  export type CastiingTotalBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CastiingTotalBalance to fetch.
     */
    where: CastiingTotalBalanceWhereUniqueInput
  }

  /**
   * CastiingTotalBalance findUniqueOrThrow
   */
  export type CastiingTotalBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CastiingTotalBalance to fetch.
     */
    where: CastiingTotalBalanceWhereUniqueInput
  }

  /**
   * CastiingTotalBalance findFirst
   */
  export type CastiingTotalBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CastiingTotalBalance to fetch.
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastiingTotalBalances to fetch.
     */
    orderBy?: CastiingTotalBalanceOrderByWithRelationInput | CastiingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastiingTotalBalances.
     */
    cursor?: CastiingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastiingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastiingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastiingTotalBalances.
     */
    distinct?: CastiingTotalBalanceScalarFieldEnum | CastiingTotalBalanceScalarFieldEnum[]
  }

  /**
   * CastiingTotalBalance findFirstOrThrow
   */
  export type CastiingTotalBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CastiingTotalBalance to fetch.
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastiingTotalBalances to fetch.
     */
    orderBy?: CastiingTotalBalanceOrderByWithRelationInput | CastiingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CastiingTotalBalances.
     */
    cursor?: CastiingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastiingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastiingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CastiingTotalBalances.
     */
    distinct?: CastiingTotalBalanceScalarFieldEnum | CastiingTotalBalanceScalarFieldEnum[]
  }

  /**
   * CastiingTotalBalance findMany
   */
  export type CastiingTotalBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which CastiingTotalBalances to fetch.
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CastiingTotalBalances to fetch.
     */
    orderBy?: CastiingTotalBalanceOrderByWithRelationInput | CastiingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CastiingTotalBalances.
     */
    cursor?: CastiingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CastiingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CastiingTotalBalances.
     */
    skip?: number
    distinct?: CastiingTotalBalanceScalarFieldEnum | CastiingTotalBalanceScalarFieldEnum[]
  }

  /**
   * CastiingTotalBalance create
   */
  export type CastiingTotalBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a CastiingTotalBalance.
     */
    data: XOR<CastiingTotalBalanceCreateInput, CastiingTotalBalanceUncheckedCreateInput>
  }

  /**
   * CastiingTotalBalance createMany
   */
  export type CastiingTotalBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CastiingTotalBalances.
     */
    data: CastiingTotalBalanceCreateManyInput | CastiingTotalBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CastiingTotalBalance update
   */
  export type CastiingTotalBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a CastiingTotalBalance.
     */
    data: XOR<CastiingTotalBalanceUpdateInput, CastiingTotalBalanceUncheckedUpdateInput>
    /**
     * Choose, which CastiingTotalBalance to update.
     */
    where: CastiingTotalBalanceWhereUniqueInput
  }

  /**
   * CastiingTotalBalance updateMany
   */
  export type CastiingTotalBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CastiingTotalBalances.
     */
    data: XOR<CastiingTotalBalanceUpdateManyMutationInput, CastiingTotalBalanceUncheckedUpdateManyInput>
    /**
     * Filter which CastiingTotalBalances to update
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * Limit how many CastiingTotalBalances to update.
     */
    limit?: number
  }

  /**
   * CastiingTotalBalance upsert
   */
  export type CastiingTotalBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the CastiingTotalBalance to update in case it exists.
     */
    where: CastiingTotalBalanceWhereUniqueInput
    /**
     * In case the CastiingTotalBalance found by the `where` argument doesn't exist, create a new CastiingTotalBalance with this data.
     */
    create: XOR<CastiingTotalBalanceCreateInput, CastiingTotalBalanceUncheckedCreateInput>
    /**
     * In case the CastiingTotalBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CastiingTotalBalanceUpdateInput, CastiingTotalBalanceUncheckedUpdateInput>
  }

  /**
   * CastiingTotalBalance delete
   */
  export type CastiingTotalBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter which CastiingTotalBalance to delete.
     */
    where: CastiingTotalBalanceWhereUniqueInput
  }

  /**
   * CastiingTotalBalance deleteMany
   */
  export type CastiingTotalBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CastiingTotalBalances to delete
     */
    where?: CastiingTotalBalanceWhereInput
    /**
     * Limit how many CastiingTotalBalances to delete.
     */
    limit?: number
  }

  /**
   * CastiingTotalBalance without action
   */
  export type CastiingTotalBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastiingTotalBalance
     */
    select?: CastiingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastiingTotalBalance
     */
    omit?: CastiingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastiingTotalBalanceInclude<ExtArgs> | null
  }


  /**
   * Model LotInfo
   */

  export type AggregateLotInfo = {
    _count: LotInfoCountAggregateOutputType | null
    _avg: LotInfoAvgAggregateOutputType | null
    _sum: LotInfoSumAggregateOutputType | null
    _min: LotInfoMinAggregateOutputType | null
    _max: LotInfoMaxAggregateOutputType | null
  }

  export type LotInfoAvgAggregateOutputType = {
    id: number | null
    lotNumber: number | null
    filing_customer_id: number | null
    setting_customer_id: number | null
    buffing_customer_id: number | null
  }

  export type LotInfoSumAggregateOutputType = {
    id: number | null
    lotNumber: number | null
    filing_customer_id: number | null
    setting_customer_id: number | null
    buffing_customer_id: number | null
  }

  export type LotInfoMinAggregateOutputType = {
    id: number | null
    lotNumber: number | null
    filing_customer_id: number | null
    setting_customer_id: number | null
    buffing_customer_id: number | null
    IsActive: boolean | null
  }

  export type LotInfoMaxAggregateOutputType = {
    id: number | null
    lotNumber: number | null
    filing_customer_id: number | null
    setting_customer_id: number | null
    buffing_customer_id: number | null
    IsActive: boolean | null
  }

  export type LotInfoCountAggregateOutputType = {
    id: number
    lotNumber: number
    filing_customer_id: number
    setting_customer_id: number
    buffing_customer_id: number
    IsActive: number
    _all: number
  }


  export type LotInfoAvgAggregateInputType = {
    id?: true
    lotNumber?: true
    filing_customer_id?: true
    setting_customer_id?: true
    buffing_customer_id?: true
  }

  export type LotInfoSumAggregateInputType = {
    id?: true
    lotNumber?: true
    filing_customer_id?: true
    setting_customer_id?: true
    buffing_customer_id?: true
  }

  export type LotInfoMinAggregateInputType = {
    id?: true
    lotNumber?: true
    filing_customer_id?: true
    setting_customer_id?: true
    buffing_customer_id?: true
    IsActive?: true
  }

  export type LotInfoMaxAggregateInputType = {
    id?: true
    lotNumber?: true
    filing_customer_id?: true
    setting_customer_id?: true
    buffing_customer_id?: true
    IsActive?: true
  }

  export type LotInfoCountAggregateInputType = {
    id?: true
    lotNumber?: true
    filing_customer_id?: true
    setting_customer_id?: true
    buffing_customer_id?: true
    IsActive?: true
    _all?: true
  }

  export type LotInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotInfo to aggregate.
     */
    where?: LotInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotInfos to fetch.
     */
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotInfos
    **/
    _count?: true | LotInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotInfoMaxAggregateInputType
  }

  export type GetLotInfoAggregateType<T extends LotInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateLotInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotInfo[P]>
      : GetScalarType<T[P], AggregateLotInfo[P]>
  }




  export type LotInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotInfoWhereInput
    orderBy?: LotInfoOrderByWithAggregationInput | LotInfoOrderByWithAggregationInput[]
    by: LotInfoScalarFieldEnum[] | LotInfoScalarFieldEnum
    having?: LotInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotInfoCountAggregateInputType | true
    _avg?: LotInfoAvgAggregateInputType
    _sum?: LotInfoSumAggregateInputType
    _min?: LotInfoMinAggregateInputType
    _max?: LotInfoMaxAggregateInputType
  }

  export type LotInfoGroupByOutputType = {
    id: number
    lotNumber: number
    filing_customer_id: number | null
    setting_customer_id: number | null
    buffing_customer_id: number | null
    IsActive: boolean
    _count: LotInfoCountAggregateOutputType | null
    _avg: LotInfoAvgAggregateOutputType | null
    _sum: LotInfoSumAggregateOutputType | null
    _min: LotInfoMinAggregateOutputType | null
    _max: LotInfoMaxAggregateOutputType | null
  }

  type GetLotInfoGroupByPayload<T extends LotInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotInfoGroupByOutputType[P]>
            : GetScalarType<T[P], LotInfoGroupByOutputType[P]>
        }
      >
    >


  export type LotInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotNumber?: boolean
    filing_customer_id?: boolean
    setting_customer_id?: boolean
    buffing_customer_id?: boolean
    IsActive?: boolean
    filingCustomerId?: boolean | LotInfo$filingCustomerIdArgs<ExtArgs>
    settingCustomerId?: boolean | LotInfo$settingCustomerIdArgs<ExtArgs>
    buffingCustomerId?: boolean | LotInfo$buffingCustomerIdArgs<ExtArgs>
    filingMapper?: boolean | LotInfo$filingMapperArgs<ExtArgs>
    settingMapper?: boolean | LotInfo$settingMapperArgs<ExtArgs>
    buffingMapper?: boolean | LotInfo$buffingMapperArgs<ExtArgs>
    filingWastages?: boolean | LotInfo$filingWastagesArgs<ExtArgs>
    buffingWastages?: boolean | LotInfo$buffingWastagesArgs<ExtArgs>
    _count?: boolean | LotInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotInfo"]>



  export type LotInfoSelectScalar = {
    id?: boolean
    lotNumber?: boolean
    filing_customer_id?: boolean
    setting_customer_id?: boolean
    buffing_customer_id?: boolean
    IsActive?: boolean
  }

  export type LotInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lotNumber" | "filing_customer_id" | "setting_customer_id" | "buffing_customer_id" | "IsActive", ExtArgs["result"]["lotInfo"]>
  export type LotInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingCustomerId?: boolean | LotInfo$filingCustomerIdArgs<ExtArgs>
    settingCustomerId?: boolean | LotInfo$settingCustomerIdArgs<ExtArgs>
    buffingCustomerId?: boolean | LotInfo$buffingCustomerIdArgs<ExtArgs>
    filingMapper?: boolean | LotInfo$filingMapperArgs<ExtArgs>
    settingMapper?: boolean | LotInfo$settingMapperArgs<ExtArgs>
    buffingMapper?: boolean | LotInfo$buffingMapperArgs<ExtArgs>
    filingWastages?: boolean | LotInfo$filingWastagesArgs<ExtArgs>
    buffingWastages?: boolean | LotInfo$buffingWastagesArgs<ExtArgs>
    _count?: boolean | LotInfoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LotInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotInfo"
    objects: {
      filingCustomerId: Prisma.$AddFilingPayload<ExtArgs> | null
      settingCustomerId: Prisma.$AddSettingPayload<ExtArgs> | null
      buffingCustomerId: Prisma.$AddBuffingPayload<ExtArgs> | null
      filingMapper: Prisma.$LotFilingMapperPayload<ExtArgs>[]
      settingMapper: Prisma.$LotSettingMapperPayload<ExtArgs>[]
      buffingMapper: Prisma.$LotBuffingMapperPayload<ExtArgs>[]
      filingWastages: Prisma.$FilingWastagePayload<ExtArgs>[]
      buffingWastages: Prisma.$BuffingWastagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lotNumber: number
      filing_customer_id: number | null
      setting_customer_id: number | null
      buffing_customer_id: number | null
      IsActive: boolean
    }, ExtArgs["result"]["lotInfo"]>
    composites: {}
  }

  type LotInfoGetPayload<S extends boolean | null | undefined | LotInfoDefaultArgs> = $Result.GetResult<Prisma.$LotInfoPayload, S>

  type LotInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LotInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LotInfoCountAggregateInputType | true
    }

  export interface LotInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotInfo'], meta: { name: 'LotInfo' } }
    /**
     * Find zero or one LotInfo that matches the filter.
     * @param {LotInfoFindUniqueArgs} args - Arguments to find a LotInfo
     * @example
     * // Get one LotInfo
     * const lotInfo = await prisma.lotInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotInfoFindUniqueArgs>(args: SelectSubset<T, LotInfoFindUniqueArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LotInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LotInfoFindUniqueOrThrowArgs} args - Arguments to find a LotInfo
     * @example
     * // Get one LotInfo
     * const lotInfo = await prisma.lotInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, LotInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoFindFirstArgs} args - Arguments to find a LotInfo
     * @example
     * // Get one LotInfo
     * const lotInfo = await prisma.lotInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotInfoFindFirstArgs>(args?: SelectSubset<T, LotInfoFindFirstArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoFindFirstOrThrowArgs} args - Arguments to find a LotInfo
     * @example
     * // Get one LotInfo
     * const lotInfo = await prisma.lotInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, LotInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LotInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotInfos
     * const lotInfos = await prisma.lotInfo.findMany()
     * 
     * // Get first 10 LotInfos
     * const lotInfos = await prisma.lotInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotInfoWithIdOnly = await prisma.lotInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotInfoFindManyArgs>(args?: SelectSubset<T, LotInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LotInfo.
     * @param {LotInfoCreateArgs} args - Arguments to create a LotInfo.
     * @example
     * // Create one LotInfo
     * const LotInfo = await prisma.lotInfo.create({
     *   data: {
     *     // ... data to create a LotInfo
     *   }
     * })
     * 
     */
    create<T extends LotInfoCreateArgs>(args: SelectSubset<T, LotInfoCreateArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LotInfos.
     * @param {LotInfoCreateManyArgs} args - Arguments to create many LotInfos.
     * @example
     * // Create many LotInfos
     * const lotInfo = await prisma.lotInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotInfoCreateManyArgs>(args?: SelectSubset<T, LotInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LotInfo.
     * @param {LotInfoDeleteArgs} args - Arguments to delete one LotInfo.
     * @example
     * // Delete one LotInfo
     * const LotInfo = await prisma.lotInfo.delete({
     *   where: {
     *     // ... filter to delete one LotInfo
     *   }
     * })
     * 
     */
    delete<T extends LotInfoDeleteArgs>(args: SelectSubset<T, LotInfoDeleteArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LotInfo.
     * @param {LotInfoUpdateArgs} args - Arguments to update one LotInfo.
     * @example
     * // Update one LotInfo
     * const lotInfo = await prisma.lotInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotInfoUpdateArgs>(args: SelectSubset<T, LotInfoUpdateArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LotInfos.
     * @param {LotInfoDeleteManyArgs} args - Arguments to filter LotInfos to delete.
     * @example
     * // Delete a few LotInfos
     * const { count } = await prisma.lotInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotInfoDeleteManyArgs>(args?: SelectSubset<T, LotInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotInfos
     * const lotInfo = await prisma.lotInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotInfoUpdateManyArgs>(args: SelectSubset<T, LotInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotInfo.
     * @param {LotInfoUpsertArgs} args - Arguments to update or create a LotInfo.
     * @example
     * // Update or create a LotInfo
     * const lotInfo = await prisma.lotInfo.upsert({
     *   create: {
     *     // ... data to create a LotInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotInfo we want to update
     *   }
     * })
     */
    upsert<T extends LotInfoUpsertArgs>(args: SelectSubset<T, LotInfoUpsertArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LotInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoCountArgs} args - Arguments to filter LotInfos to count.
     * @example
     * // Count the number of LotInfos
     * const count = await prisma.lotInfo.count({
     *   where: {
     *     // ... the filter for the LotInfos we want to count
     *   }
     * })
    **/
    count<T extends LotInfoCountArgs>(
      args?: Subset<T, LotInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotInfoAggregateArgs>(args: Subset<T, LotInfoAggregateArgs>): Prisma.PrismaPromise<GetLotInfoAggregateType<T>>

    /**
     * Group by LotInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotInfoGroupByArgs['orderBy'] }
        : { orderBy?: LotInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotInfo model
   */
  readonly fields: LotInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filingCustomerId<T extends LotInfo$filingCustomerIdArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$filingCustomerIdArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settingCustomerId<T extends LotInfo$settingCustomerIdArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$settingCustomerIdArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buffingCustomerId<T extends LotInfo$buffingCustomerIdArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$buffingCustomerIdArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    filingMapper<T extends LotInfo$filingMapperArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$filingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingMapper<T extends LotInfo$settingMapperArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$settingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingMapper<T extends LotInfo$buffingMapperArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$buffingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filingWastages<T extends LotInfo$filingWastagesArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$filingWastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingWastages<T extends LotInfo$buffingWastagesArgs<ExtArgs> = {}>(args?: Subset<T, LotInfo$buffingWastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotInfo model
   */
  interface LotInfoFieldRefs {
    readonly id: FieldRef<"LotInfo", 'Int'>
    readonly lotNumber: FieldRef<"LotInfo", 'Int'>
    readonly filing_customer_id: FieldRef<"LotInfo", 'Int'>
    readonly setting_customer_id: FieldRef<"LotInfo", 'Int'>
    readonly buffing_customer_id: FieldRef<"LotInfo", 'Int'>
    readonly IsActive: FieldRef<"LotInfo", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LotInfo findUnique
   */
  export type LotInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter, which LotInfo to fetch.
     */
    where: LotInfoWhereUniqueInput
  }

  /**
   * LotInfo findUniqueOrThrow
   */
  export type LotInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter, which LotInfo to fetch.
     */
    where: LotInfoWhereUniqueInput
  }

  /**
   * LotInfo findFirst
   */
  export type LotInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter, which LotInfo to fetch.
     */
    where?: LotInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotInfos to fetch.
     */
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotInfos.
     */
    cursor?: LotInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotInfos.
     */
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * LotInfo findFirstOrThrow
   */
  export type LotInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter, which LotInfo to fetch.
     */
    where?: LotInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotInfos to fetch.
     */
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotInfos.
     */
    cursor?: LotInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotInfos.
     */
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * LotInfo findMany
   */
  export type LotInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter, which LotInfos to fetch.
     */
    where?: LotInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotInfos to fetch.
     */
    orderBy?: LotInfoOrderByWithRelationInput | LotInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotInfos.
     */
    cursor?: LotInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotInfos.
     */
    skip?: number
    distinct?: LotInfoScalarFieldEnum | LotInfoScalarFieldEnum[]
  }

  /**
   * LotInfo create
   */
  export type LotInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a LotInfo.
     */
    data: XOR<LotInfoCreateInput, LotInfoUncheckedCreateInput>
  }

  /**
   * LotInfo createMany
   */
  export type LotInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotInfos.
     */
    data: LotInfoCreateManyInput | LotInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotInfo update
   */
  export type LotInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a LotInfo.
     */
    data: XOR<LotInfoUpdateInput, LotInfoUncheckedUpdateInput>
    /**
     * Choose, which LotInfo to update.
     */
    where: LotInfoWhereUniqueInput
  }

  /**
   * LotInfo updateMany
   */
  export type LotInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotInfos.
     */
    data: XOR<LotInfoUpdateManyMutationInput, LotInfoUncheckedUpdateManyInput>
    /**
     * Filter which LotInfos to update
     */
    where?: LotInfoWhereInput
    /**
     * Limit how many LotInfos to update.
     */
    limit?: number
  }

  /**
   * LotInfo upsert
   */
  export type LotInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the LotInfo to update in case it exists.
     */
    where: LotInfoWhereUniqueInput
    /**
     * In case the LotInfo found by the `where` argument doesn't exist, create a new LotInfo with this data.
     */
    create: XOR<LotInfoCreateInput, LotInfoUncheckedCreateInput>
    /**
     * In case the LotInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotInfoUpdateInput, LotInfoUncheckedUpdateInput>
  }

  /**
   * LotInfo delete
   */
  export type LotInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    /**
     * Filter which LotInfo to delete.
     */
    where: LotInfoWhereUniqueInput
  }

  /**
   * LotInfo deleteMany
   */
  export type LotInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotInfos to delete
     */
    where?: LotInfoWhereInput
    /**
     * Limit how many LotInfos to delete.
     */
    limit?: number
  }

  /**
   * LotInfo.filingCustomerId
   */
  export type LotInfo$filingCustomerIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    where?: AddFilingWhereInput
  }

  /**
   * LotInfo.settingCustomerId
   */
  export type LotInfo$settingCustomerIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddSetting
     */
    select?: AddSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddSetting
     */
    omit?: AddSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddSettingInclude<ExtArgs> | null
    where?: AddSettingWhereInput
  }

  /**
   * LotInfo.buffingCustomerId
   */
  export type LotInfo$buffingCustomerIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    where?: AddBuffingWhereInput
  }

  /**
   * LotInfo.filingMapper
   */
  export type LotInfo$filingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    where?: LotFilingMapperWhereInput
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    cursor?: LotFilingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * LotInfo.settingMapper
   */
  export type LotInfo$settingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    where?: LotSettingMapperWhereInput
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    cursor?: LotSettingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * LotInfo.buffingMapper
   */
  export type LotInfo$buffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    cursor?: LotBuffingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * LotInfo.filingWastages
   */
  export type LotInfo$filingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    where?: FilingWastageWhereInput
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    cursor?: FilingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * LotInfo.buffingWastages
   */
  export type LotInfo$buffingWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    where?: BuffingWastageWhereInput
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    cursor?: BuffingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * LotInfo without action
   */
  export type LotInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
  }


  /**
   * Model FilingEntry
   */

  export type AggregateFilingEntry = {
    _count: FilingEntryCountAggregateOutputType | null
    _avg: FilingEntryAvgAggregateOutputType | null
    _sum: FilingEntrySumAggregateOutputType | null
    _min: FilingEntryMinAggregateOutputType | null
    _max: FilingEntryMaxAggregateOutputType | null
  }

  export type FilingEntryAvgAggregateOutputType = {
    id: number | null
    filing_person_id: number | null
    casting_item_id: number | null
  }

  export type FilingEntrySumAggregateOutputType = {
    id: number | null
    filing_person_id: number | null
    casting_item_id: number | null
  }

  export type FilingEntryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    filing_person_id: number | null
    casting_item_id: number | null
  }

  export type FilingEntryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    filing_person_id: number | null
    casting_item_id: number | null
  }

  export type FilingEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    filing_person_id: number
    casting_item_id: number
    _all: number
  }


  export type FilingEntryAvgAggregateInputType = {
    id?: true
    filing_person_id?: true
    casting_item_id?: true
  }

  export type FilingEntrySumAggregateInputType = {
    id?: true
    filing_person_id?: true
    casting_item_id?: true
  }

  export type FilingEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    filing_person_id?: true
    casting_item_id?: true
  }

  export type FilingEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    filing_person_id?: true
    casting_item_id?: true
  }

  export type FilingEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    filing_person_id?: true
    casting_item_id?: true
    _all?: true
  }

  export type FilingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingEntry to aggregate.
     */
    where?: FilingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingEntries to fetch.
     */
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilingEntries
    **/
    _count?: true | FilingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilingEntryMaxAggregateInputType
  }

  export type GetFilingEntryAggregateType<T extends FilingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateFilingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilingEntry[P]>
      : GetScalarType<T[P], AggregateFilingEntry[P]>
  }




  export type FilingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingEntryWhereInput
    orderBy?: FilingEntryOrderByWithAggregationInput | FilingEntryOrderByWithAggregationInput[]
    by: FilingEntryScalarFieldEnum[] | FilingEntryScalarFieldEnum
    having?: FilingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilingEntryCountAggregateInputType | true
    _avg?: FilingEntryAvgAggregateInputType
    _sum?: FilingEntrySumAggregateInputType
    _min?: FilingEntryMinAggregateInputType
    _max?: FilingEntryMaxAggregateInputType
  }

  export type FilingEntryGroupByOutputType = {
    id: number
    createdAt: Date
    filing_person_id: number
    casting_item_id: number
    _count: FilingEntryCountAggregateOutputType | null
    _avg: FilingEntryAvgAggregateOutputType | null
    _sum: FilingEntrySumAggregateOutputType | null
    _min: FilingEntryMinAggregateOutputType | null
    _max: FilingEntryMaxAggregateOutputType | null
  }

  type GetFilingEntryGroupByPayload<T extends FilingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], FilingEntryGroupByOutputType[P]>
        }
      >
    >


  export type FilingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    filing_person_id?: boolean
    casting_item_id?: boolean
    filing_person?: boolean | AddFilingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filingItems?: boolean | FilingEntry$filingItemsArgs<ExtArgs>
    filingTotalBalance?: boolean | FilingEntry$filingTotalBalanceArgs<ExtArgs>
    LotFilingMapper?: boolean | FilingEntry$LotFilingMapperArgs<ExtArgs>
    _count?: boolean | FilingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filingEntry"]>



  export type FilingEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    filing_person_id?: boolean
    casting_item_id?: boolean
  }

  export type FilingEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "filing_person_id" | "casting_item_id", ExtArgs["result"]["filingEntry"]>
  export type FilingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filing_person?: boolean | AddFilingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filingItems?: boolean | FilingEntry$filingItemsArgs<ExtArgs>
    filingTotalBalance?: boolean | FilingEntry$filingTotalBalanceArgs<ExtArgs>
    LotFilingMapper?: boolean | FilingEntry$LotFilingMapperArgs<ExtArgs>
    _count?: boolean | FilingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilingEntry"
    objects: {
      filing_person: Prisma.$AddFilingPayload<ExtArgs>
      castingItem: Prisma.$CastingItemsPayload<ExtArgs>
      filingItems: Prisma.$FilingItemsPayload<ExtArgs>[]
      filingTotalBalance: Prisma.$FilingTotalBalancePayload<ExtArgs>[]
      LotFilingMapper: Prisma.$LotFilingMapperPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      filing_person_id: number
      casting_item_id: number
    }, ExtArgs["result"]["filingEntry"]>
    composites: {}
  }

  type FilingEntryGetPayload<S extends boolean | null | undefined | FilingEntryDefaultArgs> = $Result.GetResult<Prisma.$FilingEntryPayload, S>

  type FilingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilingEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilingEntryCountAggregateInputType | true
    }

  export interface FilingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilingEntry'], meta: { name: 'FilingEntry' } }
    /**
     * Find zero or one FilingEntry that matches the filter.
     * @param {FilingEntryFindUniqueArgs} args - Arguments to find a FilingEntry
     * @example
     * // Get one FilingEntry
     * const filingEntry = await prisma.filingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilingEntryFindUniqueArgs>(args: SelectSubset<T, FilingEntryFindUniqueArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilingEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilingEntryFindUniqueOrThrowArgs} args - Arguments to find a FilingEntry
     * @example
     * // Get one FilingEntry
     * const filingEntry = await prisma.filingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, FilingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryFindFirstArgs} args - Arguments to find a FilingEntry
     * @example
     * // Get one FilingEntry
     * const filingEntry = await prisma.filingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilingEntryFindFirstArgs>(args?: SelectSubset<T, FilingEntryFindFirstArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryFindFirstOrThrowArgs} args - Arguments to find a FilingEntry
     * @example
     * // Get one FilingEntry
     * const filingEntry = await prisma.filingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, FilingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilingEntries
     * const filingEntries = await prisma.filingEntry.findMany()
     * 
     * // Get first 10 FilingEntries
     * const filingEntries = await prisma.filingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filingEntryWithIdOnly = await prisma.filingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilingEntryFindManyArgs>(args?: SelectSubset<T, FilingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilingEntry.
     * @param {FilingEntryCreateArgs} args - Arguments to create a FilingEntry.
     * @example
     * // Create one FilingEntry
     * const FilingEntry = await prisma.filingEntry.create({
     *   data: {
     *     // ... data to create a FilingEntry
     *   }
     * })
     * 
     */
    create<T extends FilingEntryCreateArgs>(args: SelectSubset<T, FilingEntryCreateArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilingEntries.
     * @param {FilingEntryCreateManyArgs} args - Arguments to create many FilingEntries.
     * @example
     * // Create many FilingEntries
     * const filingEntry = await prisma.filingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilingEntryCreateManyArgs>(args?: SelectSubset<T, FilingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FilingEntry.
     * @param {FilingEntryDeleteArgs} args - Arguments to delete one FilingEntry.
     * @example
     * // Delete one FilingEntry
     * const FilingEntry = await prisma.filingEntry.delete({
     *   where: {
     *     // ... filter to delete one FilingEntry
     *   }
     * })
     * 
     */
    delete<T extends FilingEntryDeleteArgs>(args: SelectSubset<T, FilingEntryDeleteArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilingEntry.
     * @param {FilingEntryUpdateArgs} args - Arguments to update one FilingEntry.
     * @example
     * // Update one FilingEntry
     * const filingEntry = await prisma.filingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilingEntryUpdateArgs>(args: SelectSubset<T, FilingEntryUpdateArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilingEntries.
     * @param {FilingEntryDeleteManyArgs} args - Arguments to filter FilingEntries to delete.
     * @example
     * // Delete a few FilingEntries
     * const { count } = await prisma.filingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilingEntryDeleteManyArgs>(args?: SelectSubset<T, FilingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilingEntries
     * const filingEntry = await prisma.filingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilingEntryUpdateManyArgs>(args: SelectSubset<T, FilingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilingEntry.
     * @param {FilingEntryUpsertArgs} args - Arguments to update or create a FilingEntry.
     * @example
     * // Update or create a FilingEntry
     * const filingEntry = await prisma.filingEntry.upsert({
     *   create: {
     *     // ... data to create a FilingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilingEntry we want to update
     *   }
     * })
     */
    upsert<T extends FilingEntryUpsertArgs>(args: SelectSubset<T, FilingEntryUpsertArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryCountArgs} args - Arguments to filter FilingEntries to count.
     * @example
     * // Count the number of FilingEntries
     * const count = await prisma.filingEntry.count({
     *   where: {
     *     // ... the filter for the FilingEntries we want to count
     *   }
     * })
    **/
    count<T extends FilingEntryCountArgs>(
      args?: Subset<T, FilingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilingEntryAggregateArgs>(args: Subset<T, FilingEntryAggregateArgs>): Prisma.PrismaPromise<GetFilingEntryAggregateType<T>>

    /**
     * Group by FilingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilingEntryGroupByArgs['orderBy'] }
        : { orderBy?: FilingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilingEntry model
   */
  readonly fields: FilingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filing_person<T extends AddFilingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddFilingDefaultArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    castingItem<T extends CastingItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingItemsDefaultArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filingItems<T extends FilingEntry$filingItemsArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntry$filingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filingTotalBalance<T extends FilingEntry$filingTotalBalanceArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntry$filingTotalBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LotFilingMapper<T extends FilingEntry$LotFilingMapperArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntry$LotFilingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilingEntry model
   */
  interface FilingEntryFieldRefs {
    readonly id: FieldRef<"FilingEntry", 'Int'>
    readonly createdAt: FieldRef<"FilingEntry", 'DateTime'>
    readonly filing_person_id: FieldRef<"FilingEntry", 'Int'>
    readonly casting_item_id: FieldRef<"FilingEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilingEntry findUnique
   */
  export type FilingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilingEntry to fetch.
     */
    where: FilingEntryWhereUniqueInput
  }

  /**
   * FilingEntry findUniqueOrThrow
   */
  export type FilingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilingEntry to fetch.
     */
    where: FilingEntryWhereUniqueInput
  }

  /**
   * FilingEntry findFirst
   */
  export type FilingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilingEntry to fetch.
     */
    where?: FilingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingEntries to fetch.
     */
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingEntries.
     */
    cursor?: FilingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingEntries.
     */
    distinct?: FilingEntryScalarFieldEnum | FilingEntryScalarFieldEnum[]
  }

  /**
   * FilingEntry findFirstOrThrow
   */
  export type FilingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilingEntry to fetch.
     */
    where?: FilingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingEntries to fetch.
     */
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingEntries.
     */
    cursor?: FilingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingEntries.
     */
    distinct?: FilingEntryScalarFieldEnum | FilingEntryScalarFieldEnum[]
  }

  /**
   * FilingEntry findMany
   */
  export type FilingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter, which FilingEntries to fetch.
     */
    where?: FilingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingEntries to fetch.
     */
    orderBy?: FilingEntryOrderByWithRelationInput | FilingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilingEntries.
     */
    cursor?: FilingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingEntries.
     */
    skip?: number
    distinct?: FilingEntryScalarFieldEnum | FilingEntryScalarFieldEnum[]
  }

  /**
   * FilingEntry create
   */
  export type FilingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a FilingEntry.
     */
    data: XOR<FilingEntryCreateInput, FilingEntryUncheckedCreateInput>
  }

  /**
   * FilingEntry createMany
   */
  export type FilingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilingEntries.
     */
    data: FilingEntryCreateManyInput | FilingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilingEntry update
   */
  export type FilingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a FilingEntry.
     */
    data: XOR<FilingEntryUpdateInput, FilingEntryUncheckedUpdateInput>
    /**
     * Choose, which FilingEntry to update.
     */
    where: FilingEntryWhereUniqueInput
  }

  /**
   * FilingEntry updateMany
   */
  export type FilingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilingEntries.
     */
    data: XOR<FilingEntryUpdateManyMutationInput, FilingEntryUncheckedUpdateManyInput>
    /**
     * Filter which FilingEntries to update
     */
    where?: FilingEntryWhereInput
    /**
     * Limit how many FilingEntries to update.
     */
    limit?: number
  }

  /**
   * FilingEntry upsert
   */
  export type FilingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the FilingEntry to update in case it exists.
     */
    where: FilingEntryWhereUniqueInput
    /**
     * In case the FilingEntry found by the `where` argument doesn't exist, create a new FilingEntry with this data.
     */
    create: XOR<FilingEntryCreateInput, FilingEntryUncheckedCreateInput>
    /**
     * In case the FilingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilingEntryUpdateInput, FilingEntryUncheckedUpdateInput>
  }

  /**
   * FilingEntry delete
   */
  export type FilingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
    /**
     * Filter which FilingEntry to delete.
     */
    where: FilingEntryWhereUniqueInput
  }

  /**
   * FilingEntry deleteMany
   */
  export type FilingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingEntries to delete
     */
    where?: FilingEntryWhereInput
    /**
     * Limit how many FilingEntries to delete.
     */
    limit?: number
  }

  /**
   * FilingEntry.filingItems
   */
  export type FilingEntry$filingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * FilingEntry.filingTotalBalance
   */
  export type FilingEntry$filingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    where?: FilingTotalBalanceWhereInput
    orderBy?: FilingTotalBalanceOrderByWithRelationInput | FilingTotalBalanceOrderByWithRelationInput[]
    cursor?: FilingTotalBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingTotalBalanceScalarFieldEnum | FilingTotalBalanceScalarFieldEnum[]
  }

  /**
   * FilingEntry.LotFilingMapper
   */
  export type FilingEntry$LotFilingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    where?: LotFilingMapperWhereInput
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    cursor?: LotFilingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * FilingEntry without action
   */
  export type FilingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingEntry
     */
    select?: FilingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingEntry
     */
    omit?: FilingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingEntryInclude<ExtArgs> | null
  }


  /**
   * Model LotFilingMapper
   */

  export type AggregateLotFilingMapper = {
    _count: LotFilingMapperCountAggregateOutputType | null
    _avg: LotFilingMapperAvgAggregateOutputType | null
    _sum: LotFilingMapperSumAggregateOutputType | null
    _min: LotFilingMapperMinAggregateOutputType | null
    _max: LotFilingMapperMaxAggregateOutputType | null
  }

  export type LotFilingMapperAvgAggregateOutputType = {
    id: number | null
    filing_id: number | null
    lot_id: number | null
    item_id: number | null
    filing_entry_id: number | null
  }

  export type LotFilingMapperSumAggregateOutputType = {
    id: number | null
    filing_id: number | null
    lot_id: number | null
    item_id: number | null
    filing_entry_id: number | null
  }

  export type LotFilingMapperMinAggregateOutputType = {
    id: number | null
    filing_id: number | null
    lot_id: number | null
    item_id: number | null
    filing_entry_id: number | null
  }

  export type LotFilingMapperMaxAggregateOutputType = {
    id: number | null
    filing_id: number | null
    lot_id: number | null
    item_id: number | null
    filing_entry_id: number | null
  }

  export type LotFilingMapperCountAggregateOutputType = {
    id: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_entry_id: number
    _all: number
  }


  export type LotFilingMapperAvgAggregateInputType = {
    id?: true
    filing_id?: true
    lot_id?: true
    item_id?: true
    filing_entry_id?: true
  }

  export type LotFilingMapperSumAggregateInputType = {
    id?: true
    filing_id?: true
    lot_id?: true
    item_id?: true
    filing_entry_id?: true
  }

  export type LotFilingMapperMinAggregateInputType = {
    id?: true
    filing_id?: true
    lot_id?: true
    item_id?: true
    filing_entry_id?: true
  }

  export type LotFilingMapperMaxAggregateInputType = {
    id?: true
    filing_id?: true
    lot_id?: true
    item_id?: true
    filing_entry_id?: true
  }

  export type LotFilingMapperCountAggregateInputType = {
    id?: true
    filing_id?: true
    lot_id?: true
    item_id?: true
    filing_entry_id?: true
    _all?: true
  }

  export type LotFilingMapperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotFilingMapper to aggregate.
     */
    where?: LotFilingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotFilingMappers to fetch.
     */
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotFilingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotFilingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotFilingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotFilingMappers
    **/
    _count?: true | LotFilingMapperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotFilingMapperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotFilingMapperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotFilingMapperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotFilingMapperMaxAggregateInputType
  }

  export type GetLotFilingMapperAggregateType<T extends LotFilingMapperAggregateArgs> = {
        [P in keyof T & keyof AggregateLotFilingMapper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotFilingMapper[P]>
      : GetScalarType<T[P], AggregateLotFilingMapper[P]>
  }




  export type LotFilingMapperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotFilingMapperWhereInput
    orderBy?: LotFilingMapperOrderByWithAggregationInput | LotFilingMapperOrderByWithAggregationInput[]
    by: LotFilingMapperScalarFieldEnum[] | LotFilingMapperScalarFieldEnum
    having?: LotFilingMapperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotFilingMapperCountAggregateInputType | true
    _avg?: LotFilingMapperAvgAggregateInputType
    _sum?: LotFilingMapperSumAggregateInputType
    _min?: LotFilingMapperMinAggregateInputType
    _max?: LotFilingMapperMaxAggregateInputType
  }

  export type LotFilingMapperGroupByOutputType = {
    id: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_entry_id: number
    _count: LotFilingMapperCountAggregateOutputType | null
    _avg: LotFilingMapperAvgAggregateOutputType | null
    _sum: LotFilingMapperSumAggregateOutputType | null
    _min: LotFilingMapperMinAggregateOutputType | null
    _max: LotFilingMapperMaxAggregateOutputType | null
  }

  type GetLotFilingMapperGroupByPayload<T extends LotFilingMapperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotFilingMapperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotFilingMapperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotFilingMapperGroupByOutputType[P]>
            : GetScalarType<T[P], LotFilingMapperGroupByOutputType[P]>
        }
      >
    >


  export type LotFilingMapperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filing_id?: boolean
    lot_id?: boolean
    item_id?: boolean
    filing_entry_id?: boolean
    filingId?: boolean | AddFilingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    itemId?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filing_items?: boolean | LotFilingMapper$filing_itemsArgs<ExtArgs>
    filingEntry?: boolean | FilingEntryDefaultArgs<ExtArgs>
    _count?: boolean | LotFilingMapperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotFilingMapper"]>



  export type LotFilingMapperSelectScalar = {
    id?: boolean
    filing_id?: boolean
    lot_id?: boolean
    item_id?: boolean
    filing_entry_id?: boolean
  }

  export type LotFilingMapperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filing_id" | "lot_id" | "item_id" | "filing_entry_id", ExtArgs["result"]["lotFilingMapper"]>
  export type LotFilingMapperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingId?: boolean | AddFilingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    itemId?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filing_items?: boolean | LotFilingMapper$filing_itemsArgs<ExtArgs>
    filingEntry?: boolean | FilingEntryDefaultArgs<ExtArgs>
    _count?: boolean | LotFilingMapperCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LotFilingMapperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotFilingMapper"
    objects: {
      filingId: Prisma.$AddFilingPayload<ExtArgs>
      lotId: Prisma.$LotInfoPayload<ExtArgs>
      itemId: Prisma.$CastingItemsPayload<ExtArgs>
      filing_items: Prisma.$FilingItemsPayload<ExtArgs>[]
      filingEntry: Prisma.$FilingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filing_id: number
      lot_id: number
      item_id: number
      filing_entry_id: number
    }, ExtArgs["result"]["lotFilingMapper"]>
    composites: {}
  }

  type LotFilingMapperGetPayload<S extends boolean | null | undefined | LotFilingMapperDefaultArgs> = $Result.GetResult<Prisma.$LotFilingMapperPayload, S>

  type LotFilingMapperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LotFilingMapperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LotFilingMapperCountAggregateInputType | true
    }

  export interface LotFilingMapperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotFilingMapper'], meta: { name: 'LotFilingMapper' } }
    /**
     * Find zero or one LotFilingMapper that matches the filter.
     * @param {LotFilingMapperFindUniqueArgs} args - Arguments to find a LotFilingMapper
     * @example
     * // Get one LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotFilingMapperFindUniqueArgs>(args: SelectSubset<T, LotFilingMapperFindUniqueArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LotFilingMapper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LotFilingMapperFindUniqueOrThrowArgs} args - Arguments to find a LotFilingMapper
     * @example
     * // Get one LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotFilingMapperFindUniqueOrThrowArgs>(args: SelectSubset<T, LotFilingMapperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotFilingMapper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperFindFirstArgs} args - Arguments to find a LotFilingMapper
     * @example
     * // Get one LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotFilingMapperFindFirstArgs>(args?: SelectSubset<T, LotFilingMapperFindFirstArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotFilingMapper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperFindFirstOrThrowArgs} args - Arguments to find a LotFilingMapper
     * @example
     * // Get one LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotFilingMapperFindFirstOrThrowArgs>(args?: SelectSubset<T, LotFilingMapperFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LotFilingMappers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotFilingMappers
     * const lotFilingMappers = await prisma.lotFilingMapper.findMany()
     * 
     * // Get first 10 LotFilingMappers
     * const lotFilingMappers = await prisma.lotFilingMapper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotFilingMapperWithIdOnly = await prisma.lotFilingMapper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotFilingMapperFindManyArgs>(args?: SelectSubset<T, LotFilingMapperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LotFilingMapper.
     * @param {LotFilingMapperCreateArgs} args - Arguments to create a LotFilingMapper.
     * @example
     * // Create one LotFilingMapper
     * const LotFilingMapper = await prisma.lotFilingMapper.create({
     *   data: {
     *     // ... data to create a LotFilingMapper
     *   }
     * })
     * 
     */
    create<T extends LotFilingMapperCreateArgs>(args: SelectSubset<T, LotFilingMapperCreateArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LotFilingMappers.
     * @param {LotFilingMapperCreateManyArgs} args - Arguments to create many LotFilingMappers.
     * @example
     * // Create many LotFilingMappers
     * const lotFilingMapper = await prisma.lotFilingMapper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotFilingMapperCreateManyArgs>(args?: SelectSubset<T, LotFilingMapperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LotFilingMapper.
     * @param {LotFilingMapperDeleteArgs} args - Arguments to delete one LotFilingMapper.
     * @example
     * // Delete one LotFilingMapper
     * const LotFilingMapper = await prisma.lotFilingMapper.delete({
     *   where: {
     *     // ... filter to delete one LotFilingMapper
     *   }
     * })
     * 
     */
    delete<T extends LotFilingMapperDeleteArgs>(args: SelectSubset<T, LotFilingMapperDeleteArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LotFilingMapper.
     * @param {LotFilingMapperUpdateArgs} args - Arguments to update one LotFilingMapper.
     * @example
     * // Update one LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotFilingMapperUpdateArgs>(args: SelectSubset<T, LotFilingMapperUpdateArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LotFilingMappers.
     * @param {LotFilingMapperDeleteManyArgs} args - Arguments to filter LotFilingMappers to delete.
     * @example
     * // Delete a few LotFilingMappers
     * const { count } = await prisma.lotFilingMapper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotFilingMapperDeleteManyArgs>(args?: SelectSubset<T, LotFilingMapperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotFilingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotFilingMappers
     * const lotFilingMapper = await prisma.lotFilingMapper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotFilingMapperUpdateManyArgs>(args: SelectSubset<T, LotFilingMapperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotFilingMapper.
     * @param {LotFilingMapperUpsertArgs} args - Arguments to update or create a LotFilingMapper.
     * @example
     * // Update or create a LotFilingMapper
     * const lotFilingMapper = await prisma.lotFilingMapper.upsert({
     *   create: {
     *     // ... data to create a LotFilingMapper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotFilingMapper we want to update
     *   }
     * })
     */
    upsert<T extends LotFilingMapperUpsertArgs>(args: SelectSubset<T, LotFilingMapperUpsertArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LotFilingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperCountArgs} args - Arguments to filter LotFilingMappers to count.
     * @example
     * // Count the number of LotFilingMappers
     * const count = await prisma.lotFilingMapper.count({
     *   where: {
     *     // ... the filter for the LotFilingMappers we want to count
     *   }
     * })
    **/
    count<T extends LotFilingMapperCountArgs>(
      args?: Subset<T, LotFilingMapperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotFilingMapperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotFilingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotFilingMapperAggregateArgs>(args: Subset<T, LotFilingMapperAggregateArgs>): Prisma.PrismaPromise<GetLotFilingMapperAggregateType<T>>

    /**
     * Group by LotFilingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFilingMapperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotFilingMapperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotFilingMapperGroupByArgs['orderBy'] }
        : { orderBy?: LotFilingMapperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotFilingMapperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotFilingMapperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotFilingMapper model
   */
  readonly fields: LotFilingMapperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotFilingMapper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotFilingMapperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filingId<T extends AddFilingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddFilingDefaultArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lotId<T extends LotInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotInfoDefaultArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemId<T extends CastingItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingItemsDefaultArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filing_items<T extends LotFilingMapper$filing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, LotFilingMapper$filing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filingEntry<T extends FilingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntryDefaultArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotFilingMapper model
   */
  interface LotFilingMapperFieldRefs {
    readonly id: FieldRef<"LotFilingMapper", 'Int'>
    readonly filing_id: FieldRef<"LotFilingMapper", 'Int'>
    readonly lot_id: FieldRef<"LotFilingMapper", 'Int'>
    readonly item_id: FieldRef<"LotFilingMapper", 'Int'>
    readonly filing_entry_id: FieldRef<"LotFilingMapper", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LotFilingMapper findUnique
   */
  export type LotFilingMapperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotFilingMapper to fetch.
     */
    where: LotFilingMapperWhereUniqueInput
  }

  /**
   * LotFilingMapper findUniqueOrThrow
   */
  export type LotFilingMapperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotFilingMapper to fetch.
     */
    where: LotFilingMapperWhereUniqueInput
  }

  /**
   * LotFilingMapper findFirst
   */
  export type LotFilingMapperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotFilingMapper to fetch.
     */
    where?: LotFilingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotFilingMappers to fetch.
     */
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotFilingMappers.
     */
    cursor?: LotFilingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotFilingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotFilingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotFilingMappers.
     */
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * LotFilingMapper findFirstOrThrow
   */
  export type LotFilingMapperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotFilingMapper to fetch.
     */
    where?: LotFilingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotFilingMappers to fetch.
     */
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotFilingMappers.
     */
    cursor?: LotFilingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotFilingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotFilingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotFilingMappers.
     */
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * LotFilingMapper findMany
   */
  export type LotFilingMapperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotFilingMappers to fetch.
     */
    where?: LotFilingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotFilingMappers to fetch.
     */
    orderBy?: LotFilingMapperOrderByWithRelationInput | LotFilingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotFilingMappers.
     */
    cursor?: LotFilingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotFilingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotFilingMappers.
     */
    skip?: number
    distinct?: LotFilingMapperScalarFieldEnum | LotFilingMapperScalarFieldEnum[]
  }

  /**
   * LotFilingMapper create
   */
  export type LotFilingMapperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * The data needed to create a LotFilingMapper.
     */
    data: XOR<LotFilingMapperCreateInput, LotFilingMapperUncheckedCreateInput>
  }

  /**
   * LotFilingMapper createMany
   */
  export type LotFilingMapperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotFilingMappers.
     */
    data: LotFilingMapperCreateManyInput | LotFilingMapperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotFilingMapper update
   */
  export type LotFilingMapperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * The data needed to update a LotFilingMapper.
     */
    data: XOR<LotFilingMapperUpdateInput, LotFilingMapperUncheckedUpdateInput>
    /**
     * Choose, which LotFilingMapper to update.
     */
    where: LotFilingMapperWhereUniqueInput
  }

  /**
   * LotFilingMapper updateMany
   */
  export type LotFilingMapperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotFilingMappers.
     */
    data: XOR<LotFilingMapperUpdateManyMutationInput, LotFilingMapperUncheckedUpdateManyInput>
    /**
     * Filter which LotFilingMappers to update
     */
    where?: LotFilingMapperWhereInput
    /**
     * Limit how many LotFilingMappers to update.
     */
    limit?: number
  }

  /**
   * LotFilingMapper upsert
   */
  export type LotFilingMapperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * The filter to search for the LotFilingMapper to update in case it exists.
     */
    where: LotFilingMapperWhereUniqueInput
    /**
     * In case the LotFilingMapper found by the `where` argument doesn't exist, create a new LotFilingMapper with this data.
     */
    create: XOR<LotFilingMapperCreateInput, LotFilingMapperUncheckedCreateInput>
    /**
     * In case the LotFilingMapper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotFilingMapperUpdateInput, LotFilingMapperUncheckedUpdateInput>
  }

  /**
   * LotFilingMapper delete
   */
  export type LotFilingMapperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    /**
     * Filter which LotFilingMapper to delete.
     */
    where: LotFilingMapperWhereUniqueInput
  }

  /**
   * LotFilingMapper deleteMany
   */
  export type LotFilingMapperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotFilingMappers to delete
     */
    where?: LotFilingMapperWhereInput
    /**
     * Limit how many LotFilingMappers to delete.
     */
    limit?: number
  }

  /**
   * LotFilingMapper.filing_items
   */
  export type LotFilingMapper$filing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * LotFilingMapper without action
   */
  export type LotFilingMapperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
  }


  /**
   * Model FilingItems
   */

  export type AggregateFilingItems = {
    _count: FilingItemsCountAggregateOutputType | null
    _avg: FilingItemsAvgAggregateOutputType | null
    _sum: FilingItemsSumAggregateOutputType | null
    _min: FilingItemsMinAggregateOutputType | null
    _max: FilingItemsMaxAggregateOutputType | null
  }

  export type FilingItemsAvgAggregateOutputType = {
    id: number | null
    filing_entry_id: number | null
    filing_item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    lot_filing_mapper_id: number | null
  }

  export type FilingItemsSumAggregateOutputType = {
    id: number | null
    filing_entry_id: number | null
    filing_item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    lot_filing_mapper_id: number | null
  }

  export type FilingItemsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    filing_entry_id: number | null
    type: $Enums.CASTINGENTRYTYPE | null
    filing_item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    stone_option: $Enums.STONEOPTION | null
    lot_filing_mapper_id: number | null
  }

  export type FilingItemsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    filing_entry_id: number | null
    type: $Enums.CASTINGENTRYTYPE | null
    filing_item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    stone_option: $Enums.STONEOPTION | null
    lot_filing_mapper_id: number | null
  }

  export type FilingItemsCountAggregateOutputType = {
    id: number
    createdAt: number
    filing_entry_id: number
    type: number
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: number
    stone_option: number
    lot_filing_mapper_id: number
    _all: number
  }


  export type FilingItemsAvgAggregateInputType = {
    id?: true
    filing_entry_id?: true
    filing_item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    lot_filing_mapper_id?: true
  }

  export type FilingItemsSumAggregateInputType = {
    id?: true
    filing_entry_id?: true
    filing_item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    lot_filing_mapper_id?: true
  }

  export type FilingItemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    filing_entry_id?: true
    type?: true
    filing_item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    stone_option?: true
    lot_filing_mapper_id?: true
  }

  export type FilingItemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    filing_entry_id?: true
    type?: true
    filing_item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    stone_option?: true
    lot_filing_mapper_id?: true
  }

  export type FilingItemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    filing_entry_id?: true
    type?: true
    filing_item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    stone_option?: true
    lot_filing_mapper_id?: true
    _all?: true
  }

  export type FilingItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingItems to aggregate.
     */
    where?: FilingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingItems to fetch.
     */
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilingItems
    **/
    _count?: true | FilingItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilingItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilingItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilingItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilingItemsMaxAggregateInputType
  }

  export type GetFilingItemsAggregateType<T extends FilingItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateFilingItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilingItems[P]>
      : GetScalarType<T[P], AggregateFilingItems[P]>
  }




  export type FilingItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithAggregationInput | FilingItemsOrderByWithAggregationInput[]
    by: FilingItemsScalarFieldEnum[] | FilingItemsScalarFieldEnum
    having?: FilingItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilingItemsCountAggregateInputType | true
    _avg?: FilingItemsAvgAggregateInputType
    _sum?: FilingItemsSumAggregateInputType
    _min?: FilingItemsMinAggregateInputType
    _max?: FilingItemsMaxAggregateInputType
  }

  export type FilingItemsGroupByOutputType = {
    id: number
    createdAt: Date
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: string | null
    stone_option: $Enums.STONEOPTION | null
    lot_filing_mapper_id: number | null
    _count: FilingItemsCountAggregateOutputType | null
    _avg: FilingItemsAvgAggregateOutputType | null
    _sum: FilingItemsSumAggregateOutputType | null
    _min: FilingItemsMinAggregateOutputType | null
    _max: FilingItemsMaxAggregateOutputType | null
  }

  type GetFilingItemsGroupByPayload<T extends FilingItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilingItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilingItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilingItemsGroupByOutputType[P]>
            : GetScalarType<T[P], FilingItemsGroupByOutputType[P]>
        }
      >
    >


  export type FilingItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    filing_entry_id?: boolean
    type?: boolean
    filing_item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    stone_option?: boolean
    lot_filing_mapper_id?: boolean
    filing_entry?: boolean | FilingEntryDefaultArgs<ExtArgs>
    filingitem?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    stock?: boolean | FilingItems$stockArgs<ExtArgs>
    setting_entry?: boolean | FilingItems$setting_entryArgs<ExtArgs>
    buffing_entry?: boolean | FilingItems$buffing_entryArgs<ExtArgs>
    filing_wastage?: boolean | FilingItems$filing_wastageArgs<ExtArgs>
    lot_setting_mapper?: boolean | FilingItems$lot_setting_mapperArgs<ExtArgs>
    LotBuffingMapper?: boolean | FilingItems$LotBuffingMapperArgs<ExtArgs>
    lotFilingMapperId?: boolean | FilingItems$lotFilingMapperIdArgs<ExtArgs>
    _count?: boolean | FilingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filingItems"]>



  export type FilingItemsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    filing_entry_id?: boolean
    type?: boolean
    filing_item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    stone_option?: boolean
    lot_filing_mapper_id?: boolean
  }

  export type FilingItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "filing_entry_id" | "type" | "filing_item_id" | "weight" | "touch_id" | "item_purity" | "remarks" | "stone_option" | "lot_filing_mapper_id", ExtArgs["result"]["filingItems"]>
  export type FilingItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filing_entry?: boolean | FilingEntryDefaultArgs<ExtArgs>
    filingitem?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    stock?: boolean | FilingItems$stockArgs<ExtArgs>
    setting_entry?: boolean | FilingItems$setting_entryArgs<ExtArgs>
    buffing_entry?: boolean | FilingItems$buffing_entryArgs<ExtArgs>
    filing_wastage?: boolean | FilingItems$filing_wastageArgs<ExtArgs>
    lot_setting_mapper?: boolean | FilingItems$lot_setting_mapperArgs<ExtArgs>
    LotBuffingMapper?: boolean | FilingItems$LotBuffingMapperArgs<ExtArgs>
    lotFilingMapperId?: boolean | FilingItems$lotFilingMapperIdArgs<ExtArgs>
    _count?: boolean | FilingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilingItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilingItems"
    objects: {
      filing_entry: Prisma.$FilingEntryPayload<ExtArgs>
      filingitem: Prisma.$AddItemPayload<ExtArgs>
      touch: Prisma.$AddTouchPayload<ExtArgs>
      stock: Prisma.$StockPayload<ExtArgs>[]
      setting_entry: Prisma.$SettingEntryPayload<ExtArgs>[]
      buffing_entry: Prisma.$BuffingEntryPayload<ExtArgs>[]
      filing_wastage: Prisma.$FilingWastagePayload<ExtArgs>[]
      lot_setting_mapper: Prisma.$LotSettingMapperPayload<ExtArgs>[]
      LotBuffingMapper: Prisma.$LotBuffingMapperPayload<ExtArgs>[]
      lotFilingMapperId: Prisma.$LotFilingMapperPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      filing_entry_id: number
      type: $Enums.CASTINGENTRYTYPE
      filing_item_id: number
      weight: number
      touch_id: number
      item_purity: number
      remarks: string | null
      stone_option: $Enums.STONEOPTION | null
      lot_filing_mapper_id: number | null
    }, ExtArgs["result"]["filingItems"]>
    composites: {}
  }

  type FilingItemsGetPayload<S extends boolean | null | undefined | FilingItemsDefaultArgs> = $Result.GetResult<Prisma.$FilingItemsPayload, S>

  type FilingItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilingItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilingItemsCountAggregateInputType | true
    }

  export interface FilingItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilingItems'], meta: { name: 'FilingItems' } }
    /**
     * Find zero or one FilingItems that matches the filter.
     * @param {FilingItemsFindUniqueArgs} args - Arguments to find a FilingItems
     * @example
     * // Get one FilingItems
     * const filingItems = await prisma.filingItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilingItemsFindUniqueArgs>(args: SelectSubset<T, FilingItemsFindUniqueArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilingItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilingItemsFindUniqueOrThrowArgs} args - Arguments to find a FilingItems
     * @example
     * // Get one FilingItems
     * const filingItems = await prisma.filingItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilingItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, FilingItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsFindFirstArgs} args - Arguments to find a FilingItems
     * @example
     * // Get one FilingItems
     * const filingItems = await prisma.filingItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilingItemsFindFirstArgs>(args?: SelectSubset<T, FilingItemsFindFirstArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsFindFirstOrThrowArgs} args - Arguments to find a FilingItems
     * @example
     * // Get one FilingItems
     * const filingItems = await prisma.filingItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilingItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, FilingItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilingItems
     * const filingItems = await prisma.filingItems.findMany()
     * 
     * // Get first 10 FilingItems
     * const filingItems = await prisma.filingItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filingItemsWithIdOnly = await prisma.filingItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilingItemsFindManyArgs>(args?: SelectSubset<T, FilingItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilingItems.
     * @param {FilingItemsCreateArgs} args - Arguments to create a FilingItems.
     * @example
     * // Create one FilingItems
     * const FilingItems = await prisma.filingItems.create({
     *   data: {
     *     // ... data to create a FilingItems
     *   }
     * })
     * 
     */
    create<T extends FilingItemsCreateArgs>(args: SelectSubset<T, FilingItemsCreateArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilingItems.
     * @param {FilingItemsCreateManyArgs} args - Arguments to create many FilingItems.
     * @example
     * // Create many FilingItems
     * const filingItems = await prisma.filingItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilingItemsCreateManyArgs>(args?: SelectSubset<T, FilingItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FilingItems.
     * @param {FilingItemsDeleteArgs} args - Arguments to delete one FilingItems.
     * @example
     * // Delete one FilingItems
     * const FilingItems = await prisma.filingItems.delete({
     *   where: {
     *     // ... filter to delete one FilingItems
     *   }
     * })
     * 
     */
    delete<T extends FilingItemsDeleteArgs>(args: SelectSubset<T, FilingItemsDeleteArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilingItems.
     * @param {FilingItemsUpdateArgs} args - Arguments to update one FilingItems.
     * @example
     * // Update one FilingItems
     * const filingItems = await prisma.filingItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilingItemsUpdateArgs>(args: SelectSubset<T, FilingItemsUpdateArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilingItems.
     * @param {FilingItemsDeleteManyArgs} args - Arguments to filter FilingItems to delete.
     * @example
     * // Delete a few FilingItems
     * const { count } = await prisma.filingItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilingItemsDeleteManyArgs>(args?: SelectSubset<T, FilingItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilingItems
     * const filingItems = await prisma.filingItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilingItemsUpdateManyArgs>(args: SelectSubset<T, FilingItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilingItems.
     * @param {FilingItemsUpsertArgs} args - Arguments to update or create a FilingItems.
     * @example
     * // Update or create a FilingItems
     * const filingItems = await prisma.filingItems.upsert({
     *   create: {
     *     // ... data to create a FilingItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilingItems we want to update
     *   }
     * })
     */
    upsert<T extends FilingItemsUpsertArgs>(args: SelectSubset<T, FilingItemsUpsertArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsCountArgs} args - Arguments to filter FilingItems to count.
     * @example
     * // Count the number of FilingItems
     * const count = await prisma.filingItems.count({
     *   where: {
     *     // ... the filter for the FilingItems we want to count
     *   }
     * })
    **/
    count<T extends FilingItemsCountArgs>(
      args?: Subset<T, FilingItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilingItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilingItemsAggregateArgs>(args: Subset<T, FilingItemsAggregateArgs>): Prisma.PrismaPromise<GetFilingItemsAggregateType<T>>

    /**
     * Group by FilingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilingItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilingItemsGroupByArgs['orderBy'] }
        : { orderBy?: FilingItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilingItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilingItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilingItems model
   */
  readonly fields: FilingItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilingItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilingItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filing_entry<T extends FilingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntryDefaultArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filingitem<T extends AddItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddItemDefaultArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stock<T extends FilingItems$stockArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    setting_entry<T extends FilingItems$setting_entryArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$setting_entryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffing_entry<T extends FilingItems$buffing_entryArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$buffing_entryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filing_wastage<T extends FilingItems$filing_wastageArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$filing_wastageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lot_setting_mapper<T extends FilingItems$lot_setting_mapperArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$lot_setting_mapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LotBuffingMapper<T extends FilingItems$LotBuffingMapperArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$LotBuffingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lotFilingMapperId<T extends FilingItems$lotFilingMapperIdArgs<ExtArgs> = {}>(args?: Subset<T, FilingItems$lotFilingMapperIdArgs<ExtArgs>>): Prisma__LotFilingMapperClient<$Result.GetResult<Prisma.$LotFilingMapperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilingItems model
   */
  interface FilingItemsFieldRefs {
    readonly id: FieldRef<"FilingItems", 'Int'>
    readonly createdAt: FieldRef<"FilingItems", 'DateTime'>
    readonly filing_entry_id: FieldRef<"FilingItems", 'Int'>
    readonly type: FieldRef<"FilingItems", 'CASTINGENTRYTYPE'>
    readonly filing_item_id: FieldRef<"FilingItems", 'Int'>
    readonly weight: FieldRef<"FilingItems", 'Float'>
    readonly touch_id: FieldRef<"FilingItems", 'Int'>
    readonly item_purity: FieldRef<"FilingItems", 'Float'>
    readonly remarks: FieldRef<"FilingItems", 'String'>
    readonly stone_option: FieldRef<"FilingItems", 'STONEOPTION'>
    readonly lot_filing_mapper_id: FieldRef<"FilingItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilingItems findUnique
   */
  export type FilingItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter, which FilingItems to fetch.
     */
    where: FilingItemsWhereUniqueInput
  }

  /**
   * FilingItems findUniqueOrThrow
   */
  export type FilingItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter, which FilingItems to fetch.
     */
    where: FilingItemsWhereUniqueInput
  }

  /**
   * FilingItems findFirst
   */
  export type FilingItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter, which FilingItems to fetch.
     */
    where?: FilingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingItems to fetch.
     */
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingItems.
     */
    cursor?: FilingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingItems.
     */
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * FilingItems findFirstOrThrow
   */
  export type FilingItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter, which FilingItems to fetch.
     */
    where?: FilingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingItems to fetch.
     */
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingItems.
     */
    cursor?: FilingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingItems.
     */
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * FilingItems findMany
   */
  export type FilingItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter, which FilingItems to fetch.
     */
    where?: FilingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingItems to fetch.
     */
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilingItems.
     */
    cursor?: FilingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingItems.
     */
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * FilingItems create
   */
  export type FilingItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a FilingItems.
     */
    data: XOR<FilingItemsCreateInput, FilingItemsUncheckedCreateInput>
  }

  /**
   * FilingItems createMany
   */
  export type FilingItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilingItems.
     */
    data: FilingItemsCreateManyInput | FilingItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilingItems update
   */
  export type FilingItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a FilingItems.
     */
    data: XOR<FilingItemsUpdateInput, FilingItemsUncheckedUpdateInput>
    /**
     * Choose, which FilingItems to update.
     */
    where: FilingItemsWhereUniqueInput
  }

  /**
   * FilingItems updateMany
   */
  export type FilingItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilingItems.
     */
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyInput>
    /**
     * Filter which FilingItems to update
     */
    where?: FilingItemsWhereInput
    /**
     * Limit how many FilingItems to update.
     */
    limit?: number
  }

  /**
   * FilingItems upsert
   */
  export type FilingItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the FilingItems to update in case it exists.
     */
    where: FilingItemsWhereUniqueInput
    /**
     * In case the FilingItems found by the `where` argument doesn't exist, create a new FilingItems with this data.
     */
    create: XOR<FilingItemsCreateInput, FilingItemsUncheckedCreateInput>
    /**
     * In case the FilingItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilingItemsUpdateInput, FilingItemsUncheckedUpdateInput>
  }

  /**
   * FilingItems delete
   */
  export type FilingItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    /**
     * Filter which FilingItems to delete.
     */
    where: FilingItemsWhereUniqueInput
  }

  /**
   * FilingItems deleteMany
   */
  export type FilingItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingItems to delete
     */
    where?: FilingItemsWhereInput
    /**
     * Limit how many FilingItems to delete.
     */
    limit?: number
  }

  /**
   * FilingItems.stock
   */
  export type FilingItems$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * FilingItems.setting_entry
   */
  export type FilingItems$setting_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    where?: SettingEntryWhereInput
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    cursor?: SettingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * FilingItems.buffing_entry
   */
  export type FilingItems$buffing_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    where?: BuffingEntryWhereInput
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    cursor?: BuffingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * FilingItems.filing_wastage
   */
  export type FilingItems$filing_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    where?: FilingWastageWhereInput
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    cursor?: FilingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * FilingItems.lot_setting_mapper
   */
  export type FilingItems$lot_setting_mapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    where?: LotSettingMapperWhereInput
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    cursor?: LotSettingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * FilingItems.LotBuffingMapper
   */
  export type FilingItems$LotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    cursor?: LotBuffingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * FilingItems.lotFilingMapperId
   */
  export type FilingItems$lotFilingMapperIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotFilingMapper
     */
    select?: LotFilingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotFilingMapper
     */
    omit?: LotFilingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotFilingMapperInclude<ExtArgs> | null
    where?: LotFilingMapperWhereInput
  }

  /**
   * FilingItems without action
   */
  export type FilingItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
  }


  /**
   * Model FilingTotalBalance
   */

  export type AggregateFilingTotalBalance = {
    _count: FilingTotalBalanceCountAggregateOutputType | null
    _avg: FilingTotalBalanceAvgAggregateOutputType | null
    _sum: FilingTotalBalanceSumAggregateOutputType | null
    _min: FilingTotalBalanceMinAggregateOutputType | null
    _max: FilingTotalBalanceMaxAggregateOutputType | null
  }

  export type FilingTotalBalanceAvgAggregateOutputType = {
    id: number | null
    after_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    filing_entry_id: number | null
  }

  export type FilingTotalBalanceSumAggregateOutputType = {
    id: number | null
    after_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    filing_entry_id: number | null
  }

  export type FilingTotalBalanceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    after_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    wastage: boolean | null
    balance: number | null
    filing_entry_id: number | null
  }

  export type FilingTotalBalanceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    after_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    wastage: boolean | null
    balance: number | null
    filing_entry_id: number | null
  }

  export type FilingTotalBalanceCountAggregateOutputType = {
    id: number
    createdAt: number
    after_weight: number
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight: number
    wastage: number
    balance: number
    filing_entry_id: number
    _all: number
  }


  export type FilingTotalBalanceAvgAggregateInputType = {
    id?: true
    after_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    filing_entry_id?: true
  }

  export type FilingTotalBalanceSumAggregateInputType = {
    id?: true
    after_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    filing_entry_id?: true
  }

  export type FilingTotalBalanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    after_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    wastage?: true
    balance?: true
    filing_entry_id?: true
  }

  export type FilingTotalBalanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    after_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    wastage?: true
    balance?: true
    filing_entry_id?: true
  }

  export type FilingTotalBalanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    after_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    wastage?: true
    balance?: true
    filing_entry_id?: true
    _all?: true
  }

  export type FilingTotalBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingTotalBalance to aggregate.
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingTotalBalances to fetch.
     */
    orderBy?: FilingTotalBalanceOrderByWithRelationInput | FilingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilingTotalBalances
    **/
    _count?: true | FilingTotalBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilingTotalBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilingTotalBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilingTotalBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilingTotalBalanceMaxAggregateInputType
  }

  export type GetFilingTotalBalanceAggregateType<T extends FilingTotalBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFilingTotalBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilingTotalBalance[P]>
      : GetScalarType<T[P], AggregateFilingTotalBalance[P]>
  }




  export type FilingTotalBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingTotalBalanceWhereInput
    orderBy?: FilingTotalBalanceOrderByWithAggregationInput | FilingTotalBalanceOrderByWithAggregationInput[]
    by: FilingTotalBalanceScalarFieldEnum[] | FilingTotalBalanceScalarFieldEnum
    having?: FilingTotalBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilingTotalBalanceCountAggregateInputType | true
    _avg?: FilingTotalBalanceAvgAggregateInputType
    _sum?: FilingTotalBalanceSumAggregateInputType
    _min?: FilingTotalBalanceMinAggregateInputType
    _max?: FilingTotalBalanceMaxAggregateInputType
  }

  export type FilingTotalBalanceGroupByOutputType = {
    id: number
    createdAt: Date
    after_weight: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight: number | null
    wastage: boolean
    balance: number
    filing_entry_id: number
    _count: FilingTotalBalanceCountAggregateOutputType | null
    _avg: FilingTotalBalanceAvgAggregateOutputType | null
    _sum: FilingTotalBalanceSumAggregateOutputType | null
    _min: FilingTotalBalanceMinAggregateOutputType | null
    _max: FilingTotalBalanceMaxAggregateOutputType | null
  }

  type GetFilingTotalBalanceGroupByPayload<T extends FilingTotalBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilingTotalBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilingTotalBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilingTotalBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], FilingTotalBalanceGroupByOutputType[P]>
        }
      >
    >


  export type FilingTotalBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    after_weight?: boolean
    total_product_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    wastage?: boolean
    balance?: boolean
    filing_entry_id?: boolean
    filingEntryId?: boolean | FilingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filingTotalBalance"]>



  export type FilingTotalBalanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    after_weight?: boolean
    total_product_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    wastage?: boolean
    balance?: boolean
    filing_entry_id?: boolean
  }

  export type FilingTotalBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "after_weight" | "total_product_weight" | "current_balance_weight" | "total_scrap_weight" | "wastage" | "balance" | "filing_entry_id", ExtArgs["result"]["filingTotalBalance"]>
  export type FilingTotalBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingEntryId?: boolean | FilingEntryDefaultArgs<ExtArgs>
  }

  export type $FilingTotalBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilingTotalBalance"
    objects: {
      filingEntryId: Prisma.$FilingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      after_weight: number | null
      total_product_weight: number
      current_balance_weight: number
      total_scrap_weight: number | null
      wastage: boolean
      balance: number
      filing_entry_id: number
    }, ExtArgs["result"]["filingTotalBalance"]>
    composites: {}
  }

  type FilingTotalBalanceGetPayload<S extends boolean | null | undefined | FilingTotalBalanceDefaultArgs> = $Result.GetResult<Prisma.$FilingTotalBalancePayload, S>

  type FilingTotalBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilingTotalBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilingTotalBalanceCountAggregateInputType | true
    }

  export interface FilingTotalBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilingTotalBalance'], meta: { name: 'FilingTotalBalance' } }
    /**
     * Find zero or one FilingTotalBalance that matches the filter.
     * @param {FilingTotalBalanceFindUniqueArgs} args - Arguments to find a FilingTotalBalance
     * @example
     * // Get one FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilingTotalBalanceFindUniqueArgs>(args: SelectSubset<T, FilingTotalBalanceFindUniqueArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilingTotalBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilingTotalBalanceFindUniqueOrThrowArgs} args - Arguments to find a FilingTotalBalance
     * @example
     * // Get one FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilingTotalBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FilingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingTotalBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceFindFirstArgs} args - Arguments to find a FilingTotalBalance
     * @example
     * // Get one FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilingTotalBalanceFindFirstArgs>(args?: SelectSubset<T, FilingTotalBalanceFindFirstArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingTotalBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceFindFirstOrThrowArgs} args - Arguments to find a FilingTotalBalance
     * @example
     * // Get one FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilingTotalBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FilingTotalBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilingTotalBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilingTotalBalances
     * const filingTotalBalances = await prisma.filingTotalBalance.findMany()
     * 
     * // Get first 10 FilingTotalBalances
     * const filingTotalBalances = await prisma.filingTotalBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filingTotalBalanceWithIdOnly = await prisma.filingTotalBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilingTotalBalanceFindManyArgs>(args?: SelectSubset<T, FilingTotalBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilingTotalBalance.
     * @param {FilingTotalBalanceCreateArgs} args - Arguments to create a FilingTotalBalance.
     * @example
     * // Create one FilingTotalBalance
     * const FilingTotalBalance = await prisma.filingTotalBalance.create({
     *   data: {
     *     // ... data to create a FilingTotalBalance
     *   }
     * })
     * 
     */
    create<T extends FilingTotalBalanceCreateArgs>(args: SelectSubset<T, FilingTotalBalanceCreateArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilingTotalBalances.
     * @param {FilingTotalBalanceCreateManyArgs} args - Arguments to create many FilingTotalBalances.
     * @example
     * // Create many FilingTotalBalances
     * const filingTotalBalance = await prisma.filingTotalBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilingTotalBalanceCreateManyArgs>(args?: SelectSubset<T, FilingTotalBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FilingTotalBalance.
     * @param {FilingTotalBalanceDeleteArgs} args - Arguments to delete one FilingTotalBalance.
     * @example
     * // Delete one FilingTotalBalance
     * const FilingTotalBalance = await prisma.filingTotalBalance.delete({
     *   where: {
     *     // ... filter to delete one FilingTotalBalance
     *   }
     * })
     * 
     */
    delete<T extends FilingTotalBalanceDeleteArgs>(args: SelectSubset<T, FilingTotalBalanceDeleteArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilingTotalBalance.
     * @param {FilingTotalBalanceUpdateArgs} args - Arguments to update one FilingTotalBalance.
     * @example
     * // Update one FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilingTotalBalanceUpdateArgs>(args: SelectSubset<T, FilingTotalBalanceUpdateArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilingTotalBalances.
     * @param {FilingTotalBalanceDeleteManyArgs} args - Arguments to filter FilingTotalBalances to delete.
     * @example
     * // Delete a few FilingTotalBalances
     * const { count } = await prisma.filingTotalBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilingTotalBalanceDeleteManyArgs>(args?: SelectSubset<T, FilingTotalBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilingTotalBalances
     * const filingTotalBalance = await prisma.filingTotalBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilingTotalBalanceUpdateManyArgs>(args: SelectSubset<T, FilingTotalBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilingTotalBalance.
     * @param {FilingTotalBalanceUpsertArgs} args - Arguments to update or create a FilingTotalBalance.
     * @example
     * // Update or create a FilingTotalBalance
     * const filingTotalBalance = await prisma.filingTotalBalance.upsert({
     *   create: {
     *     // ... data to create a FilingTotalBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilingTotalBalance we want to update
     *   }
     * })
     */
    upsert<T extends FilingTotalBalanceUpsertArgs>(args: SelectSubset<T, FilingTotalBalanceUpsertArgs<ExtArgs>>): Prisma__FilingTotalBalanceClient<$Result.GetResult<Prisma.$FilingTotalBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceCountArgs} args - Arguments to filter FilingTotalBalances to count.
     * @example
     * // Count the number of FilingTotalBalances
     * const count = await prisma.filingTotalBalance.count({
     *   where: {
     *     // ... the filter for the FilingTotalBalances we want to count
     *   }
     * })
    **/
    count<T extends FilingTotalBalanceCountArgs>(
      args?: Subset<T, FilingTotalBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilingTotalBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilingTotalBalanceAggregateArgs>(args: Subset<T, FilingTotalBalanceAggregateArgs>): Prisma.PrismaPromise<GetFilingTotalBalanceAggregateType<T>>

    /**
     * Group by FilingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingTotalBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilingTotalBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilingTotalBalanceGroupByArgs['orderBy'] }
        : { orderBy?: FilingTotalBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilingTotalBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilingTotalBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilingTotalBalance model
   */
  readonly fields: FilingTotalBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilingTotalBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilingTotalBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filingEntryId<T extends FilingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilingEntryDefaultArgs<ExtArgs>>): Prisma__FilingEntryClient<$Result.GetResult<Prisma.$FilingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilingTotalBalance model
   */
  interface FilingTotalBalanceFieldRefs {
    readonly id: FieldRef<"FilingTotalBalance", 'Int'>
    readonly createdAt: FieldRef<"FilingTotalBalance", 'DateTime'>
    readonly after_weight: FieldRef<"FilingTotalBalance", 'Float'>
    readonly total_product_weight: FieldRef<"FilingTotalBalance", 'Float'>
    readonly current_balance_weight: FieldRef<"FilingTotalBalance", 'Float'>
    readonly total_scrap_weight: FieldRef<"FilingTotalBalance", 'Float'>
    readonly wastage: FieldRef<"FilingTotalBalance", 'Boolean'>
    readonly balance: FieldRef<"FilingTotalBalance", 'Float'>
    readonly filing_entry_id: FieldRef<"FilingTotalBalance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilingTotalBalance findUnique
   */
  export type FilingTotalBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which FilingTotalBalance to fetch.
     */
    where: FilingTotalBalanceWhereUniqueInput
  }

  /**
   * FilingTotalBalance findUniqueOrThrow
   */
  export type FilingTotalBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which FilingTotalBalance to fetch.
     */
    where: FilingTotalBalanceWhereUniqueInput
  }

  /**
   * FilingTotalBalance findFirst
   */
  export type FilingTotalBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which FilingTotalBalance to fetch.
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingTotalBalances to fetch.
     */
    orderBy?: FilingTotalBalanceOrderByWithRelationInput | FilingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingTotalBalances.
     */
    cursor?: FilingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingTotalBalances.
     */
    distinct?: FilingTotalBalanceScalarFieldEnum | FilingTotalBalanceScalarFieldEnum[]
  }

  /**
   * FilingTotalBalance findFirstOrThrow
   */
  export type FilingTotalBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which FilingTotalBalance to fetch.
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingTotalBalances to fetch.
     */
    orderBy?: FilingTotalBalanceOrderByWithRelationInput | FilingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingTotalBalances.
     */
    cursor?: FilingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingTotalBalances.
     */
    distinct?: FilingTotalBalanceScalarFieldEnum | FilingTotalBalanceScalarFieldEnum[]
  }

  /**
   * FilingTotalBalance findMany
   */
  export type FilingTotalBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which FilingTotalBalances to fetch.
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingTotalBalances to fetch.
     */
    orderBy?: FilingTotalBalanceOrderByWithRelationInput | FilingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilingTotalBalances.
     */
    cursor?: FilingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingTotalBalances.
     */
    skip?: number
    distinct?: FilingTotalBalanceScalarFieldEnum | FilingTotalBalanceScalarFieldEnum[]
  }

  /**
   * FilingTotalBalance create
   */
  export type FilingTotalBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a FilingTotalBalance.
     */
    data: XOR<FilingTotalBalanceCreateInput, FilingTotalBalanceUncheckedCreateInput>
  }

  /**
   * FilingTotalBalance createMany
   */
  export type FilingTotalBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilingTotalBalances.
     */
    data: FilingTotalBalanceCreateManyInput | FilingTotalBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilingTotalBalance update
   */
  export type FilingTotalBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a FilingTotalBalance.
     */
    data: XOR<FilingTotalBalanceUpdateInput, FilingTotalBalanceUncheckedUpdateInput>
    /**
     * Choose, which FilingTotalBalance to update.
     */
    where: FilingTotalBalanceWhereUniqueInput
  }

  /**
   * FilingTotalBalance updateMany
   */
  export type FilingTotalBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilingTotalBalances.
     */
    data: XOR<FilingTotalBalanceUpdateManyMutationInput, FilingTotalBalanceUncheckedUpdateManyInput>
    /**
     * Filter which FilingTotalBalances to update
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * Limit how many FilingTotalBalances to update.
     */
    limit?: number
  }

  /**
   * FilingTotalBalance upsert
   */
  export type FilingTotalBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the FilingTotalBalance to update in case it exists.
     */
    where: FilingTotalBalanceWhereUniqueInput
    /**
     * In case the FilingTotalBalance found by the `where` argument doesn't exist, create a new FilingTotalBalance with this data.
     */
    create: XOR<FilingTotalBalanceCreateInput, FilingTotalBalanceUncheckedCreateInput>
    /**
     * In case the FilingTotalBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilingTotalBalanceUpdateInput, FilingTotalBalanceUncheckedUpdateInput>
  }

  /**
   * FilingTotalBalance delete
   */
  export type FilingTotalBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter which FilingTotalBalance to delete.
     */
    where: FilingTotalBalanceWhereUniqueInput
  }

  /**
   * FilingTotalBalance deleteMany
   */
  export type FilingTotalBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingTotalBalances to delete
     */
    where?: FilingTotalBalanceWhereInput
    /**
     * Limit how many FilingTotalBalances to delete.
     */
    limit?: number
  }

  /**
   * FilingTotalBalance without action
   */
  export type FilingTotalBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingTotalBalance
     */
    select?: FilingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingTotalBalance
     */
    omit?: FilingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingTotalBalanceInclude<ExtArgs> | null
  }


  /**
   * Model FilingWastage
   */

  export type AggregateFilingWastage = {
    _count: FilingWastageCountAggregateOutputType | null
    _avg: FilingWastageAvgAggregateOutputType | null
    _sum: FilingWastageSumAggregateOutputType | null
    _min: FilingWastageMinAggregateOutputType | null
    _max: FilingWastageMaxAggregateOutputType | null
  }

  export type FilingWastageAvgAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    filing_person_id: number | null
    filing_lot_id: number | null
  }

  export type FilingWastageSumAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    filing_person_id: number | null
    filing_lot_id: number | null
  }

  export type FilingWastageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    filing_person_id: number | null
    filing_lot_id: number | null
  }

  export type FilingWastageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    filing_person_id: number | null
    filing_lot_id: number | null
  }

  export type FilingWastageCountAggregateOutputType = {
    id: number
    createdAt: number
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number
    add_wastage: number
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id: number
    filing_lot_id: number
    _all: number
  }


  export type FilingWastageAvgAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    filing_person_id?: true
    filing_lot_id?: true
  }

  export type FilingWastageSumAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    filing_person_id?: true
    filing_lot_id?: true
  }

  export type FilingWastageMinAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    filing_person_id?: true
    filing_lot_id?: true
  }

  export type FilingWastageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    filing_person_id?: true
    filing_lot_id?: true
  }

  export type FilingWastageCountAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    filing_person_id?: true
    filing_lot_id?: true
    _all?: true
  }

  export type FilingWastageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingWastage to aggregate.
     */
    where?: FilingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingWastages to fetch.
     */
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilingWastages
    **/
    _count?: true | FilingWastageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilingWastageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilingWastageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilingWastageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilingWastageMaxAggregateInputType
  }

  export type GetFilingWastageAggregateType<T extends FilingWastageAggregateArgs> = {
        [P in keyof T & keyof AggregateFilingWastage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilingWastage[P]>
      : GetScalarType<T[P], AggregateFilingWastage[P]>
  }




  export type FilingWastageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilingWastageWhereInput
    orderBy?: FilingWastageOrderByWithAggregationInput | FilingWastageOrderByWithAggregationInput[]
    by: FilingWastageScalarFieldEnum[] | FilingWastageScalarFieldEnum
    having?: FilingWastageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilingWastageCountAggregateInputType | true
    _avg?: FilingWastageAvgAggregateInputType
    _sum?: FilingWastageSumAggregateInputType
    _min?: FilingWastageMinAggregateInputType
    _max?: FilingWastageMaxAggregateInputType
  }

  export type FilingWastageGroupByOutputType = {
    id: number
    createdAt: Date
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id: number | null
    filing_lot_id: number | null
    _count: FilingWastageCountAggregateOutputType | null
    _avg: FilingWastageAvgAggregateOutputType | null
    _sum: FilingWastageSumAggregateOutputType | null
    _min: FilingWastageMinAggregateOutputType | null
    _max: FilingWastageMaxAggregateOutputType | null
  }

  type GetFilingWastageGroupByPayload<T extends FilingWastageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilingWastageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilingWastageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilingWastageGroupByOutputType[P]>
            : GetScalarType<T[P], FilingWastageGroupByOutputType[P]>
        }
      >
    >


  export type FilingWastageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    filing_person_id?: boolean
    filing_lot_id?: boolean
    filingPersonId?: boolean | FilingWastage$filingPersonIdArgs<ExtArgs>
    filingLotId?: boolean | FilingWastage$filingLotIdArgs<ExtArgs>
    filing_items?: boolean | FilingWastage$filing_itemsArgs<ExtArgs>
    _count?: boolean | FilingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filingWastage"]>



  export type FilingWastageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    filing_person_id?: boolean
    filing_lot_id?: boolean
  }

  export type FilingWastageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "total_receipt" | "total_wastage" | "balance" | "wastage_percentage" | "given_gold" | "add_wastage" | "overall_wastage" | "closing_balance" | "opening_balance" | "filing_person_id" | "filing_lot_id", ExtArgs["result"]["filingWastage"]>
  export type FilingWastageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filingPersonId?: boolean | FilingWastage$filingPersonIdArgs<ExtArgs>
    filingLotId?: boolean | FilingWastage$filingLotIdArgs<ExtArgs>
    filing_items?: boolean | FilingWastage$filing_itemsArgs<ExtArgs>
    _count?: boolean | FilingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilingWastagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilingWastage"
    objects: {
      filingPersonId: Prisma.$AddFilingPayload<ExtArgs> | null
      filingLotId: Prisma.$LotInfoPayload<ExtArgs> | null
      filing_items: Prisma.$FilingItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      total_receipt: number
      total_wastage: number
      balance: number
      wastage_percentage: number
      given_gold: number | null
      add_wastage: number | null
      overall_wastage: number
      closing_balance: number
      opening_balance: number
      filing_person_id: number | null
      filing_lot_id: number | null
    }, ExtArgs["result"]["filingWastage"]>
    composites: {}
  }

  type FilingWastageGetPayload<S extends boolean | null | undefined | FilingWastageDefaultArgs> = $Result.GetResult<Prisma.$FilingWastagePayload, S>

  type FilingWastageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilingWastageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilingWastageCountAggregateInputType | true
    }

  export interface FilingWastageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilingWastage'], meta: { name: 'FilingWastage' } }
    /**
     * Find zero or one FilingWastage that matches the filter.
     * @param {FilingWastageFindUniqueArgs} args - Arguments to find a FilingWastage
     * @example
     * // Get one FilingWastage
     * const filingWastage = await prisma.filingWastage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilingWastageFindUniqueArgs>(args: SelectSubset<T, FilingWastageFindUniqueArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilingWastage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilingWastageFindUniqueOrThrowArgs} args - Arguments to find a FilingWastage
     * @example
     * // Get one FilingWastage
     * const filingWastage = await prisma.filingWastage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilingWastageFindUniqueOrThrowArgs>(args: SelectSubset<T, FilingWastageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingWastage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageFindFirstArgs} args - Arguments to find a FilingWastage
     * @example
     * // Get one FilingWastage
     * const filingWastage = await prisma.filingWastage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilingWastageFindFirstArgs>(args?: SelectSubset<T, FilingWastageFindFirstArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilingWastage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageFindFirstOrThrowArgs} args - Arguments to find a FilingWastage
     * @example
     * // Get one FilingWastage
     * const filingWastage = await prisma.filingWastage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilingWastageFindFirstOrThrowArgs>(args?: SelectSubset<T, FilingWastageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilingWastages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilingWastages
     * const filingWastages = await prisma.filingWastage.findMany()
     * 
     * // Get first 10 FilingWastages
     * const filingWastages = await prisma.filingWastage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filingWastageWithIdOnly = await prisma.filingWastage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilingWastageFindManyArgs>(args?: SelectSubset<T, FilingWastageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilingWastage.
     * @param {FilingWastageCreateArgs} args - Arguments to create a FilingWastage.
     * @example
     * // Create one FilingWastage
     * const FilingWastage = await prisma.filingWastage.create({
     *   data: {
     *     // ... data to create a FilingWastage
     *   }
     * })
     * 
     */
    create<T extends FilingWastageCreateArgs>(args: SelectSubset<T, FilingWastageCreateArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilingWastages.
     * @param {FilingWastageCreateManyArgs} args - Arguments to create many FilingWastages.
     * @example
     * // Create many FilingWastages
     * const filingWastage = await prisma.filingWastage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilingWastageCreateManyArgs>(args?: SelectSubset<T, FilingWastageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FilingWastage.
     * @param {FilingWastageDeleteArgs} args - Arguments to delete one FilingWastage.
     * @example
     * // Delete one FilingWastage
     * const FilingWastage = await prisma.filingWastage.delete({
     *   where: {
     *     // ... filter to delete one FilingWastage
     *   }
     * })
     * 
     */
    delete<T extends FilingWastageDeleteArgs>(args: SelectSubset<T, FilingWastageDeleteArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilingWastage.
     * @param {FilingWastageUpdateArgs} args - Arguments to update one FilingWastage.
     * @example
     * // Update one FilingWastage
     * const filingWastage = await prisma.filingWastage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilingWastageUpdateArgs>(args: SelectSubset<T, FilingWastageUpdateArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilingWastages.
     * @param {FilingWastageDeleteManyArgs} args - Arguments to filter FilingWastages to delete.
     * @example
     * // Delete a few FilingWastages
     * const { count } = await prisma.filingWastage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilingWastageDeleteManyArgs>(args?: SelectSubset<T, FilingWastageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilingWastages
     * const filingWastage = await prisma.filingWastage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilingWastageUpdateManyArgs>(args: SelectSubset<T, FilingWastageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilingWastage.
     * @param {FilingWastageUpsertArgs} args - Arguments to update or create a FilingWastage.
     * @example
     * // Update or create a FilingWastage
     * const filingWastage = await prisma.filingWastage.upsert({
     *   create: {
     *     // ... data to create a FilingWastage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilingWastage we want to update
     *   }
     * })
     */
    upsert<T extends FilingWastageUpsertArgs>(args: SelectSubset<T, FilingWastageUpsertArgs<ExtArgs>>): Prisma__FilingWastageClient<$Result.GetResult<Prisma.$FilingWastagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageCountArgs} args - Arguments to filter FilingWastages to count.
     * @example
     * // Count the number of FilingWastages
     * const count = await prisma.filingWastage.count({
     *   where: {
     *     // ... the filter for the FilingWastages we want to count
     *   }
     * })
    **/
    count<T extends FilingWastageCountArgs>(
      args?: Subset<T, FilingWastageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilingWastageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilingWastageAggregateArgs>(args: Subset<T, FilingWastageAggregateArgs>): Prisma.PrismaPromise<GetFilingWastageAggregateType<T>>

    /**
     * Group by FilingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilingWastageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilingWastageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilingWastageGroupByArgs['orderBy'] }
        : { orderBy?: FilingWastageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilingWastageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilingWastageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilingWastage model
   */
  readonly fields: FilingWastageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilingWastage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilingWastageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filingPersonId<T extends FilingWastage$filingPersonIdArgs<ExtArgs> = {}>(args?: Subset<T, FilingWastage$filingPersonIdArgs<ExtArgs>>): Prisma__AddFilingClient<$Result.GetResult<Prisma.$AddFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    filingLotId<T extends FilingWastage$filingLotIdArgs<ExtArgs> = {}>(args?: Subset<T, FilingWastage$filingLotIdArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    filing_items<T extends FilingWastage$filing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, FilingWastage$filing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilingWastage model
   */
  interface FilingWastageFieldRefs {
    readonly id: FieldRef<"FilingWastage", 'Int'>
    readonly createdAt: FieldRef<"FilingWastage", 'DateTime'>
    readonly total_receipt: FieldRef<"FilingWastage", 'Float'>
    readonly total_wastage: FieldRef<"FilingWastage", 'Float'>
    readonly balance: FieldRef<"FilingWastage", 'Float'>
    readonly wastage_percentage: FieldRef<"FilingWastage", 'Int'>
    readonly given_gold: FieldRef<"FilingWastage", 'Float'>
    readonly add_wastage: FieldRef<"FilingWastage", 'Float'>
    readonly overall_wastage: FieldRef<"FilingWastage", 'Float'>
    readonly closing_balance: FieldRef<"FilingWastage", 'Float'>
    readonly opening_balance: FieldRef<"FilingWastage", 'Float'>
    readonly filing_person_id: FieldRef<"FilingWastage", 'Int'>
    readonly filing_lot_id: FieldRef<"FilingWastage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilingWastage findUnique
   */
  export type FilingWastageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter, which FilingWastage to fetch.
     */
    where: FilingWastageWhereUniqueInput
  }

  /**
   * FilingWastage findUniqueOrThrow
   */
  export type FilingWastageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter, which FilingWastage to fetch.
     */
    where: FilingWastageWhereUniqueInput
  }

  /**
   * FilingWastage findFirst
   */
  export type FilingWastageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter, which FilingWastage to fetch.
     */
    where?: FilingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingWastages to fetch.
     */
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingWastages.
     */
    cursor?: FilingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingWastages.
     */
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * FilingWastage findFirstOrThrow
   */
  export type FilingWastageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter, which FilingWastage to fetch.
     */
    where?: FilingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingWastages to fetch.
     */
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilingWastages.
     */
    cursor?: FilingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilingWastages.
     */
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * FilingWastage findMany
   */
  export type FilingWastageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter, which FilingWastages to fetch.
     */
    where?: FilingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilingWastages to fetch.
     */
    orderBy?: FilingWastageOrderByWithRelationInput | FilingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilingWastages.
     */
    cursor?: FilingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilingWastages.
     */
    skip?: number
    distinct?: FilingWastageScalarFieldEnum | FilingWastageScalarFieldEnum[]
  }

  /**
   * FilingWastage create
   */
  export type FilingWastageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * The data needed to create a FilingWastage.
     */
    data: XOR<FilingWastageCreateInput, FilingWastageUncheckedCreateInput>
  }

  /**
   * FilingWastage createMany
   */
  export type FilingWastageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilingWastages.
     */
    data: FilingWastageCreateManyInput | FilingWastageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilingWastage update
   */
  export type FilingWastageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * The data needed to update a FilingWastage.
     */
    data: XOR<FilingWastageUpdateInput, FilingWastageUncheckedUpdateInput>
    /**
     * Choose, which FilingWastage to update.
     */
    where: FilingWastageWhereUniqueInput
  }

  /**
   * FilingWastage updateMany
   */
  export type FilingWastageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilingWastages.
     */
    data: XOR<FilingWastageUpdateManyMutationInput, FilingWastageUncheckedUpdateManyInput>
    /**
     * Filter which FilingWastages to update
     */
    where?: FilingWastageWhereInput
    /**
     * Limit how many FilingWastages to update.
     */
    limit?: number
  }

  /**
   * FilingWastage upsert
   */
  export type FilingWastageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * The filter to search for the FilingWastage to update in case it exists.
     */
    where: FilingWastageWhereUniqueInput
    /**
     * In case the FilingWastage found by the `where` argument doesn't exist, create a new FilingWastage with this data.
     */
    create: XOR<FilingWastageCreateInput, FilingWastageUncheckedCreateInput>
    /**
     * In case the FilingWastage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilingWastageUpdateInput, FilingWastageUncheckedUpdateInput>
  }

  /**
   * FilingWastage delete
   */
  export type FilingWastageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
    /**
     * Filter which FilingWastage to delete.
     */
    where: FilingWastageWhereUniqueInput
  }

  /**
   * FilingWastage deleteMany
   */
  export type FilingWastageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilingWastages to delete
     */
    where?: FilingWastageWhereInput
    /**
     * Limit how many FilingWastages to delete.
     */
    limit?: number
  }

  /**
   * FilingWastage.filingPersonId
   */
  export type FilingWastage$filingPersonIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddFiling
     */
    select?: AddFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddFiling
     */
    omit?: AddFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddFilingInclude<ExtArgs> | null
    where?: AddFilingWhereInput
  }

  /**
   * FilingWastage.filingLotId
   */
  export type FilingWastage$filingLotIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    where?: LotInfoWhereInput
  }

  /**
   * FilingWastage.filing_items
   */
  export type FilingWastage$filing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * FilingWastage without action
   */
  export type FilingWastageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingWastage
     */
    select?: FilingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingWastage
     */
    omit?: FilingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingWastageInclude<ExtArgs> | null
  }


  /**
   * Model SettingEntry
   */

  export type AggregateSettingEntry = {
    _count: SettingEntryCountAggregateOutputType | null
    _avg: SettingEntryAvgAggregateOutputType | null
    _sum: SettingEntrySumAggregateOutputType | null
    _min: SettingEntryMinAggregateOutputType | null
    _max: SettingEntryMaxAggregateOutputType | null
  }

  export type SettingEntryAvgAggregateOutputType = {
    id: number | null
    setting_person_id: number | null
    casting_item_id: number | null
  }

  export type SettingEntrySumAggregateOutputType = {
    id: number | null
    setting_person_id: number | null
    casting_item_id: number | null
  }

  export type SettingEntryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    setting_person_id: number | null
    casting_item_id: number | null
  }

  export type SettingEntryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    setting_person_id: number | null
    casting_item_id: number | null
  }

  export type SettingEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    setting_person_id: number
    casting_item_id: number
    _all: number
  }


  export type SettingEntryAvgAggregateInputType = {
    id?: true
    setting_person_id?: true
    casting_item_id?: true
  }

  export type SettingEntrySumAggregateInputType = {
    id?: true
    setting_person_id?: true
    casting_item_id?: true
  }

  export type SettingEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    setting_person_id?: true
    casting_item_id?: true
  }

  export type SettingEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    setting_person_id?: true
    casting_item_id?: true
  }

  export type SettingEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    setting_person_id?: true
    casting_item_id?: true
    _all?: true
  }

  export type SettingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingEntry to aggregate.
     */
    where?: SettingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingEntries to fetch.
     */
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingEntries
    **/
    _count?: true | SettingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingEntryMaxAggregateInputType
  }

  export type GetSettingEntryAggregateType<T extends SettingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingEntry[P]>
      : GetScalarType<T[P], AggregateSettingEntry[P]>
  }




  export type SettingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingEntryWhereInput
    orderBy?: SettingEntryOrderByWithAggregationInput | SettingEntryOrderByWithAggregationInput[]
    by: SettingEntryScalarFieldEnum[] | SettingEntryScalarFieldEnum
    having?: SettingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingEntryCountAggregateInputType | true
    _avg?: SettingEntryAvgAggregateInputType
    _sum?: SettingEntrySumAggregateInputType
    _min?: SettingEntryMinAggregateInputType
    _max?: SettingEntryMaxAggregateInputType
  }

  export type SettingEntryGroupByOutputType = {
    id: number
    createdAt: Date
    setting_person_id: number
    casting_item_id: number
    _count: SettingEntryCountAggregateOutputType | null
    _avg: SettingEntryAvgAggregateOutputType | null
    _sum: SettingEntrySumAggregateOutputType | null
    _min: SettingEntryMinAggregateOutputType | null
    _max: SettingEntryMaxAggregateOutputType | null
  }

  type GetSettingEntryGroupByPayload<T extends SettingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], SettingEntryGroupByOutputType[P]>
        }
      >
    >


  export type SettingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    setting_person_id?: boolean
    casting_item_id?: boolean
    setting_person?: boolean | AddSettingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filingItems?: boolean | SettingEntry$filingItemsArgs<ExtArgs>
    settingTotalBalance?: boolean | SettingEntry$settingTotalBalanceArgs<ExtArgs>
    settingWastage?: boolean | SettingEntry$settingWastageArgs<ExtArgs>
    LotSettingMapper?: boolean | SettingEntry$LotSettingMapperArgs<ExtArgs>
    SettingItems?: boolean | SettingEntry$SettingItemsArgs<ExtArgs>
    _count?: boolean | SettingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingEntry"]>



  export type SettingEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    setting_person_id?: boolean
    casting_item_id?: boolean
  }

  export type SettingEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "setting_person_id" | "casting_item_id", ExtArgs["result"]["settingEntry"]>
  export type SettingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting_person?: boolean | AddSettingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filingItems?: boolean | SettingEntry$filingItemsArgs<ExtArgs>
    settingTotalBalance?: boolean | SettingEntry$settingTotalBalanceArgs<ExtArgs>
    settingWastage?: boolean | SettingEntry$settingWastageArgs<ExtArgs>
    LotSettingMapper?: boolean | SettingEntry$LotSettingMapperArgs<ExtArgs>
    SettingItems?: boolean | SettingEntry$SettingItemsArgs<ExtArgs>
    _count?: boolean | SettingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SettingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingEntry"
    objects: {
      setting_person: Prisma.$AddSettingPayload<ExtArgs>
      castingItem: Prisma.$CastingItemsPayload<ExtArgs>
      filingItems: Prisma.$FilingItemsPayload<ExtArgs>[]
      settingTotalBalance: Prisma.$SettingTotalBalancePayload<ExtArgs>[]
      settingWastage: Prisma.$SettingWastagePayload<ExtArgs>[]
      LotSettingMapper: Prisma.$LotSettingMapperPayload<ExtArgs>[]
      SettingItems: Prisma.$SettingItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      setting_person_id: number
      casting_item_id: number
    }, ExtArgs["result"]["settingEntry"]>
    composites: {}
  }

  type SettingEntryGetPayload<S extends boolean | null | undefined | SettingEntryDefaultArgs> = $Result.GetResult<Prisma.$SettingEntryPayload, S>

  type SettingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingEntryCountAggregateInputType | true
    }

  export interface SettingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingEntry'], meta: { name: 'SettingEntry' } }
    /**
     * Find zero or one SettingEntry that matches the filter.
     * @param {SettingEntryFindUniqueArgs} args - Arguments to find a SettingEntry
     * @example
     * // Get one SettingEntry
     * const settingEntry = await prisma.settingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingEntryFindUniqueArgs>(args: SelectSubset<T, SettingEntryFindUniqueArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettingEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingEntryFindUniqueOrThrowArgs} args - Arguments to find a SettingEntry
     * @example
     * // Get one SettingEntry
     * const settingEntry = await prisma.settingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryFindFirstArgs} args - Arguments to find a SettingEntry
     * @example
     * // Get one SettingEntry
     * const settingEntry = await prisma.settingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingEntryFindFirstArgs>(args?: SelectSubset<T, SettingEntryFindFirstArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryFindFirstOrThrowArgs} args - Arguments to find a SettingEntry
     * @example
     * // Get one SettingEntry
     * const settingEntry = await prisma.settingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingEntries
     * const settingEntries = await prisma.settingEntry.findMany()
     * 
     * // Get first 10 SettingEntries
     * const settingEntries = await prisma.settingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingEntryWithIdOnly = await prisma.settingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingEntryFindManyArgs>(args?: SelectSubset<T, SettingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettingEntry.
     * @param {SettingEntryCreateArgs} args - Arguments to create a SettingEntry.
     * @example
     * // Create one SettingEntry
     * const SettingEntry = await prisma.settingEntry.create({
     *   data: {
     *     // ... data to create a SettingEntry
     *   }
     * })
     * 
     */
    create<T extends SettingEntryCreateArgs>(args: SelectSubset<T, SettingEntryCreateArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettingEntries.
     * @param {SettingEntryCreateManyArgs} args - Arguments to create many SettingEntries.
     * @example
     * // Create many SettingEntries
     * const settingEntry = await prisma.settingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingEntryCreateManyArgs>(args?: SelectSubset<T, SettingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettingEntry.
     * @param {SettingEntryDeleteArgs} args - Arguments to delete one SettingEntry.
     * @example
     * // Delete one SettingEntry
     * const SettingEntry = await prisma.settingEntry.delete({
     *   where: {
     *     // ... filter to delete one SettingEntry
     *   }
     * })
     * 
     */
    delete<T extends SettingEntryDeleteArgs>(args: SelectSubset<T, SettingEntryDeleteArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettingEntry.
     * @param {SettingEntryUpdateArgs} args - Arguments to update one SettingEntry.
     * @example
     * // Update one SettingEntry
     * const settingEntry = await prisma.settingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingEntryUpdateArgs>(args: SelectSubset<T, SettingEntryUpdateArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettingEntries.
     * @param {SettingEntryDeleteManyArgs} args - Arguments to filter SettingEntries to delete.
     * @example
     * // Delete a few SettingEntries
     * const { count } = await prisma.settingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingEntryDeleteManyArgs>(args?: SelectSubset<T, SettingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingEntries
     * const settingEntry = await prisma.settingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingEntryUpdateManyArgs>(args: SelectSubset<T, SettingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingEntry.
     * @param {SettingEntryUpsertArgs} args - Arguments to update or create a SettingEntry.
     * @example
     * // Update or create a SettingEntry
     * const settingEntry = await prisma.settingEntry.upsert({
     *   create: {
     *     // ... data to create a SettingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingEntry we want to update
     *   }
     * })
     */
    upsert<T extends SettingEntryUpsertArgs>(args: SelectSubset<T, SettingEntryUpsertArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryCountArgs} args - Arguments to filter SettingEntries to count.
     * @example
     * // Count the number of SettingEntries
     * const count = await prisma.settingEntry.count({
     *   where: {
     *     // ... the filter for the SettingEntries we want to count
     *   }
     * })
    **/
    count<T extends SettingEntryCountArgs>(
      args?: Subset<T, SettingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingEntryAggregateArgs>(args: Subset<T, SettingEntryAggregateArgs>): Prisma.PrismaPromise<GetSettingEntryAggregateType<T>>

    /**
     * Group by SettingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingEntryGroupByArgs['orderBy'] }
        : { orderBy?: SettingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingEntry model
   */
  readonly fields: SettingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting_person<T extends AddSettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddSettingDefaultArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    castingItem<T extends CastingItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingItemsDefaultArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filingItems<T extends SettingEntry$filingItemsArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntry$filingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingTotalBalance<T extends SettingEntry$settingTotalBalanceArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntry$settingTotalBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingWastage<T extends SettingEntry$settingWastageArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntry$settingWastageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LotSettingMapper<T extends SettingEntry$LotSettingMapperArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntry$LotSettingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SettingItems<T extends SettingEntry$SettingItemsArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntry$SettingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingEntry model
   */
  interface SettingEntryFieldRefs {
    readonly id: FieldRef<"SettingEntry", 'Int'>
    readonly createdAt: FieldRef<"SettingEntry", 'DateTime'>
    readonly setting_person_id: FieldRef<"SettingEntry", 'Int'>
    readonly casting_item_id: FieldRef<"SettingEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SettingEntry findUnique
   */
  export type SettingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter, which SettingEntry to fetch.
     */
    where: SettingEntryWhereUniqueInput
  }

  /**
   * SettingEntry findUniqueOrThrow
   */
  export type SettingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter, which SettingEntry to fetch.
     */
    where: SettingEntryWhereUniqueInput
  }

  /**
   * SettingEntry findFirst
   */
  export type SettingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter, which SettingEntry to fetch.
     */
    where?: SettingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingEntries to fetch.
     */
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingEntries.
     */
    cursor?: SettingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingEntries.
     */
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * SettingEntry findFirstOrThrow
   */
  export type SettingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter, which SettingEntry to fetch.
     */
    where?: SettingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingEntries to fetch.
     */
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingEntries.
     */
    cursor?: SettingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingEntries.
     */
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * SettingEntry findMany
   */
  export type SettingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter, which SettingEntries to fetch.
     */
    where?: SettingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingEntries to fetch.
     */
    orderBy?: SettingEntryOrderByWithRelationInput | SettingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingEntries.
     */
    cursor?: SettingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingEntries.
     */
    skip?: number
    distinct?: SettingEntryScalarFieldEnum | SettingEntryScalarFieldEnum[]
  }

  /**
   * SettingEntry create
   */
  export type SettingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingEntry.
     */
    data: XOR<SettingEntryCreateInput, SettingEntryUncheckedCreateInput>
  }

  /**
   * SettingEntry createMany
   */
  export type SettingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingEntries.
     */
    data: SettingEntryCreateManyInput | SettingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingEntry update
   */
  export type SettingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingEntry.
     */
    data: XOR<SettingEntryUpdateInput, SettingEntryUncheckedUpdateInput>
    /**
     * Choose, which SettingEntry to update.
     */
    where: SettingEntryWhereUniqueInput
  }

  /**
   * SettingEntry updateMany
   */
  export type SettingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingEntries.
     */
    data: XOR<SettingEntryUpdateManyMutationInput, SettingEntryUncheckedUpdateManyInput>
    /**
     * Filter which SettingEntries to update
     */
    where?: SettingEntryWhereInput
    /**
     * Limit how many SettingEntries to update.
     */
    limit?: number
  }

  /**
   * SettingEntry upsert
   */
  export type SettingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingEntry to update in case it exists.
     */
    where: SettingEntryWhereUniqueInput
    /**
     * In case the SettingEntry found by the `where` argument doesn't exist, create a new SettingEntry with this data.
     */
    create: XOR<SettingEntryCreateInput, SettingEntryUncheckedCreateInput>
    /**
     * In case the SettingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingEntryUpdateInput, SettingEntryUncheckedUpdateInput>
  }

  /**
   * SettingEntry delete
   */
  export type SettingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
    /**
     * Filter which SettingEntry to delete.
     */
    where: SettingEntryWhereUniqueInput
  }

  /**
   * SettingEntry deleteMany
   */
  export type SettingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingEntries to delete
     */
    where?: SettingEntryWhereInput
    /**
     * Limit how many SettingEntries to delete.
     */
    limit?: number
  }

  /**
   * SettingEntry.filingItems
   */
  export type SettingEntry$filingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * SettingEntry.settingTotalBalance
   */
  export type SettingEntry$settingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    where?: SettingTotalBalanceWhereInput
    orderBy?: SettingTotalBalanceOrderByWithRelationInput | SettingTotalBalanceOrderByWithRelationInput[]
    cursor?: SettingTotalBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingTotalBalanceScalarFieldEnum | SettingTotalBalanceScalarFieldEnum[]
  }

  /**
   * SettingEntry.settingWastage
   */
  export type SettingEntry$settingWastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    where?: SettingWastageWhereInput
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    cursor?: SettingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingWastageScalarFieldEnum | SettingWastageScalarFieldEnum[]
  }

  /**
   * SettingEntry.LotSettingMapper
   */
  export type SettingEntry$LotSettingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    where?: LotSettingMapperWhereInput
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    cursor?: LotSettingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * SettingEntry.SettingItems
   */
  export type SettingEntry$SettingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    cursor?: SettingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * SettingEntry without action
   */
  export type SettingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingEntry
     */
    select?: SettingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingEntry
     */
    omit?: SettingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingEntryInclude<ExtArgs> | null
  }


  /**
   * Model SettingItems
   */

  export type AggregateSettingItems = {
    _count: SettingItemsCountAggregateOutputType | null
    _avg: SettingItemsAvgAggregateOutputType | null
    _sum: SettingItemsSumAggregateOutputType | null
    _min: SettingItemsMinAggregateOutputType | null
    _max: SettingItemsMaxAggregateOutputType | null
  }

  export type SettingItemsAvgAggregateOutputType = {
    id: number | null
    setting_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    setting_entry_id: number | null
  }

  export type SettingItemsSumAggregateOutputType = {
    id: number | null
    setting_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    setting_entry_id: number | null
  }

  export type SettingItemsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    scrap_remarks: string | null
    setting_entry_id: number | null
  }

  export type SettingItemsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    scrap_remarks: string | null
    setting_entry_id: number | null
  }

  export type SettingItemsCountAggregateOutputType = {
    id: number
    createdAt: number
    type: number
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks: number
    setting_entry_id: number
    _all: number
  }


  export type SettingItemsAvgAggregateInputType = {
    id?: true
    setting_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    setting_entry_id?: true
  }

  export type SettingItemsSumAggregateInputType = {
    id?: true
    setting_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    setting_entry_id?: true
  }

  export type SettingItemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    setting_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    setting_entry_id?: true
  }

  export type SettingItemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    setting_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    setting_entry_id?: true
  }

  export type SettingItemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    setting_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    setting_entry_id?: true
    _all?: true
  }

  export type SettingItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingItems to aggregate.
     */
    where?: SettingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingItems to fetch.
     */
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingItems
    **/
    _count?: true | SettingItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingItemsMaxAggregateInputType
  }

  export type GetSettingItemsAggregateType<T extends SettingItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingItems[P]>
      : GetScalarType<T[P], AggregateSettingItems[P]>
  }




  export type SettingItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithAggregationInput | SettingItemsOrderByWithAggregationInput[]
    by: SettingItemsScalarFieldEnum[] | SettingItemsScalarFieldEnum
    having?: SettingItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingItemsCountAggregateInputType | true
    _avg?: SettingItemsAvgAggregateInputType
    _sum?: SettingItemsSumAggregateInputType
    _min?: SettingItemsMinAggregateInputType
    _max?: SettingItemsMaxAggregateInputType
  }

  export type SettingItemsGroupByOutputType = {
    id: number
    createdAt: Date
    type: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks: string | null
    setting_entry_id: number
    _count: SettingItemsCountAggregateOutputType | null
    _avg: SettingItemsAvgAggregateOutputType | null
    _sum: SettingItemsSumAggregateOutputType | null
    _min: SettingItemsMinAggregateOutputType | null
    _max: SettingItemsMaxAggregateOutputType | null
  }

  type GetSettingItemsGroupByPayload<T extends SettingItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingItemsGroupByOutputType[P]>
        }
      >
    >


  export type SettingItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    setting_item_id?: boolean
    scrap_weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    scrap_remarks?: boolean
    setting_entry_id?: boolean
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    setting_wastage?: boolean | SettingItems$setting_wastageArgs<ExtArgs>
    buffing_entry?: boolean | SettingItems$buffing_entryArgs<ExtArgs>
    stock?: boolean | SettingItems$stockArgs<ExtArgs>
    LotBuffingMapper?: boolean | SettingItems$LotBuffingMapperArgs<ExtArgs>
    settingEntryId?: boolean | SettingEntryDefaultArgs<ExtArgs>
    _count?: boolean | SettingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingItems"]>



  export type SettingItemsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    type?: boolean
    setting_item_id?: boolean
    scrap_weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    scrap_remarks?: boolean
    setting_entry_id?: boolean
  }

  export type SettingItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "type" | "setting_item_id" | "scrap_weight" | "touch_id" | "item_purity" | "scrap_remarks" | "setting_entry_id", ExtArgs["result"]["settingItems"]>
  export type SettingItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    setting_wastage?: boolean | SettingItems$setting_wastageArgs<ExtArgs>
    buffing_entry?: boolean | SettingItems$buffing_entryArgs<ExtArgs>
    stock?: boolean | SettingItems$stockArgs<ExtArgs>
    LotBuffingMapper?: boolean | SettingItems$LotBuffingMapperArgs<ExtArgs>
    settingEntryId?: boolean | SettingEntryDefaultArgs<ExtArgs>
    _count?: boolean | SettingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SettingItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingItems"
    objects: {
      item: Prisma.$AddItemPayload<ExtArgs>
      touch: Prisma.$AddTouchPayload<ExtArgs>
      setting_wastage: Prisma.$SettingWastagePayload<ExtArgs>[]
      buffing_entry: Prisma.$BuffingEntryPayload<ExtArgs>[]
      stock: Prisma.$StockPayload<ExtArgs>[]
      LotBuffingMapper: Prisma.$LotBuffingMapperPayload<ExtArgs>[]
      settingEntryId: Prisma.$SettingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      type: $Enums.CASTINGENTRYTYPE | null
      setting_item_id: number
      scrap_weight: number
      touch_id: number
      item_purity: number
      scrap_remarks: string | null
      setting_entry_id: number
    }, ExtArgs["result"]["settingItems"]>
    composites: {}
  }

  type SettingItemsGetPayload<S extends boolean | null | undefined | SettingItemsDefaultArgs> = $Result.GetResult<Prisma.$SettingItemsPayload, S>

  type SettingItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingItemsCountAggregateInputType | true
    }

  export interface SettingItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingItems'], meta: { name: 'SettingItems' } }
    /**
     * Find zero or one SettingItems that matches the filter.
     * @param {SettingItemsFindUniqueArgs} args - Arguments to find a SettingItems
     * @example
     * // Get one SettingItems
     * const settingItems = await prisma.settingItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingItemsFindUniqueArgs>(args: SelectSubset<T, SettingItemsFindUniqueArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettingItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingItemsFindUniqueOrThrowArgs} args - Arguments to find a SettingItems
     * @example
     * // Get one SettingItems
     * const settingItems = await prisma.settingItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsFindFirstArgs} args - Arguments to find a SettingItems
     * @example
     * // Get one SettingItems
     * const settingItems = await prisma.settingItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingItemsFindFirstArgs>(args?: SelectSubset<T, SettingItemsFindFirstArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsFindFirstOrThrowArgs} args - Arguments to find a SettingItems
     * @example
     * // Get one SettingItems
     * const settingItems = await prisma.settingItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingItems
     * const settingItems = await prisma.settingItems.findMany()
     * 
     * // Get first 10 SettingItems
     * const settingItems = await prisma.settingItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingItemsWithIdOnly = await prisma.settingItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingItemsFindManyArgs>(args?: SelectSubset<T, SettingItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettingItems.
     * @param {SettingItemsCreateArgs} args - Arguments to create a SettingItems.
     * @example
     * // Create one SettingItems
     * const SettingItems = await prisma.settingItems.create({
     *   data: {
     *     // ... data to create a SettingItems
     *   }
     * })
     * 
     */
    create<T extends SettingItemsCreateArgs>(args: SelectSubset<T, SettingItemsCreateArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettingItems.
     * @param {SettingItemsCreateManyArgs} args - Arguments to create many SettingItems.
     * @example
     * // Create many SettingItems
     * const settingItems = await prisma.settingItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingItemsCreateManyArgs>(args?: SelectSubset<T, SettingItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettingItems.
     * @param {SettingItemsDeleteArgs} args - Arguments to delete one SettingItems.
     * @example
     * // Delete one SettingItems
     * const SettingItems = await prisma.settingItems.delete({
     *   where: {
     *     // ... filter to delete one SettingItems
     *   }
     * })
     * 
     */
    delete<T extends SettingItemsDeleteArgs>(args: SelectSubset<T, SettingItemsDeleteArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettingItems.
     * @param {SettingItemsUpdateArgs} args - Arguments to update one SettingItems.
     * @example
     * // Update one SettingItems
     * const settingItems = await prisma.settingItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingItemsUpdateArgs>(args: SelectSubset<T, SettingItemsUpdateArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettingItems.
     * @param {SettingItemsDeleteManyArgs} args - Arguments to filter SettingItems to delete.
     * @example
     * // Delete a few SettingItems
     * const { count } = await prisma.settingItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingItemsDeleteManyArgs>(args?: SelectSubset<T, SettingItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingItems
     * const settingItems = await prisma.settingItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingItemsUpdateManyArgs>(args: SelectSubset<T, SettingItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingItems.
     * @param {SettingItemsUpsertArgs} args - Arguments to update or create a SettingItems.
     * @example
     * // Update or create a SettingItems
     * const settingItems = await prisma.settingItems.upsert({
     *   create: {
     *     // ... data to create a SettingItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingItems we want to update
     *   }
     * })
     */
    upsert<T extends SettingItemsUpsertArgs>(args: SelectSubset<T, SettingItemsUpsertArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsCountArgs} args - Arguments to filter SettingItems to count.
     * @example
     * // Count the number of SettingItems
     * const count = await prisma.settingItems.count({
     *   where: {
     *     // ... the filter for the SettingItems we want to count
     *   }
     * })
    **/
    count<T extends SettingItemsCountArgs>(
      args?: Subset<T, SettingItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingItemsAggregateArgs>(args: Subset<T, SettingItemsAggregateArgs>): Prisma.PrismaPromise<GetSettingItemsAggregateType<T>>

    /**
     * Group by SettingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingItemsGroupByArgs['orderBy'] }
        : { orderBy?: SettingItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingItems model
   */
  readonly fields: SettingItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends AddItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddItemDefaultArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    setting_wastage<T extends SettingItems$setting_wastageArgs<ExtArgs> = {}>(args?: Subset<T, SettingItems$setting_wastageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffing_entry<T extends SettingItems$buffing_entryArgs<ExtArgs> = {}>(args?: Subset<T, SettingItems$buffing_entryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stock<T extends SettingItems$stockArgs<ExtArgs> = {}>(args?: Subset<T, SettingItems$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LotBuffingMapper<T extends SettingItems$LotBuffingMapperArgs<ExtArgs> = {}>(args?: Subset<T, SettingItems$LotBuffingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settingEntryId<T extends SettingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntryDefaultArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingItems model
   */
  interface SettingItemsFieldRefs {
    readonly id: FieldRef<"SettingItems", 'Int'>
    readonly createdAt: FieldRef<"SettingItems", 'DateTime'>
    readonly type: FieldRef<"SettingItems", 'CASTINGENTRYTYPE'>
    readonly setting_item_id: FieldRef<"SettingItems", 'Int'>
    readonly scrap_weight: FieldRef<"SettingItems", 'Float'>
    readonly touch_id: FieldRef<"SettingItems", 'Int'>
    readonly item_purity: FieldRef<"SettingItems", 'Float'>
    readonly scrap_remarks: FieldRef<"SettingItems", 'String'>
    readonly setting_entry_id: FieldRef<"SettingItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SettingItems findUnique
   */
  export type SettingItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter, which SettingItems to fetch.
     */
    where: SettingItemsWhereUniqueInput
  }

  /**
   * SettingItems findUniqueOrThrow
   */
  export type SettingItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter, which SettingItems to fetch.
     */
    where: SettingItemsWhereUniqueInput
  }

  /**
   * SettingItems findFirst
   */
  export type SettingItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter, which SettingItems to fetch.
     */
    where?: SettingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingItems to fetch.
     */
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingItems.
     */
    cursor?: SettingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingItems.
     */
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * SettingItems findFirstOrThrow
   */
  export type SettingItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter, which SettingItems to fetch.
     */
    where?: SettingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingItems to fetch.
     */
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingItems.
     */
    cursor?: SettingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingItems.
     */
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * SettingItems findMany
   */
  export type SettingItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter, which SettingItems to fetch.
     */
    where?: SettingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingItems to fetch.
     */
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingItems.
     */
    cursor?: SettingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingItems.
     */
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * SettingItems create
   */
  export type SettingItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingItems.
     */
    data: XOR<SettingItemsCreateInput, SettingItemsUncheckedCreateInput>
  }

  /**
   * SettingItems createMany
   */
  export type SettingItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingItems.
     */
    data: SettingItemsCreateManyInput | SettingItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingItems update
   */
  export type SettingItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingItems.
     */
    data: XOR<SettingItemsUpdateInput, SettingItemsUncheckedUpdateInput>
    /**
     * Choose, which SettingItems to update.
     */
    where: SettingItemsWhereUniqueInput
  }

  /**
   * SettingItems updateMany
   */
  export type SettingItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingItems.
     */
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyInput>
    /**
     * Filter which SettingItems to update
     */
    where?: SettingItemsWhereInput
    /**
     * Limit how many SettingItems to update.
     */
    limit?: number
  }

  /**
   * SettingItems upsert
   */
  export type SettingItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingItems to update in case it exists.
     */
    where: SettingItemsWhereUniqueInput
    /**
     * In case the SettingItems found by the `where` argument doesn't exist, create a new SettingItems with this data.
     */
    create: XOR<SettingItemsCreateInput, SettingItemsUncheckedCreateInput>
    /**
     * In case the SettingItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingItemsUpdateInput, SettingItemsUncheckedUpdateInput>
  }

  /**
   * SettingItems delete
   */
  export type SettingItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    /**
     * Filter which SettingItems to delete.
     */
    where: SettingItemsWhereUniqueInput
  }

  /**
   * SettingItems deleteMany
   */
  export type SettingItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingItems to delete
     */
    where?: SettingItemsWhereInput
    /**
     * Limit how many SettingItems to delete.
     */
    limit?: number
  }

  /**
   * SettingItems.setting_wastage
   */
  export type SettingItems$setting_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    where?: SettingWastageWhereInput
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    cursor?: SettingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingWastageScalarFieldEnum | SettingWastageScalarFieldEnum[]
  }

  /**
   * SettingItems.buffing_entry
   */
  export type SettingItems$buffing_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    where?: BuffingEntryWhereInput
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    cursor?: BuffingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * SettingItems.stock
   */
  export type SettingItems$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * SettingItems.LotBuffingMapper
   */
  export type SettingItems$LotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    cursor?: LotBuffingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * SettingItems without action
   */
  export type SettingItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
  }


  /**
   * Model LotSettingMapper
   */

  export type AggregateLotSettingMapper = {
    _count: LotSettingMapperCountAggregateOutputType | null
    _avg: LotSettingMapperAvgAggregateOutputType | null
    _sum: LotSettingMapperSumAggregateOutputType | null
    _min: LotSettingMapperMinAggregateOutputType | null
    _max: LotSettingMapperMaxAggregateOutputType | null
  }

  export type LotSettingMapperAvgAggregateOutputType = {
    id: number | null
    setting_id: number | null
    lot_id: number | null
    filing_item_id: number | null
    setting_entry_id: number | null
  }

  export type LotSettingMapperSumAggregateOutputType = {
    id: number | null
    setting_id: number | null
    lot_id: number | null
    filing_item_id: number | null
    setting_entry_id: number | null
  }

  export type LotSettingMapperMinAggregateOutputType = {
    id: number | null
    setting_id: number | null
    lot_id: number | null
    filing_item_id: number | null
    setting_entry_id: number | null
  }

  export type LotSettingMapperMaxAggregateOutputType = {
    id: number | null
    setting_id: number | null
    lot_id: number | null
    filing_item_id: number | null
    setting_entry_id: number | null
  }

  export type LotSettingMapperCountAggregateOutputType = {
    id: number
    setting_id: number
    lot_id: number
    filing_item_id: number
    setting_entry_id: number
    _all: number
  }


  export type LotSettingMapperAvgAggregateInputType = {
    id?: true
    setting_id?: true
    lot_id?: true
    filing_item_id?: true
    setting_entry_id?: true
  }

  export type LotSettingMapperSumAggregateInputType = {
    id?: true
    setting_id?: true
    lot_id?: true
    filing_item_id?: true
    setting_entry_id?: true
  }

  export type LotSettingMapperMinAggregateInputType = {
    id?: true
    setting_id?: true
    lot_id?: true
    filing_item_id?: true
    setting_entry_id?: true
  }

  export type LotSettingMapperMaxAggregateInputType = {
    id?: true
    setting_id?: true
    lot_id?: true
    filing_item_id?: true
    setting_entry_id?: true
  }

  export type LotSettingMapperCountAggregateInputType = {
    id?: true
    setting_id?: true
    lot_id?: true
    filing_item_id?: true
    setting_entry_id?: true
    _all?: true
  }

  export type LotSettingMapperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotSettingMapper to aggregate.
     */
    where?: LotSettingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotSettingMappers to fetch.
     */
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotSettingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotSettingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotSettingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotSettingMappers
    **/
    _count?: true | LotSettingMapperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotSettingMapperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotSettingMapperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotSettingMapperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotSettingMapperMaxAggregateInputType
  }

  export type GetLotSettingMapperAggregateType<T extends LotSettingMapperAggregateArgs> = {
        [P in keyof T & keyof AggregateLotSettingMapper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotSettingMapper[P]>
      : GetScalarType<T[P], AggregateLotSettingMapper[P]>
  }




  export type LotSettingMapperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotSettingMapperWhereInput
    orderBy?: LotSettingMapperOrderByWithAggregationInput | LotSettingMapperOrderByWithAggregationInput[]
    by: LotSettingMapperScalarFieldEnum[] | LotSettingMapperScalarFieldEnum
    having?: LotSettingMapperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotSettingMapperCountAggregateInputType | true
    _avg?: LotSettingMapperAvgAggregateInputType
    _sum?: LotSettingMapperSumAggregateInputType
    _min?: LotSettingMapperMinAggregateInputType
    _max?: LotSettingMapperMaxAggregateInputType
  }

  export type LotSettingMapperGroupByOutputType = {
    id: number
    setting_id: number
    lot_id: number
    filing_item_id: number | null
    setting_entry_id: number
    _count: LotSettingMapperCountAggregateOutputType | null
    _avg: LotSettingMapperAvgAggregateOutputType | null
    _sum: LotSettingMapperSumAggregateOutputType | null
    _min: LotSettingMapperMinAggregateOutputType | null
    _max: LotSettingMapperMaxAggregateOutputType | null
  }

  type GetLotSettingMapperGroupByPayload<T extends LotSettingMapperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotSettingMapperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotSettingMapperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotSettingMapperGroupByOutputType[P]>
            : GetScalarType<T[P], LotSettingMapperGroupByOutputType[P]>
        }
      >
    >


  export type LotSettingMapperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setting_id?: boolean
    lot_id?: boolean
    filing_item_id?: boolean
    setting_entry_id?: boolean
    settingId?: boolean | AddSettingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    itemId?: boolean | LotSettingMapper$itemIdArgs<ExtArgs>
    settingEntry?: boolean | SettingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotSettingMapper"]>



  export type LotSettingMapperSelectScalar = {
    id?: boolean
    setting_id?: boolean
    lot_id?: boolean
    filing_item_id?: boolean
    setting_entry_id?: boolean
  }

  export type LotSettingMapperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "setting_id" | "lot_id" | "filing_item_id" | "setting_entry_id", ExtArgs["result"]["lotSettingMapper"]>
  export type LotSettingMapperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settingId?: boolean | AddSettingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    itemId?: boolean | LotSettingMapper$itemIdArgs<ExtArgs>
    settingEntry?: boolean | SettingEntryDefaultArgs<ExtArgs>
  }

  export type $LotSettingMapperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotSettingMapper"
    objects: {
      settingId: Prisma.$AddSettingPayload<ExtArgs>
      lotId: Prisma.$LotInfoPayload<ExtArgs>
      itemId: Prisma.$FilingItemsPayload<ExtArgs> | null
      settingEntry: Prisma.$SettingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      setting_id: number
      lot_id: number
      filing_item_id: number | null
      setting_entry_id: number
    }, ExtArgs["result"]["lotSettingMapper"]>
    composites: {}
  }

  type LotSettingMapperGetPayload<S extends boolean | null | undefined | LotSettingMapperDefaultArgs> = $Result.GetResult<Prisma.$LotSettingMapperPayload, S>

  type LotSettingMapperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LotSettingMapperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LotSettingMapperCountAggregateInputType | true
    }

  export interface LotSettingMapperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotSettingMapper'], meta: { name: 'LotSettingMapper' } }
    /**
     * Find zero or one LotSettingMapper that matches the filter.
     * @param {LotSettingMapperFindUniqueArgs} args - Arguments to find a LotSettingMapper
     * @example
     * // Get one LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotSettingMapperFindUniqueArgs>(args: SelectSubset<T, LotSettingMapperFindUniqueArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LotSettingMapper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LotSettingMapperFindUniqueOrThrowArgs} args - Arguments to find a LotSettingMapper
     * @example
     * // Get one LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotSettingMapperFindUniqueOrThrowArgs>(args: SelectSubset<T, LotSettingMapperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotSettingMapper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperFindFirstArgs} args - Arguments to find a LotSettingMapper
     * @example
     * // Get one LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotSettingMapperFindFirstArgs>(args?: SelectSubset<T, LotSettingMapperFindFirstArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotSettingMapper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperFindFirstOrThrowArgs} args - Arguments to find a LotSettingMapper
     * @example
     * // Get one LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotSettingMapperFindFirstOrThrowArgs>(args?: SelectSubset<T, LotSettingMapperFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LotSettingMappers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotSettingMappers
     * const lotSettingMappers = await prisma.lotSettingMapper.findMany()
     * 
     * // Get first 10 LotSettingMappers
     * const lotSettingMappers = await prisma.lotSettingMapper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotSettingMapperWithIdOnly = await prisma.lotSettingMapper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotSettingMapperFindManyArgs>(args?: SelectSubset<T, LotSettingMapperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LotSettingMapper.
     * @param {LotSettingMapperCreateArgs} args - Arguments to create a LotSettingMapper.
     * @example
     * // Create one LotSettingMapper
     * const LotSettingMapper = await prisma.lotSettingMapper.create({
     *   data: {
     *     // ... data to create a LotSettingMapper
     *   }
     * })
     * 
     */
    create<T extends LotSettingMapperCreateArgs>(args: SelectSubset<T, LotSettingMapperCreateArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LotSettingMappers.
     * @param {LotSettingMapperCreateManyArgs} args - Arguments to create many LotSettingMappers.
     * @example
     * // Create many LotSettingMappers
     * const lotSettingMapper = await prisma.lotSettingMapper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotSettingMapperCreateManyArgs>(args?: SelectSubset<T, LotSettingMapperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LotSettingMapper.
     * @param {LotSettingMapperDeleteArgs} args - Arguments to delete one LotSettingMapper.
     * @example
     * // Delete one LotSettingMapper
     * const LotSettingMapper = await prisma.lotSettingMapper.delete({
     *   where: {
     *     // ... filter to delete one LotSettingMapper
     *   }
     * })
     * 
     */
    delete<T extends LotSettingMapperDeleteArgs>(args: SelectSubset<T, LotSettingMapperDeleteArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LotSettingMapper.
     * @param {LotSettingMapperUpdateArgs} args - Arguments to update one LotSettingMapper.
     * @example
     * // Update one LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotSettingMapperUpdateArgs>(args: SelectSubset<T, LotSettingMapperUpdateArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LotSettingMappers.
     * @param {LotSettingMapperDeleteManyArgs} args - Arguments to filter LotSettingMappers to delete.
     * @example
     * // Delete a few LotSettingMappers
     * const { count } = await prisma.lotSettingMapper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotSettingMapperDeleteManyArgs>(args?: SelectSubset<T, LotSettingMapperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotSettingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotSettingMappers
     * const lotSettingMapper = await prisma.lotSettingMapper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotSettingMapperUpdateManyArgs>(args: SelectSubset<T, LotSettingMapperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotSettingMapper.
     * @param {LotSettingMapperUpsertArgs} args - Arguments to update or create a LotSettingMapper.
     * @example
     * // Update or create a LotSettingMapper
     * const lotSettingMapper = await prisma.lotSettingMapper.upsert({
     *   create: {
     *     // ... data to create a LotSettingMapper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotSettingMapper we want to update
     *   }
     * })
     */
    upsert<T extends LotSettingMapperUpsertArgs>(args: SelectSubset<T, LotSettingMapperUpsertArgs<ExtArgs>>): Prisma__LotSettingMapperClient<$Result.GetResult<Prisma.$LotSettingMapperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LotSettingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperCountArgs} args - Arguments to filter LotSettingMappers to count.
     * @example
     * // Count the number of LotSettingMappers
     * const count = await prisma.lotSettingMapper.count({
     *   where: {
     *     // ... the filter for the LotSettingMappers we want to count
     *   }
     * })
    **/
    count<T extends LotSettingMapperCountArgs>(
      args?: Subset<T, LotSettingMapperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotSettingMapperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotSettingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotSettingMapperAggregateArgs>(args: Subset<T, LotSettingMapperAggregateArgs>): Prisma.PrismaPromise<GetLotSettingMapperAggregateType<T>>

    /**
     * Group by LotSettingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotSettingMapperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotSettingMapperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotSettingMapperGroupByArgs['orderBy'] }
        : { orderBy?: LotSettingMapperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotSettingMapperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotSettingMapperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotSettingMapper model
   */
  readonly fields: LotSettingMapperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotSettingMapper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotSettingMapperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settingId<T extends AddSettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddSettingDefaultArgs<ExtArgs>>): Prisma__AddSettingClient<$Result.GetResult<Prisma.$AddSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lotId<T extends LotInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotInfoDefaultArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemId<T extends LotSettingMapper$itemIdArgs<ExtArgs> = {}>(args?: Subset<T, LotSettingMapper$itemIdArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settingEntry<T extends SettingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntryDefaultArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotSettingMapper model
   */
  interface LotSettingMapperFieldRefs {
    readonly id: FieldRef<"LotSettingMapper", 'Int'>
    readonly setting_id: FieldRef<"LotSettingMapper", 'Int'>
    readonly lot_id: FieldRef<"LotSettingMapper", 'Int'>
    readonly filing_item_id: FieldRef<"LotSettingMapper", 'Int'>
    readonly setting_entry_id: FieldRef<"LotSettingMapper", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LotSettingMapper findUnique
   */
  export type LotSettingMapperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotSettingMapper to fetch.
     */
    where: LotSettingMapperWhereUniqueInput
  }

  /**
   * LotSettingMapper findUniqueOrThrow
   */
  export type LotSettingMapperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotSettingMapper to fetch.
     */
    where: LotSettingMapperWhereUniqueInput
  }

  /**
   * LotSettingMapper findFirst
   */
  export type LotSettingMapperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotSettingMapper to fetch.
     */
    where?: LotSettingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotSettingMappers to fetch.
     */
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotSettingMappers.
     */
    cursor?: LotSettingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotSettingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotSettingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotSettingMappers.
     */
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * LotSettingMapper findFirstOrThrow
   */
  export type LotSettingMapperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotSettingMapper to fetch.
     */
    where?: LotSettingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotSettingMappers to fetch.
     */
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotSettingMappers.
     */
    cursor?: LotSettingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotSettingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotSettingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotSettingMappers.
     */
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * LotSettingMapper findMany
   */
  export type LotSettingMapperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotSettingMappers to fetch.
     */
    where?: LotSettingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotSettingMappers to fetch.
     */
    orderBy?: LotSettingMapperOrderByWithRelationInput | LotSettingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotSettingMappers.
     */
    cursor?: LotSettingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotSettingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotSettingMappers.
     */
    skip?: number
    distinct?: LotSettingMapperScalarFieldEnum | LotSettingMapperScalarFieldEnum[]
  }

  /**
   * LotSettingMapper create
   */
  export type LotSettingMapperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * The data needed to create a LotSettingMapper.
     */
    data: XOR<LotSettingMapperCreateInput, LotSettingMapperUncheckedCreateInput>
  }

  /**
   * LotSettingMapper createMany
   */
  export type LotSettingMapperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotSettingMappers.
     */
    data: LotSettingMapperCreateManyInput | LotSettingMapperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotSettingMapper update
   */
  export type LotSettingMapperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * The data needed to update a LotSettingMapper.
     */
    data: XOR<LotSettingMapperUpdateInput, LotSettingMapperUncheckedUpdateInput>
    /**
     * Choose, which LotSettingMapper to update.
     */
    where: LotSettingMapperWhereUniqueInput
  }

  /**
   * LotSettingMapper updateMany
   */
  export type LotSettingMapperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotSettingMappers.
     */
    data: XOR<LotSettingMapperUpdateManyMutationInput, LotSettingMapperUncheckedUpdateManyInput>
    /**
     * Filter which LotSettingMappers to update
     */
    where?: LotSettingMapperWhereInput
    /**
     * Limit how many LotSettingMappers to update.
     */
    limit?: number
  }

  /**
   * LotSettingMapper upsert
   */
  export type LotSettingMapperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * The filter to search for the LotSettingMapper to update in case it exists.
     */
    where: LotSettingMapperWhereUniqueInput
    /**
     * In case the LotSettingMapper found by the `where` argument doesn't exist, create a new LotSettingMapper with this data.
     */
    create: XOR<LotSettingMapperCreateInput, LotSettingMapperUncheckedCreateInput>
    /**
     * In case the LotSettingMapper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotSettingMapperUpdateInput, LotSettingMapperUncheckedUpdateInput>
  }

  /**
   * LotSettingMapper delete
   */
  export type LotSettingMapperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
    /**
     * Filter which LotSettingMapper to delete.
     */
    where: LotSettingMapperWhereUniqueInput
  }

  /**
   * LotSettingMapper deleteMany
   */
  export type LotSettingMapperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotSettingMappers to delete
     */
    where?: LotSettingMapperWhereInput
    /**
     * Limit how many LotSettingMappers to delete.
     */
    limit?: number
  }

  /**
   * LotSettingMapper.itemId
   */
  export type LotSettingMapper$itemIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
  }

  /**
   * LotSettingMapper without action
   */
  export type LotSettingMapperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotSettingMapper
     */
    select?: LotSettingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotSettingMapper
     */
    omit?: LotSettingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotSettingMapperInclude<ExtArgs> | null
  }


  /**
   * Model SettingTotalBalance
   */

  export type AggregateSettingTotalBalance = {
    _count: SettingTotalBalanceCountAggregateOutputType | null
    _avg: SettingTotalBalanceAvgAggregateOutputType | null
    _sum: SettingTotalBalanceSumAggregateOutputType | null
    _min: SettingTotalBalanceMinAggregateOutputType | null
    _max: SettingTotalBalanceMaxAggregateOutputType | null
  }

  export type SettingTotalBalanceAvgAggregateOutputType = {
    id: number | null
    receipt_weight: number | null
    stone_count: number | null
    stone_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    setting_entry_id: number | null
  }

  export type SettingTotalBalanceSumAggregateOutputType = {
    id: number | null
    receipt_weight: number | null
    stone_count: number | null
    stone_weight: number | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    setting_entry_id: number | null
  }

  export type SettingTotalBalanceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    receipt_weight: number | null
    stone_count: number | null
    stone_weight: number | null
    remarks: string | null
    wastage: boolean | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    setting_entry_id: number | null
  }

  export type SettingTotalBalanceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    receipt_weight: number | null
    stone_count: number | null
    stone_weight: number | null
    remarks: string | null
    wastage: boolean | null
    total_product_weight: number | null
    current_balance_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    setting_entry_id: number | null
  }

  export type SettingTotalBalanceCountAggregateOutputType = {
    id: number
    createdAt: number
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks: number
    wastage: number
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight: number
    balance: number
    setting_entry_id: number
    _all: number
  }


  export type SettingTotalBalanceAvgAggregateInputType = {
    id?: true
    receipt_weight?: true
    stone_count?: true
    stone_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    setting_entry_id?: true
  }

  export type SettingTotalBalanceSumAggregateInputType = {
    id?: true
    receipt_weight?: true
    stone_count?: true
    stone_weight?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    setting_entry_id?: true
  }

  export type SettingTotalBalanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    stone_count?: true
    stone_weight?: true
    remarks?: true
    wastage?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    setting_entry_id?: true
  }

  export type SettingTotalBalanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    stone_count?: true
    stone_weight?: true
    remarks?: true
    wastage?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    setting_entry_id?: true
  }

  export type SettingTotalBalanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    stone_count?: true
    stone_weight?: true
    remarks?: true
    wastage?: true
    total_product_weight?: true
    current_balance_weight?: true
    total_scrap_weight?: true
    balance?: true
    setting_entry_id?: true
    _all?: true
  }

  export type SettingTotalBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingTotalBalance to aggregate.
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTotalBalances to fetch.
     */
    orderBy?: SettingTotalBalanceOrderByWithRelationInput | SettingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingTotalBalances
    **/
    _count?: true | SettingTotalBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingTotalBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingTotalBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingTotalBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingTotalBalanceMaxAggregateInputType
  }

  export type GetSettingTotalBalanceAggregateType<T extends SettingTotalBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingTotalBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingTotalBalance[P]>
      : GetScalarType<T[P], AggregateSettingTotalBalance[P]>
  }




  export type SettingTotalBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingTotalBalanceWhereInput
    orderBy?: SettingTotalBalanceOrderByWithAggregationInput | SettingTotalBalanceOrderByWithAggregationInput[]
    by: SettingTotalBalanceScalarFieldEnum[] | SettingTotalBalanceScalarFieldEnum
    having?: SettingTotalBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingTotalBalanceCountAggregateInputType | true
    _avg?: SettingTotalBalanceAvgAggregateInputType
    _sum?: SettingTotalBalanceSumAggregateInputType
    _min?: SettingTotalBalanceMinAggregateInputType
    _max?: SettingTotalBalanceMaxAggregateInputType
  }

  export type SettingTotalBalanceGroupByOutputType = {
    id: number
    createdAt: Date
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight: number | null
    balance: number | null
    setting_entry_id: number
    _count: SettingTotalBalanceCountAggregateOutputType | null
    _avg: SettingTotalBalanceAvgAggregateOutputType | null
    _sum: SettingTotalBalanceSumAggregateOutputType | null
    _min: SettingTotalBalanceMinAggregateOutputType | null
    _max: SettingTotalBalanceMaxAggregateOutputType | null
  }

  type GetSettingTotalBalanceGroupByPayload<T extends SettingTotalBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingTotalBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingTotalBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingTotalBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], SettingTotalBalanceGroupByOutputType[P]>
        }
      >
    >


  export type SettingTotalBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    receipt_weight?: boolean
    stone_count?: boolean
    stone_weight?: boolean
    remarks?: boolean
    wastage?: boolean
    total_product_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    balance?: boolean
    setting_entry_id?: boolean
    setting_entry?: boolean | SettingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingTotalBalance"]>



  export type SettingTotalBalanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    receipt_weight?: boolean
    stone_count?: boolean
    stone_weight?: boolean
    remarks?: boolean
    wastage?: boolean
    total_product_weight?: boolean
    current_balance_weight?: boolean
    total_scrap_weight?: boolean
    balance?: boolean
    setting_entry_id?: boolean
  }

  export type SettingTotalBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "receipt_weight" | "stone_count" | "stone_weight" | "remarks" | "wastage" | "total_product_weight" | "current_balance_weight" | "total_scrap_weight" | "balance" | "setting_entry_id", ExtArgs["result"]["settingTotalBalance"]>
  export type SettingTotalBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting_entry?: boolean | SettingEntryDefaultArgs<ExtArgs>
  }

  export type $SettingTotalBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingTotalBalance"
    objects: {
      setting_entry: Prisma.$SettingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      receipt_weight: number
      stone_count: number
      stone_weight: number
      remarks: string | null
      wastage: boolean
      total_product_weight: number
      current_balance_weight: number
      total_scrap_weight: number | null
      balance: number | null
      setting_entry_id: number
    }, ExtArgs["result"]["settingTotalBalance"]>
    composites: {}
  }

  type SettingTotalBalanceGetPayload<S extends boolean | null | undefined | SettingTotalBalanceDefaultArgs> = $Result.GetResult<Prisma.$SettingTotalBalancePayload, S>

  type SettingTotalBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingTotalBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingTotalBalanceCountAggregateInputType | true
    }

  export interface SettingTotalBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingTotalBalance'], meta: { name: 'SettingTotalBalance' } }
    /**
     * Find zero or one SettingTotalBalance that matches the filter.
     * @param {SettingTotalBalanceFindUniqueArgs} args - Arguments to find a SettingTotalBalance
     * @example
     * // Get one SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingTotalBalanceFindUniqueArgs>(args: SelectSubset<T, SettingTotalBalanceFindUniqueArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettingTotalBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingTotalBalanceFindUniqueOrThrowArgs} args - Arguments to find a SettingTotalBalance
     * @example
     * // Get one SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingTotalBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingTotalBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceFindFirstArgs} args - Arguments to find a SettingTotalBalance
     * @example
     * // Get one SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingTotalBalanceFindFirstArgs>(args?: SelectSubset<T, SettingTotalBalanceFindFirstArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingTotalBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceFindFirstOrThrowArgs} args - Arguments to find a SettingTotalBalance
     * @example
     * // Get one SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingTotalBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingTotalBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettingTotalBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingTotalBalances
     * const settingTotalBalances = await prisma.settingTotalBalance.findMany()
     * 
     * // Get first 10 SettingTotalBalances
     * const settingTotalBalances = await prisma.settingTotalBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingTotalBalanceWithIdOnly = await prisma.settingTotalBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingTotalBalanceFindManyArgs>(args?: SelectSubset<T, SettingTotalBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettingTotalBalance.
     * @param {SettingTotalBalanceCreateArgs} args - Arguments to create a SettingTotalBalance.
     * @example
     * // Create one SettingTotalBalance
     * const SettingTotalBalance = await prisma.settingTotalBalance.create({
     *   data: {
     *     // ... data to create a SettingTotalBalance
     *   }
     * })
     * 
     */
    create<T extends SettingTotalBalanceCreateArgs>(args: SelectSubset<T, SettingTotalBalanceCreateArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettingTotalBalances.
     * @param {SettingTotalBalanceCreateManyArgs} args - Arguments to create many SettingTotalBalances.
     * @example
     * // Create many SettingTotalBalances
     * const settingTotalBalance = await prisma.settingTotalBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingTotalBalanceCreateManyArgs>(args?: SelectSubset<T, SettingTotalBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettingTotalBalance.
     * @param {SettingTotalBalanceDeleteArgs} args - Arguments to delete one SettingTotalBalance.
     * @example
     * // Delete one SettingTotalBalance
     * const SettingTotalBalance = await prisma.settingTotalBalance.delete({
     *   where: {
     *     // ... filter to delete one SettingTotalBalance
     *   }
     * })
     * 
     */
    delete<T extends SettingTotalBalanceDeleteArgs>(args: SelectSubset<T, SettingTotalBalanceDeleteArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettingTotalBalance.
     * @param {SettingTotalBalanceUpdateArgs} args - Arguments to update one SettingTotalBalance.
     * @example
     * // Update one SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingTotalBalanceUpdateArgs>(args: SelectSubset<T, SettingTotalBalanceUpdateArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettingTotalBalances.
     * @param {SettingTotalBalanceDeleteManyArgs} args - Arguments to filter SettingTotalBalances to delete.
     * @example
     * // Delete a few SettingTotalBalances
     * const { count } = await prisma.settingTotalBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingTotalBalanceDeleteManyArgs>(args?: SelectSubset<T, SettingTotalBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingTotalBalances
     * const settingTotalBalance = await prisma.settingTotalBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingTotalBalanceUpdateManyArgs>(args: SelectSubset<T, SettingTotalBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingTotalBalance.
     * @param {SettingTotalBalanceUpsertArgs} args - Arguments to update or create a SettingTotalBalance.
     * @example
     * // Update or create a SettingTotalBalance
     * const settingTotalBalance = await prisma.settingTotalBalance.upsert({
     *   create: {
     *     // ... data to create a SettingTotalBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingTotalBalance we want to update
     *   }
     * })
     */
    upsert<T extends SettingTotalBalanceUpsertArgs>(args: SelectSubset<T, SettingTotalBalanceUpsertArgs<ExtArgs>>): Prisma__SettingTotalBalanceClient<$Result.GetResult<Prisma.$SettingTotalBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceCountArgs} args - Arguments to filter SettingTotalBalances to count.
     * @example
     * // Count the number of SettingTotalBalances
     * const count = await prisma.settingTotalBalance.count({
     *   where: {
     *     // ... the filter for the SettingTotalBalances we want to count
     *   }
     * })
    **/
    count<T extends SettingTotalBalanceCountArgs>(
      args?: Subset<T, SettingTotalBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingTotalBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingTotalBalanceAggregateArgs>(args: Subset<T, SettingTotalBalanceAggregateArgs>): Prisma.PrismaPromise<GetSettingTotalBalanceAggregateType<T>>

    /**
     * Group by SettingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingTotalBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingTotalBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingTotalBalanceGroupByArgs['orderBy'] }
        : { orderBy?: SettingTotalBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingTotalBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingTotalBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingTotalBalance model
   */
  readonly fields: SettingTotalBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingTotalBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingTotalBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting_entry<T extends SettingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntryDefaultArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingTotalBalance model
   */
  interface SettingTotalBalanceFieldRefs {
    readonly id: FieldRef<"SettingTotalBalance", 'Int'>
    readonly createdAt: FieldRef<"SettingTotalBalance", 'DateTime'>
    readonly receipt_weight: FieldRef<"SettingTotalBalance", 'Float'>
    readonly stone_count: FieldRef<"SettingTotalBalance", 'Float'>
    readonly stone_weight: FieldRef<"SettingTotalBalance", 'Float'>
    readonly remarks: FieldRef<"SettingTotalBalance", 'String'>
    readonly wastage: FieldRef<"SettingTotalBalance", 'Boolean'>
    readonly total_product_weight: FieldRef<"SettingTotalBalance", 'Float'>
    readonly current_balance_weight: FieldRef<"SettingTotalBalance", 'Float'>
    readonly total_scrap_weight: FieldRef<"SettingTotalBalance", 'Float'>
    readonly balance: FieldRef<"SettingTotalBalance", 'Float'>
    readonly setting_entry_id: FieldRef<"SettingTotalBalance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SettingTotalBalance findUnique
   */
  export type SettingTotalBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which SettingTotalBalance to fetch.
     */
    where: SettingTotalBalanceWhereUniqueInput
  }

  /**
   * SettingTotalBalance findUniqueOrThrow
   */
  export type SettingTotalBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which SettingTotalBalance to fetch.
     */
    where: SettingTotalBalanceWhereUniqueInput
  }

  /**
   * SettingTotalBalance findFirst
   */
  export type SettingTotalBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which SettingTotalBalance to fetch.
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTotalBalances to fetch.
     */
    orderBy?: SettingTotalBalanceOrderByWithRelationInput | SettingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingTotalBalances.
     */
    cursor?: SettingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingTotalBalances.
     */
    distinct?: SettingTotalBalanceScalarFieldEnum | SettingTotalBalanceScalarFieldEnum[]
  }

  /**
   * SettingTotalBalance findFirstOrThrow
   */
  export type SettingTotalBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which SettingTotalBalance to fetch.
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTotalBalances to fetch.
     */
    orderBy?: SettingTotalBalanceOrderByWithRelationInput | SettingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingTotalBalances.
     */
    cursor?: SettingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingTotalBalances.
     */
    distinct?: SettingTotalBalanceScalarFieldEnum | SettingTotalBalanceScalarFieldEnum[]
  }

  /**
   * SettingTotalBalance findMany
   */
  export type SettingTotalBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which SettingTotalBalances to fetch.
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingTotalBalances to fetch.
     */
    orderBy?: SettingTotalBalanceOrderByWithRelationInput | SettingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingTotalBalances.
     */
    cursor?: SettingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingTotalBalances.
     */
    skip?: number
    distinct?: SettingTotalBalanceScalarFieldEnum | SettingTotalBalanceScalarFieldEnum[]
  }

  /**
   * SettingTotalBalance create
   */
  export type SettingTotalBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingTotalBalance.
     */
    data: XOR<SettingTotalBalanceCreateInput, SettingTotalBalanceUncheckedCreateInput>
  }

  /**
   * SettingTotalBalance createMany
   */
  export type SettingTotalBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingTotalBalances.
     */
    data: SettingTotalBalanceCreateManyInput | SettingTotalBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingTotalBalance update
   */
  export type SettingTotalBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingTotalBalance.
     */
    data: XOR<SettingTotalBalanceUpdateInput, SettingTotalBalanceUncheckedUpdateInput>
    /**
     * Choose, which SettingTotalBalance to update.
     */
    where: SettingTotalBalanceWhereUniqueInput
  }

  /**
   * SettingTotalBalance updateMany
   */
  export type SettingTotalBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingTotalBalances.
     */
    data: XOR<SettingTotalBalanceUpdateManyMutationInput, SettingTotalBalanceUncheckedUpdateManyInput>
    /**
     * Filter which SettingTotalBalances to update
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * Limit how many SettingTotalBalances to update.
     */
    limit?: number
  }

  /**
   * SettingTotalBalance upsert
   */
  export type SettingTotalBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingTotalBalance to update in case it exists.
     */
    where: SettingTotalBalanceWhereUniqueInput
    /**
     * In case the SettingTotalBalance found by the `where` argument doesn't exist, create a new SettingTotalBalance with this data.
     */
    create: XOR<SettingTotalBalanceCreateInput, SettingTotalBalanceUncheckedCreateInput>
    /**
     * In case the SettingTotalBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingTotalBalanceUpdateInput, SettingTotalBalanceUncheckedUpdateInput>
  }

  /**
   * SettingTotalBalance delete
   */
  export type SettingTotalBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter which SettingTotalBalance to delete.
     */
    where: SettingTotalBalanceWhereUniqueInput
  }

  /**
   * SettingTotalBalance deleteMany
   */
  export type SettingTotalBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingTotalBalances to delete
     */
    where?: SettingTotalBalanceWhereInput
    /**
     * Limit how many SettingTotalBalances to delete.
     */
    limit?: number
  }

  /**
   * SettingTotalBalance without action
   */
  export type SettingTotalBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingTotalBalance
     */
    select?: SettingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingTotalBalance
     */
    omit?: SettingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingTotalBalanceInclude<ExtArgs> | null
  }


  /**
   * Model SettingWastage
   */

  export type AggregateSettingWastage = {
    _count: SettingWastageCountAggregateOutputType | null
    _avg: SettingWastageAvgAggregateOutputType | null
    _sum: SettingWastageSumAggregateOutputType | null
    _min: SettingWastageMinAggregateOutputType | null
    _max: SettingWastageMaxAggregateOutputType | null
  }

  export type SettingWastageAvgAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    setting_entry_id: number | null
  }

  export type SettingWastageSumAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    setting_entry_id: number | null
  }

  export type SettingWastageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    setting_entry_id: number | null
  }

  export type SettingWastageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    setting_entry_id: number | null
  }

  export type SettingWastageCountAggregateOutputType = {
    id: number
    createdAt: number
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number
    add_wastage: number
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_entry_id: number
    _all: number
  }


  export type SettingWastageAvgAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    setting_entry_id?: true
  }

  export type SettingWastageSumAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    setting_entry_id?: true
  }

  export type SettingWastageMinAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    setting_entry_id?: true
  }

  export type SettingWastageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    setting_entry_id?: true
  }

  export type SettingWastageCountAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    setting_entry_id?: true
    _all?: true
  }

  export type SettingWastageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingWastage to aggregate.
     */
    where?: SettingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingWastages to fetch.
     */
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingWastages
    **/
    _count?: true | SettingWastageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingWastageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingWastageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingWastageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingWastageMaxAggregateInputType
  }

  export type GetSettingWastageAggregateType<T extends SettingWastageAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingWastage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingWastage[P]>
      : GetScalarType<T[P], AggregateSettingWastage[P]>
  }




  export type SettingWastageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWastageWhereInput
    orderBy?: SettingWastageOrderByWithAggregationInput | SettingWastageOrderByWithAggregationInput[]
    by: SettingWastageScalarFieldEnum[] | SettingWastageScalarFieldEnum
    having?: SettingWastageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingWastageCountAggregateInputType | true
    _avg?: SettingWastageAvgAggregateInputType
    _sum?: SettingWastageSumAggregateInputType
    _min?: SettingWastageMinAggregateInputType
    _max?: SettingWastageMaxAggregateInputType
  }

  export type SettingWastageGroupByOutputType = {
    id: number
    createdAt: Date
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_entry_id: number
    _count: SettingWastageCountAggregateOutputType | null
    _avg: SettingWastageAvgAggregateOutputType | null
    _sum: SettingWastageSumAggregateOutputType | null
    _min: SettingWastageMinAggregateOutputType | null
    _max: SettingWastageMaxAggregateOutputType | null
  }

  type GetSettingWastageGroupByPayload<T extends SettingWastageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingWastageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingWastageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingWastageGroupByOutputType[P]>
            : GetScalarType<T[P], SettingWastageGroupByOutputType[P]>
        }
      >
    >


  export type SettingWastageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    setting_entry_id?: boolean
    setting_items?: boolean | SettingWastage$setting_itemsArgs<ExtArgs>
    SettingEntryId?: boolean | SettingEntryDefaultArgs<ExtArgs>
    _count?: boolean | SettingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingWastage"]>



  export type SettingWastageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    setting_entry_id?: boolean
  }

  export type SettingWastageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "total_receipt" | "total_wastage" | "balance" | "wastage_percentage" | "given_gold" | "add_wastage" | "overall_wastage" | "closing_balance" | "opening_balance" | "setting_entry_id", ExtArgs["result"]["settingWastage"]>
  export type SettingWastageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting_items?: boolean | SettingWastage$setting_itemsArgs<ExtArgs>
    SettingEntryId?: boolean | SettingEntryDefaultArgs<ExtArgs>
    _count?: boolean | SettingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SettingWastagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingWastage"
    objects: {
      setting_items: Prisma.$SettingItemsPayload<ExtArgs>[]
      SettingEntryId: Prisma.$SettingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      total_receipt: number
      total_wastage: number
      balance: number
      wastage_percentage: number
      given_gold: number | null
      add_wastage: number | null
      overall_wastage: number
      closing_balance: number
      opening_balance: number
      setting_entry_id: number
    }, ExtArgs["result"]["settingWastage"]>
    composites: {}
  }

  type SettingWastageGetPayload<S extends boolean | null | undefined | SettingWastageDefaultArgs> = $Result.GetResult<Prisma.$SettingWastagePayload, S>

  type SettingWastageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingWastageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingWastageCountAggregateInputType | true
    }

  export interface SettingWastageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingWastage'], meta: { name: 'SettingWastage' } }
    /**
     * Find zero or one SettingWastage that matches the filter.
     * @param {SettingWastageFindUniqueArgs} args - Arguments to find a SettingWastage
     * @example
     * // Get one SettingWastage
     * const settingWastage = await prisma.settingWastage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingWastageFindUniqueArgs>(args: SelectSubset<T, SettingWastageFindUniqueArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SettingWastage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingWastageFindUniqueOrThrowArgs} args - Arguments to find a SettingWastage
     * @example
     * // Get one SettingWastage
     * const settingWastage = await prisma.settingWastage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingWastageFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingWastageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingWastage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageFindFirstArgs} args - Arguments to find a SettingWastage
     * @example
     * // Get one SettingWastage
     * const settingWastage = await prisma.settingWastage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingWastageFindFirstArgs>(args?: SelectSubset<T, SettingWastageFindFirstArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SettingWastage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageFindFirstOrThrowArgs} args - Arguments to find a SettingWastage
     * @example
     * // Get one SettingWastage
     * const settingWastage = await prisma.settingWastage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingWastageFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingWastageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SettingWastages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingWastages
     * const settingWastages = await prisma.settingWastage.findMany()
     * 
     * // Get first 10 SettingWastages
     * const settingWastages = await prisma.settingWastage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWastageWithIdOnly = await prisma.settingWastage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingWastageFindManyArgs>(args?: SelectSubset<T, SettingWastageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SettingWastage.
     * @param {SettingWastageCreateArgs} args - Arguments to create a SettingWastage.
     * @example
     * // Create one SettingWastage
     * const SettingWastage = await prisma.settingWastage.create({
     *   data: {
     *     // ... data to create a SettingWastage
     *   }
     * })
     * 
     */
    create<T extends SettingWastageCreateArgs>(args: SelectSubset<T, SettingWastageCreateArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SettingWastages.
     * @param {SettingWastageCreateManyArgs} args - Arguments to create many SettingWastages.
     * @example
     * // Create many SettingWastages
     * const settingWastage = await prisma.settingWastage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingWastageCreateManyArgs>(args?: SelectSubset<T, SettingWastageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettingWastage.
     * @param {SettingWastageDeleteArgs} args - Arguments to delete one SettingWastage.
     * @example
     * // Delete one SettingWastage
     * const SettingWastage = await prisma.settingWastage.delete({
     *   where: {
     *     // ... filter to delete one SettingWastage
     *   }
     * })
     * 
     */
    delete<T extends SettingWastageDeleteArgs>(args: SelectSubset<T, SettingWastageDeleteArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SettingWastage.
     * @param {SettingWastageUpdateArgs} args - Arguments to update one SettingWastage.
     * @example
     * // Update one SettingWastage
     * const settingWastage = await prisma.settingWastage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingWastageUpdateArgs>(args: SelectSubset<T, SettingWastageUpdateArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SettingWastages.
     * @param {SettingWastageDeleteManyArgs} args - Arguments to filter SettingWastages to delete.
     * @example
     * // Delete a few SettingWastages
     * const { count } = await prisma.settingWastage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingWastageDeleteManyArgs>(args?: SelectSubset<T, SettingWastageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingWastages
     * const settingWastage = await prisma.settingWastage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingWastageUpdateManyArgs>(args: SelectSubset<T, SettingWastageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingWastage.
     * @param {SettingWastageUpsertArgs} args - Arguments to update or create a SettingWastage.
     * @example
     * // Update or create a SettingWastage
     * const settingWastage = await prisma.settingWastage.upsert({
     *   create: {
     *     // ... data to create a SettingWastage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingWastage we want to update
     *   }
     * })
     */
    upsert<T extends SettingWastageUpsertArgs>(args: SelectSubset<T, SettingWastageUpsertArgs<ExtArgs>>): Prisma__SettingWastageClient<$Result.GetResult<Prisma.$SettingWastagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SettingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageCountArgs} args - Arguments to filter SettingWastages to count.
     * @example
     * // Count the number of SettingWastages
     * const count = await prisma.settingWastage.count({
     *   where: {
     *     // ... the filter for the SettingWastages we want to count
     *   }
     * })
    **/
    count<T extends SettingWastageCountArgs>(
      args?: Subset<T, SettingWastageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingWastageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingWastageAggregateArgs>(args: Subset<T, SettingWastageAggregateArgs>): Prisma.PrismaPromise<GetSettingWastageAggregateType<T>>

    /**
     * Group by SettingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingWastageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingWastageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingWastageGroupByArgs['orderBy'] }
        : { orderBy?: SettingWastageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingWastageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingWastageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingWastage model
   */
  readonly fields: SettingWastageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingWastage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingWastageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting_items<T extends SettingWastage$setting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, SettingWastage$setting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SettingEntryId<T extends SettingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SettingEntryDefaultArgs<ExtArgs>>): Prisma__SettingEntryClient<$Result.GetResult<Prisma.$SettingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingWastage model
   */
  interface SettingWastageFieldRefs {
    readonly id: FieldRef<"SettingWastage", 'Int'>
    readonly createdAt: FieldRef<"SettingWastage", 'DateTime'>
    readonly total_receipt: FieldRef<"SettingWastage", 'Float'>
    readonly total_wastage: FieldRef<"SettingWastage", 'Float'>
    readonly balance: FieldRef<"SettingWastage", 'Float'>
    readonly wastage_percentage: FieldRef<"SettingWastage", 'Int'>
    readonly given_gold: FieldRef<"SettingWastage", 'Int'>
    readonly add_wastage: FieldRef<"SettingWastage", 'Float'>
    readonly overall_wastage: FieldRef<"SettingWastage", 'Float'>
    readonly closing_balance: FieldRef<"SettingWastage", 'Float'>
    readonly opening_balance: FieldRef<"SettingWastage", 'Float'>
    readonly setting_entry_id: FieldRef<"SettingWastage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SettingWastage findUnique
   */
  export type SettingWastageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter, which SettingWastage to fetch.
     */
    where: SettingWastageWhereUniqueInput
  }

  /**
   * SettingWastage findUniqueOrThrow
   */
  export type SettingWastageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter, which SettingWastage to fetch.
     */
    where: SettingWastageWhereUniqueInput
  }

  /**
   * SettingWastage findFirst
   */
  export type SettingWastageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter, which SettingWastage to fetch.
     */
    where?: SettingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingWastages to fetch.
     */
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingWastages.
     */
    cursor?: SettingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingWastages.
     */
    distinct?: SettingWastageScalarFieldEnum | SettingWastageScalarFieldEnum[]
  }

  /**
   * SettingWastage findFirstOrThrow
   */
  export type SettingWastageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter, which SettingWastage to fetch.
     */
    where?: SettingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingWastages to fetch.
     */
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingWastages.
     */
    cursor?: SettingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingWastages.
     */
    distinct?: SettingWastageScalarFieldEnum | SettingWastageScalarFieldEnum[]
  }

  /**
   * SettingWastage findMany
   */
  export type SettingWastageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter, which SettingWastages to fetch.
     */
    where?: SettingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingWastages to fetch.
     */
    orderBy?: SettingWastageOrderByWithRelationInput | SettingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingWastages.
     */
    cursor?: SettingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingWastages.
     */
    skip?: number
    distinct?: SettingWastageScalarFieldEnum | SettingWastageScalarFieldEnum[]
  }

  /**
   * SettingWastage create
   */
  export type SettingWastageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingWastage.
     */
    data: XOR<SettingWastageCreateInput, SettingWastageUncheckedCreateInput>
  }

  /**
   * SettingWastage createMany
   */
  export type SettingWastageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingWastages.
     */
    data: SettingWastageCreateManyInput | SettingWastageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingWastage update
   */
  export type SettingWastageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingWastage.
     */
    data: XOR<SettingWastageUpdateInput, SettingWastageUncheckedUpdateInput>
    /**
     * Choose, which SettingWastage to update.
     */
    where: SettingWastageWhereUniqueInput
  }

  /**
   * SettingWastage updateMany
   */
  export type SettingWastageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingWastages.
     */
    data: XOR<SettingWastageUpdateManyMutationInput, SettingWastageUncheckedUpdateManyInput>
    /**
     * Filter which SettingWastages to update
     */
    where?: SettingWastageWhereInput
    /**
     * Limit how many SettingWastages to update.
     */
    limit?: number
  }

  /**
   * SettingWastage upsert
   */
  export type SettingWastageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingWastage to update in case it exists.
     */
    where: SettingWastageWhereUniqueInput
    /**
     * In case the SettingWastage found by the `where` argument doesn't exist, create a new SettingWastage with this data.
     */
    create: XOR<SettingWastageCreateInput, SettingWastageUncheckedCreateInput>
    /**
     * In case the SettingWastage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingWastageUpdateInput, SettingWastageUncheckedUpdateInput>
  }

  /**
   * SettingWastage delete
   */
  export type SettingWastageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
    /**
     * Filter which SettingWastage to delete.
     */
    where: SettingWastageWhereUniqueInput
  }

  /**
   * SettingWastage deleteMany
   */
  export type SettingWastageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingWastages to delete
     */
    where?: SettingWastageWhereInput
    /**
     * Limit how many SettingWastages to delete.
     */
    limit?: number
  }

  /**
   * SettingWastage.setting_items
   */
  export type SettingWastage$setting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    cursor?: SettingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * SettingWastage without action
   */
  export type SettingWastageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingWastage
     */
    select?: SettingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingWastage
     */
    omit?: SettingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingWastageInclude<ExtArgs> | null
  }


  /**
   * Model BuffingEntry
   */

  export type AggregateBuffingEntry = {
    _count: BuffingEntryCountAggregateOutputType | null
    _avg: BuffingEntryAvgAggregateOutputType | null
    _sum: BuffingEntrySumAggregateOutputType | null
    _min: BuffingEntryMinAggregateOutputType | null
    _max: BuffingEntryMaxAggregateOutputType | null
  }

  export type BuffingEntryAvgAggregateOutputType = {
    id: number | null
    buffing_person_id: number | null
    casting_item_id: number | null
  }

  export type BuffingEntrySumAggregateOutputType = {
    id: number | null
    buffing_person_id: number | null
    casting_item_id: number | null
  }

  export type BuffingEntryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    buffing_person_id: number | null
    casting_item_id: number | null
  }

  export type BuffingEntryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    buffing_person_id: number | null
    casting_item_id: number | null
  }

  export type BuffingEntryCountAggregateOutputType = {
    id: number
    createdAt: number
    buffing_person_id: number
    casting_item_id: number
    _all: number
  }


  export type BuffingEntryAvgAggregateInputType = {
    id?: true
    buffing_person_id?: true
    casting_item_id?: true
  }

  export type BuffingEntrySumAggregateInputType = {
    id?: true
    buffing_person_id?: true
    casting_item_id?: true
  }

  export type BuffingEntryMinAggregateInputType = {
    id?: true
    createdAt?: true
    buffing_person_id?: true
    casting_item_id?: true
  }

  export type BuffingEntryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    buffing_person_id?: true
    casting_item_id?: true
  }

  export type BuffingEntryCountAggregateInputType = {
    id?: true
    createdAt?: true
    buffing_person_id?: true
    casting_item_id?: true
    _all?: true
  }

  export type BuffingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingEntry to aggregate.
     */
    where?: BuffingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingEntries to fetch.
     */
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuffingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuffingEntries
    **/
    _count?: true | BuffingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuffingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuffingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuffingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuffingEntryMaxAggregateInputType
  }

  export type GetBuffingEntryAggregateType<T extends BuffingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateBuffingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuffingEntry[P]>
      : GetScalarType<T[P], AggregateBuffingEntry[P]>
  }




  export type BuffingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingEntryWhereInput
    orderBy?: BuffingEntryOrderByWithAggregationInput | BuffingEntryOrderByWithAggregationInput[]
    by: BuffingEntryScalarFieldEnum[] | BuffingEntryScalarFieldEnum
    having?: BuffingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuffingEntryCountAggregateInputType | true
    _avg?: BuffingEntryAvgAggregateInputType
    _sum?: BuffingEntrySumAggregateInputType
    _min?: BuffingEntryMinAggregateInputType
    _max?: BuffingEntryMaxAggregateInputType
  }

  export type BuffingEntryGroupByOutputType = {
    id: number
    createdAt: Date
    buffing_person_id: number
    casting_item_id: number
    _count: BuffingEntryCountAggregateOutputType | null
    _avg: BuffingEntryAvgAggregateOutputType | null
    _sum: BuffingEntrySumAggregateOutputType | null
    _min: BuffingEntryMinAggregateOutputType | null
    _max: BuffingEntryMaxAggregateOutputType | null
  }

  type GetBuffingEntryGroupByPayload<T extends BuffingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuffingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuffingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuffingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], BuffingEntryGroupByOutputType[P]>
        }
      >
    >


  export type BuffingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    buffing_person_id?: boolean
    casting_item_id?: boolean
    buffing_person?: boolean | AddBuffingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filing_items?: boolean | BuffingEntry$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | BuffingEntry$setting_itemsArgs<ExtArgs>
    BuffingTotalBalance?: boolean | BuffingEntry$BuffingTotalBalanceArgs<ExtArgs>
    LotBuffingMapper?: boolean | BuffingEntry$LotBuffingMapperArgs<ExtArgs>
    BuffingItems?: boolean | BuffingEntry$BuffingItemsArgs<ExtArgs>
    _count?: boolean | BuffingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buffingEntry"]>



  export type BuffingEntrySelectScalar = {
    id?: boolean
    createdAt?: boolean
    buffing_person_id?: boolean
    casting_item_id?: boolean
  }

  export type BuffingEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "buffing_person_id" | "casting_item_id", ExtArgs["result"]["buffingEntry"]>
  export type BuffingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffing_person?: boolean | AddBuffingDefaultArgs<ExtArgs>
    castingItem?: boolean | CastingItemsDefaultArgs<ExtArgs>
    filing_items?: boolean | BuffingEntry$filing_itemsArgs<ExtArgs>
    setting_items?: boolean | BuffingEntry$setting_itemsArgs<ExtArgs>
    BuffingTotalBalance?: boolean | BuffingEntry$BuffingTotalBalanceArgs<ExtArgs>
    LotBuffingMapper?: boolean | BuffingEntry$LotBuffingMapperArgs<ExtArgs>
    BuffingItems?: boolean | BuffingEntry$BuffingItemsArgs<ExtArgs>
    _count?: boolean | BuffingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuffingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuffingEntry"
    objects: {
      buffing_person: Prisma.$AddBuffingPayload<ExtArgs>
      castingItem: Prisma.$CastingItemsPayload<ExtArgs>
      filing_items: Prisma.$FilingItemsPayload<ExtArgs>[]
      setting_items: Prisma.$SettingItemsPayload<ExtArgs>[]
      BuffingTotalBalance: Prisma.$BuffingTotalBalancePayload<ExtArgs>[]
      LotBuffingMapper: Prisma.$LotBuffingMapperPayload<ExtArgs>[]
      BuffingItems: Prisma.$BuffingItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      buffing_person_id: number
      casting_item_id: number
    }, ExtArgs["result"]["buffingEntry"]>
    composites: {}
  }

  type BuffingEntryGetPayload<S extends boolean | null | undefined | BuffingEntryDefaultArgs> = $Result.GetResult<Prisma.$BuffingEntryPayload, S>

  type BuffingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuffingEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuffingEntryCountAggregateInputType | true
    }

  export interface BuffingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuffingEntry'], meta: { name: 'BuffingEntry' } }
    /**
     * Find zero or one BuffingEntry that matches the filter.
     * @param {BuffingEntryFindUniqueArgs} args - Arguments to find a BuffingEntry
     * @example
     * // Get one BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuffingEntryFindUniqueArgs>(args: SelectSubset<T, BuffingEntryFindUniqueArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuffingEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuffingEntryFindUniqueOrThrowArgs} args - Arguments to find a BuffingEntry
     * @example
     * // Get one BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuffingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, BuffingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryFindFirstArgs} args - Arguments to find a BuffingEntry
     * @example
     * // Get one BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuffingEntryFindFirstArgs>(args?: SelectSubset<T, BuffingEntryFindFirstArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryFindFirstOrThrowArgs} args - Arguments to find a BuffingEntry
     * @example
     * // Get one BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuffingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, BuffingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuffingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuffingEntries
     * const buffingEntries = await prisma.buffingEntry.findMany()
     * 
     * // Get first 10 BuffingEntries
     * const buffingEntries = await prisma.buffingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buffingEntryWithIdOnly = await prisma.buffingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuffingEntryFindManyArgs>(args?: SelectSubset<T, BuffingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuffingEntry.
     * @param {BuffingEntryCreateArgs} args - Arguments to create a BuffingEntry.
     * @example
     * // Create one BuffingEntry
     * const BuffingEntry = await prisma.buffingEntry.create({
     *   data: {
     *     // ... data to create a BuffingEntry
     *   }
     * })
     * 
     */
    create<T extends BuffingEntryCreateArgs>(args: SelectSubset<T, BuffingEntryCreateArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuffingEntries.
     * @param {BuffingEntryCreateManyArgs} args - Arguments to create many BuffingEntries.
     * @example
     * // Create many BuffingEntries
     * const buffingEntry = await prisma.buffingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuffingEntryCreateManyArgs>(args?: SelectSubset<T, BuffingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuffingEntry.
     * @param {BuffingEntryDeleteArgs} args - Arguments to delete one BuffingEntry.
     * @example
     * // Delete one BuffingEntry
     * const BuffingEntry = await prisma.buffingEntry.delete({
     *   where: {
     *     // ... filter to delete one BuffingEntry
     *   }
     * })
     * 
     */
    delete<T extends BuffingEntryDeleteArgs>(args: SelectSubset<T, BuffingEntryDeleteArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuffingEntry.
     * @param {BuffingEntryUpdateArgs} args - Arguments to update one BuffingEntry.
     * @example
     * // Update one BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuffingEntryUpdateArgs>(args: SelectSubset<T, BuffingEntryUpdateArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuffingEntries.
     * @param {BuffingEntryDeleteManyArgs} args - Arguments to filter BuffingEntries to delete.
     * @example
     * // Delete a few BuffingEntries
     * const { count } = await prisma.buffingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuffingEntryDeleteManyArgs>(args?: SelectSubset<T, BuffingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuffingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuffingEntries
     * const buffingEntry = await prisma.buffingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuffingEntryUpdateManyArgs>(args: SelectSubset<T, BuffingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuffingEntry.
     * @param {BuffingEntryUpsertArgs} args - Arguments to update or create a BuffingEntry.
     * @example
     * // Update or create a BuffingEntry
     * const buffingEntry = await prisma.buffingEntry.upsert({
     *   create: {
     *     // ... data to create a BuffingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuffingEntry we want to update
     *   }
     * })
     */
    upsert<T extends BuffingEntryUpsertArgs>(args: SelectSubset<T, BuffingEntryUpsertArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuffingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryCountArgs} args - Arguments to filter BuffingEntries to count.
     * @example
     * // Count the number of BuffingEntries
     * const count = await prisma.buffingEntry.count({
     *   where: {
     *     // ... the filter for the BuffingEntries we want to count
     *   }
     * })
    **/
    count<T extends BuffingEntryCountArgs>(
      args?: Subset<T, BuffingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuffingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuffingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuffingEntryAggregateArgs>(args: Subset<T, BuffingEntryAggregateArgs>): Prisma.PrismaPromise<GetBuffingEntryAggregateType<T>>

    /**
     * Group by BuffingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuffingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuffingEntryGroupByArgs['orderBy'] }
        : { orderBy?: BuffingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuffingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuffingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuffingEntry model
   */
  readonly fields: BuffingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuffingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuffingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buffing_person<T extends AddBuffingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffingDefaultArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    castingItem<T extends CastingItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CastingItemsDefaultArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filing_items<T extends BuffingEntry$filing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntry$filing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    setting_items<T extends BuffingEntry$setting_itemsArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntry$setting_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BuffingTotalBalance<T extends BuffingEntry$BuffingTotalBalanceArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntry$BuffingTotalBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LotBuffingMapper<T extends BuffingEntry$LotBuffingMapperArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntry$LotBuffingMapperArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BuffingItems<T extends BuffingEntry$BuffingItemsArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntry$BuffingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuffingEntry model
   */
  interface BuffingEntryFieldRefs {
    readonly id: FieldRef<"BuffingEntry", 'Int'>
    readonly createdAt: FieldRef<"BuffingEntry", 'DateTime'>
    readonly buffing_person_id: FieldRef<"BuffingEntry", 'Int'>
    readonly casting_item_id: FieldRef<"BuffingEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BuffingEntry findUnique
   */
  export type BuffingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter, which BuffingEntry to fetch.
     */
    where: BuffingEntryWhereUniqueInput
  }

  /**
   * BuffingEntry findUniqueOrThrow
   */
  export type BuffingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter, which BuffingEntry to fetch.
     */
    where: BuffingEntryWhereUniqueInput
  }

  /**
   * BuffingEntry findFirst
   */
  export type BuffingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter, which BuffingEntry to fetch.
     */
    where?: BuffingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingEntries to fetch.
     */
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingEntries.
     */
    cursor?: BuffingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingEntries.
     */
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * BuffingEntry findFirstOrThrow
   */
  export type BuffingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter, which BuffingEntry to fetch.
     */
    where?: BuffingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingEntries to fetch.
     */
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingEntries.
     */
    cursor?: BuffingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingEntries.
     */
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * BuffingEntry findMany
   */
  export type BuffingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter, which BuffingEntries to fetch.
     */
    where?: BuffingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingEntries to fetch.
     */
    orderBy?: BuffingEntryOrderByWithRelationInput | BuffingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuffingEntries.
     */
    cursor?: BuffingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingEntries.
     */
    skip?: number
    distinct?: BuffingEntryScalarFieldEnum | BuffingEntryScalarFieldEnum[]
  }

  /**
   * BuffingEntry create
   */
  export type BuffingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a BuffingEntry.
     */
    data: XOR<BuffingEntryCreateInput, BuffingEntryUncheckedCreateInput>
  }

  /**
   * BuffingEntry createMany
   */
  export type BuffingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuffingEntries.
     */
    data: BuffingEntryCreateManyInput | BuffingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuffingEntry update
   */
  export type BuffingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a BuffingEntry.
     */
    data: XOR<BuffingEntryUpdateInput, BuffingEntryUncheckedUpdateInput>
    /**
     * Choose, which BuffingEntry to update.
     */
    where: BuffingEntryWhereUniqueInput
  }

  /**
   * BuffingEntry updateMany
   */
  export type BuffingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuffingEntries.
     */
    data: XOR<BuffingEntryUpdateManyMutationInput, BuffingEntryUncheckedUpdateManyInput>
    /**
     * Filter which BuffingEntries to update
     */
    where?: BuffingEntryWhereInput
    /**
     * Limit how many BuffingEntries to update.
     */
    limit?: number
  }

  /**
   * BuffingEntry upsert
   */
  export type BuffingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the BuffingEntry to update in case it exists.
     */
    where: BuffingEntryWhereUniqueInput
    /**
     * In case the BuffingEntry found by the `where` argument doesn't exist, create a new BuffingEntry with this data.
     */
    create: XOR<BuffingEntryCreateInput, BuffingEntryUncheckedCreateInput>
    /**
     * In case the BuffingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuffingEntryUpdateInput, BuffingEntryUncheckedUpdateInput>
  }

  /**
   * BuffingEntry delete
   */
  export type BuffingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
    /**
     * Filter which BuffingEntry to delete.
     */
    where: BuffingEntryWhereUniqueInput
  }

  /**
   * BuffingEntry deleteMany
   */
  export type BuffingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingEntries to delete
     */
    where?: BuffingEntryWhereInput
    /**
     * Limit how many BuffingEntries to delete.
     */
    limit?: number
  }

  /**
   * BuffingEntry.filing_items
   */
  export type BuffingEntry$filing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
    orderBy?: FilingItemsOrderByWithRelationInput | FilingItemsOrderByWithRelationInput[]
    cursor?: FilingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilingItemsScalarFieldEnum | FilingItemsScalarFieldEnum[]
  }

  /**
   * BuffingEntry.setting_items
   */
  export type BuffingEntry$setting_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
    orderBy?: SettingItemsOrderByWithRelationInput | SettingItemsOrderByWithRelationInput[]
    cursor?: SettingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingItemsScalarFieldEnum | SettingItemsScalarFieldEnum[]
  }

  /**
   * BuffingEntry.BuffingTotalBalance
   */
  export type BuffingEntry$BuffingTotalBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    where?: BuffingTotalBalanceWhereInput
    orderBy?: BuffingTotalBalanceOrderByWithRelationInput | BuffingTotalBalanceOrderByWithRelationInput[]
    cursor?: BuffingTotalBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingTotalBalanceScalarFieldEnum | BuffingTotalBalanceScalarFieldEnum[]
  }

  /**
   * BuffingEntry.LotBuffingMapper
   */
  export type BuffingEntry$LotBuffingMapperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    cursor?: LotBuffingMapperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * BuffingEntry.BuffingItems
   */
  export type BuffingEntry$BuffingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    where?: BuffingItemsWhereInput
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    cursor?: BuffingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * BuffingEntry without action
   */
  export type BuffingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingEntry
     */
    select?: BuffingEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingEntry
     */
    omit?: BuffingEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingEntryInclude<ExtArgs> | null
  }


  /**
   * Model BuffingItems
   */

  export type AggregateBuffingItems = {
    _count: BuffingItemsCountAggregateOutputType | null
    _avg: BuffingItemsAvgAggregateOutputType | null
    _sum: BuffingItemsSumAggregateOutputType | null
    _min: BuffingItemsMinAggregateOutputType | null
    _max: BuffingItemsMaxAggregateOutputType | null
  }

  export type BuffingItemsAvgAggregateOutputType = {
    id: number | null
    buffing_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    buffing_entry_id: number | null
  }

  export type BuffingItemsSumAggregateOutputType = {
    id: number | null
    buffing_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    buffing_entry_id: number | null
  }

  export type BuffingItemsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    buffing_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    scrap_remarks: string | null
    buffing_entry_id: number | null
  }

  export type BuffingItemsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    type: $Enums.CASTINGENTRYTYPE | null
    buffing_item_id: number | null
    scrap_weight: number | null
    touch_id: number | null
    item_purity: number | null
    scrap_remarks: string | null
    buffing_entry_id: number | null
  }

  export type BuffingItemsCountAggregateOutputType = {
    id: number
    createdAt: number
    type: number
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks: number
    buffing_entry_id: number
    _all: number
  }


  export type BuffingItemsAvgAggregateInputType = {
    id?: true
    buffing_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    buffing_entry_id?: true
  }

  export type BuffingItemsSumAggregateInputType = {
    id?: true
    buffing_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    buffing_entry_id?: true
  }

  export type BuffingItemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    buffing_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    buffing_entry_id?: true
  }

  export type BuffingItemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    buffing_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    buffing_entry_id?: true
  }

  export type BuffingItemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    type?: true
    buffing_item_id?: true
    scrap_weight?: true
    touch_id?: true
    item_purity?: true
    scrap_remarks?: true
    buffing_entry_id?: true
    _all?: true
  }

  export type BuffingItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingItems to aggregate.
     */
    where?: BuffingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingItems to fetch.
     */
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuffingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuffingItems
    **/
    _count?: true | BuffingItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuffingItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuffingItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuffingItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuffingItemsMaxAggregateInputType
  }

  export type GetBuffingItemsAggregateType<T extends BuffingItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateBuffingItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuffingItems[P]>
      : GetScalarType<T[P], AggregateBuffingItems[P]>
  }




  export type BuffingItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingItemsWhereInput
    orderBy?: BuffingItemsOrderByWithAggregationInput | BuffingItemsOrderByWithAggregationInput[]
    by: BuffingItemsScalarFieldEnum[] | BuffingItemsScalarFieldEnum
    having?: BuffingItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuffingItemsCountAggregateInputType | true
    _avg?: BuffingItemsAvgAggregateInputType
    _sum?: BuffingItemsSumAggregateInputType
    _min?: BuffingItemsMinAggregateInputType
    _max?: BuffingItemsMaxAggregateInputType
  }

  export type BuffingItemsGroupByOutputType = {
    id: number
    createdAt: Date
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks: string | null
    buffing_entry_id: number
    _count: BuffingItemsCountAggregateOutputType | null
    _avg: BuffingItemsAvgAggregateOutputType | null
    _sum: BuffingItemsSumAggregateOutputType | null
    _min: BuffingItemsMinAggregateOutputType | null
    _max: BuffingItemsMaxAggregateOutputType | null
  }

  type GetBuffingItemsGroupByPayload<T extends BuffingItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuffingItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuffingItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuffingItemsGroupByOutputType[P]>
            : GetScalarType<T[P], BuffingItemsGroupByOutputType[P]>
        }
      >
    >


  export type BuffingItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    type?: boolean
    buffing_item_id?: boolean
    scrap_weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    scrap_remarks?: boolean
    buffing_entry_id?: boolean
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    stock?: boolean | BuffingItems$stockArgs<ExtArgs>
    buffing_wastage?: boolean | BuffingItems$buffing_wastageArgs<ExtArgs>
    buffingEntryId?: boolean | BuffingEntryDefaultArgs<ExtArgs>
    _count?: boolean | BuffingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buffingItems"]>



  export type BuffingItemsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    type?: boolean
    buffing_item_id?: boolean
    scrap_weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    scrap_remarks?: boolean
    buffing_entry_id?: boolean
  }

  export type BuffingItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "type" | "buffing_item_id" | "scrap_weight" | "touch_id" | "item_purity" | "scrap_remarks" | "buffing_entry_id", ExtArgs["result"]["buffingItems"]>
  export type BuffingItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    stock?: boolean | BuffingItems$stockArgs<ExtArgs>
    buffing_wastage?: boolean | BuffingItems$buffing_wastageArgs<ExtArgs>
    buffingEntryId?: boolean | BuffingEntryDefaultArgs<ExtArgs>
    _count?: boolean | BuffingItemsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuffingItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuffingItems"
    objects: {
      item: Prisma.$AddItemPayload<ExtArgs>
      touch: Prisma.$AddTouchPayload<ExtArgs>
      stock: Prisma.$StockPayload<ExtArgs>[]
      buffing_wastage: Prisma.$BuffingWastagePayload<ExtArgs>[]
      buffingEntryId: Prisma.$BuffingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      type: $Enums.CASTINGENTRYTYPE
      buffing_item_id: number
      scrap_weight: number
      touch_id: number
      item_purity: number
      scrap_remarks: string | null
      buffing_entry_id: number
    }, ExtArgs["result"]["buffingItems"]>
    composites: {}
  }

  type BuffingItemsGetPayload<S extends boolean | null | undefined | BuffingItemsDefaultArgs> = $Result.GetResult<Prisma.$BuffingItemsPayload, S>

  type BuffingItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuffingItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuffingItemsCountAggregateInputType | true
    }

  export interface BuffingItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuffingItems'], meta: { name: 'BuffingItems' } }
    /**
     * Find zero or one BuffingItems that matches the filter.
     * @param {BuffingItemsFindUniqueArgs} args - Arguments to find a BuffingItems
     * @example
     * // Get one BuffingItems
     * const buffingItems = await prisma.buffingItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuffingItemsFindUniqueArgs>(args: SelectSubset<T, BuffingItemsFindUniqueArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuffingItems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuffingItemsFindUniqueOrThrowArgs} args - Arguments to find a BuffingItems
     * @example
     * // Get one BuffingItems
     * const buffingItems = await prisma.buffingItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuffingItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, BuffingItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsFindFirstArgs} args - Arguments to find a BuffingItems
     * @example
     * // Get one BuffingItems
     * const buffingItems = await prisma.buffingItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuffingItemsFindFirstArgs>(args?: SelectSubset<T, BuffingItemsFindFirstArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsFindFirstOrThrowArgs} args - Arguments to find a BuffingItems
     * @example
     * // Get one BuffingItems
     * const buffingItems = await prisma.buffingItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuffingItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, BuffingItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuffingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuffingItems
     * const buffingItems = await prisma.buffingItems.findMany()
     * 
     * // Get first 10 BuffingItems
     * const buffingItems = await prisma.buffingItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buffingItemsWithIdOnly = await prisma.buffingItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuffingItemsFindManyArgs>(args?: SelectSubset<T, BuffingItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuffingItems.
     * @param {BuffingItemsCreateArgs} args - Arguments to create a BuffingItems.
     * @example
     * // Create one BuffingItems
     * const BuffingItems = await prisma.buffingItems.create({
     *   data: {
     *     // ... data to create a BuffingItems
     *   }
     * })
     * 
     */
    create<T extends BuffingItemsCreateArgs>(args: SelectSubset<T, BuffingItemsCreateArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuffingItems.
     * @param {BuffingItemsCreateManyArgs} args - Arguments to create many BuffingItems.
     * @example
     * // Create many BuffingItems
     * const buffingItems = await prisma.buffingItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuffingItemsCreateManyArgs>(args?: SelectSubset<T, BuffingItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuffingItems.
     * @param {BuffingItemsDeleteArgs} args - Arguments to delete one BuffingItems.
     * @example
     * // Delete one BuffingItems
     * const BuffingItems = await prisma.buffingItems.delete({
     *   where: {
     *     // ... filter to delete one BuffingItems
     *   }
     * })
     * 
     */
    delete<T extends BuffingItemsDeleteArgs>(args: SelectSubset<T, BuffingItemsDeleteArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuffingItems.
     * @param {BuffingItemsUpdateArgs} args - Arguments to update one BuffingItems.
     * @example
     * // Update one BuffingItems
     * const buffingItems = await prisma.buffingItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuffingItemsUpdateArgs>(args: SelectSubset<T, BuffingItemsUpdateArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuffingItems.
     * @param {BuffingItemsDeleteManyArgs} args - Arguments to filter BuffingItems to delete.
     * @example
     * // Delete a few BuffingItems
     * const { count } = await prisma.buffingItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuffingItemsDeleteManyArgs>(args?: SelectSubset<T, BuffingItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuffingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuffingItems
     * const buffingItems = await prisma.buffingItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuffingItemsUpdateManyArgs>(args: SelectSubset<T, BuffingItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuffingItems.
     * @param {BuffingItemsUpsertArgs} args - Arguments to update or create a BuffingItems.
     * @example
     * // Update or create a BuffingItems
     * const buffingItems = await prisma.buffingItems.upsert({
     *   create: {
     *     // ... data to create a BuffingItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuffingItems we want to update
     *   }
     * })
     */
    upsert<T extends BuffingItemsUpsertArgs>(args: SelectSubset<T, BuffingItemsUpsertArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuffingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsCountArgs} args - Arguments to filter BuffingItems to count.
     * @example
     * // Count the number of BuffingItems
     * const count = await prisma.buffingItems.count({
     *   where: {
     *     // ... the filter for the BuffingItems we want to count
     *   }
     * })
    **/
    count<T extends BuffingItemsCountArgs>(
      args?: Subset<T, BuffingItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuffingItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuffingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuffingItemsAggregateArgs>(args: Subset<T, BuffingItemsAggregateArgs>): Prisma.PrismaPromise<GetBuffingItemsAggregateType<T>>

    /**
     * Group by BuffingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuffingItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuffingItemsGroupByArgs['orderBy'] }
        : { orderBy?: BuffingItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuffingItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuffingItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuffingItems model
   */
  readonly fields: BuffingItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuffingItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuffingItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends AddItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddItemDefaultArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stock<T extends BuffingItems$stockArgs<ExtArgs> = {}>(args?: Subset<T, BuffingItems$stockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffing_wastage<T extends BuffingItems$buffing_wastageArgs<ExtArgs> = {}>(args?: Subset<T, BuffingItems$buffing_wastageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buffingEntryId<T extends BuffingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntryDefaultArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuffingItems model
   */
  interface BuffingItemsFieldRefs {
    readonly id: FieldRef<"BuffingItems", 'Int'>
    readonly createdAt: FieldRef<"BuffingItems", 'DateTime'>
    readonly type: FieldRef<"BuffingItems", 'CASTINGENTRYTYPE'>
    readonly buffing_item_id: FieldRef<"BuffingItems", 'Int'>
    readonly scrap_weight: FieldRef<"BuffingItems", 'Float'>
    readonly touch_id: FieldRef<"BuffingItems", 'Int'>
    readonly item_purity: FieldRef<"BuffingItems", 'Float'>
    readonly scrap_remarks: FieldRef<"BuffingItems", 'String'>
    readonly buffing_entry_id: FieldRef<"BuffingItems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BuffingItems findUnique
   */
  export type BuffingItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter, which BuffingItems to fetch.
     */
    where: BuffingItemsWhereUniqueInput
  }

  /**
   * BuffingItems findUniqueOrThrow
   */
  export type BuffingItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter, which BuffingItems to fetch.
     */
    where: BuffingItemsWhereUniqueInput
  }

  /**
   * BuffingItems findFirst
   */
  export type BuffingItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter, which BuffingItems to fetch.
     */
    where?: BuffingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingItems to fetch.
     */
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingItems.
     */
    cursor?: BuffingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingItems.
     */
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * BuffingItems findFirstOrThrow
   */
  export type BuffingItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter, which BuffingItems to fetch.
     */
    where?: BuffingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingItems to fetch.
     */
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingItems.
     */
    cursor?: BuffingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingItems.
     */
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * BuffingItems findMany
   */
  export type BuffingItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter, which BuffingItems to fetch.
     */
    where?: BuffingItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingItems to fetch.
     */
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuffingItems.
     */
    cursor?: BuffingItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingItems.
     */
    skip?: number
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * BuffingItems create
   */
  export type BuffingItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a BuffingItems.
     */
    data: XOR<BuffingItemsCreateInput, BuffingItemsUncheckedCreateInput>
  }

  /**
   * BuffingItems createMany
   */
  export type BuffingItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuffingItems.
     */
    data: BuffingItemsCreateManyInput | BuffingItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuffingItems update
   */
  export type BuffingItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a BuffingItems.
     */
    data: XOR<BuffingItemsUpdateInput, BuffingItemsUncheckedUpdateInput>
    /**
     * Choose, which BuffingItems to update.
     */
    where: BuffingItemsWhereUniqueInput
  }

  /**
   * BuffingItems updateMany
   */
  export type BuffingItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuffingItems.
     */
    data: XOR<BuffingItemsUpdateManyMutationInput, BuffingItemsUncheckedUpdateManyInput>
    /**
     * Filter which BuffingItems to update
     */
    where?: BuffingItemsWhereInput
    /**
     * Limit how many BuffingItems to update.
     */
    limit?: number
  }

  /**
   * BuffingItems upsert
   */
  export type BuffingItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the BuffingItems to update in case it exists.
     */
    where: BuffingItemsWhereUniqueInput
    /**
     * In case the BuffingItems found by the `where` argument doesn't exist, create a new BuffingItems with this data.
     */
    create: XOR<BuffingItemsCreateInput, BuffingItemsUncheckedCreateInput>
    /**
     * In case the BuffingItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuffingItemsUpdateInput, BuffingItemsUncheckedUpdateInput>
  }

  /**
   * BuffingItems delete
   */
  export type BuffingItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    /**
     * Filter which BuffingItems to delete.
     */
    where: BuffingItemsWhereUniqueInput
  }

  /**
   * BuffingItems deleteMany
   */
  export type BuffingItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingItems to delete
     */
    where?: BuffingItemsWhereInput
    /**
     * Limit how many BuffingItems to delete.
     */
    limit?: number
  }

  /**
   * BuffingItems.stock
   */
  export type BuffingItems$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * BuffingItems.buffing_wastage
   */
  export type BuffingItems$buffing_wastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    where?: BuffingWastageWhereInput
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    cursor?: BuffingWastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * BuffingItems without action
   */
  export type BuffingItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
  }


  /**
   * Model BuffingTotalBalance
   */

  export type AggregateBuffingTotalBalance = {
    _count: BuffingTotalBalanceCountAggregateOutputType | null
    _avg: BuffingTotalBalanceAvgAggregateOutputType | null
    _sum: BuffingTotalBalanceSumAggregateOutputType | null
    _min: BuffingTotalBalanceMinAggregateOutputType | null
    _max: BuffingTotalBalanceMaxAggregateOutputType | null
  }

  export type BuffingTotalBalanceAvgAggregateOutputType = {
    id: number | null
    receipt_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    buffing_entry_id: number | null
  }

  export type BuffingTotalBalanceSumAggregateOutputType = {
    id: number | null
    receipt_weight: number | null
    total_scrap_weight: number | null
    balance: number | null
    buffing_entry_id: number | null
  }

  export type BuffingTotalBalanceMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    receipt_weight: number | null
    remarks: string | null
    wastage: boolean | null
    total_scrap_weight: number | null
    balance: number | null
    buffing_entry_id: number | null
  }

  export type BuffingTotalBalanceMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    receipt_weight: number | null
    remarks: string | null
    wastage: boolean | null
    total_scrap_weight: number | null
    balance: number | null
    buffing_entry_id: number | null
  }

  export type BuffingTotalBalanceCountAggregateOutputType = {
    id: number
    createdAt: number
    receipt_weight: number
    remarks: number
    wastage: number
    total_scrap_weight: number
    balance: number
    buffing_entry_id: number
    _all: number
  }


  export type BuffingTotalBalanceAvgAggregateInputType = {
    id?: true
    receipt_weight?: true
    total_scrap_weight?: true
    balance?: true
    buffing_entry_id?: true
  }

  export type BuffingTotalBalanceSumAggregateInputType = {
    id?: true
    receipt_weight?: true
    total_scrap_weight?: true
    balance?: true
    buffing_entry_id?: true
  }

  export type BuffingTotalBalanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    remarks?: true
    wastage?: true
    total_scrap_weight?: true
    balance?: true
    buffing_entry_id?: true
  }

  export type BuffingTotalBalanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    remarks?: true
    wastage?: true
    total_scrap_weight?: true
    balance?: true
    buffing_entry_id?: true
  }

  export type BuffingTotalBalanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    receipt_weight?: true
    remarks?: true
    wastage?: true
    total_scrap_weight?: true
    balance?: true
    buffing_entry_id?: true
    _all?: true
  }

  export type BuffingTotalBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingTotalBalance to aggregate.
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingTotalBalances to fetch.
     */
    orderBy?: BuffingTotalBalanceOrderByWithRelationInput | BuffingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuffingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuffingTotalBalances
    **/
    _count?: true | BuffingTotalBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuffingTotalBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuffingTotalBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuffingTotalBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuffingTotalBalanceMaxAggregateInputType
  }

  export type GetBuffingTotalBalanceAggregateType<T extends BuffingTotalBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBuffingTotalBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuffingTotalBalance[P]>
      : GetScalarType<T[P], AggregateBuffingTotalBalance[P]>
  }




  export type BuffingTotalBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingTotalBalanceWhereInput
    orderBy?: BuffingTotalBalanceOrderByWithAggregationInput | BuffingTotalBalanceOrderByWithAggregationInput[]
    by: BuffingTotalBalanceScalarFieldEnum[] | BuffingTotalBalanceScalarFieldEnum
    having?: BuffingTotalBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuffingTotalBalanceCountAggregateInputType | true
    _avg?: BuffingTotalBalanceAvgAggregateInputType
    _sum?: BuffingTotalBalanceSumAggregateInputType
    _min?: BuffingTotalBalanceMinAggregateInputType
    _max?: BuffingTotalBalanceMaxAggregateInputType
  }

  export type BuffingTotalBalanceGroupByOutputType = {
    id: number
    createdAt: Date
    receipt_weight: number
    remarks: string | null
    wastage: boolean
    total_scrap_weight: number | null
    balance: number
    buffing_entry_id: number
    _count: BuffingTotalBalanceCountAggregateOutputType | null
    _avg: BuffingTotalBalanceAvgAggregateOutputType | null
    _sum: BuffingTotalBalanceSumAggregateOutputType | null
    _min: BuffingTotalBalanceMinAggregateOutputType | null
    _max: BuffingTotalBalanceMaxAggregateOutputType | null
  }

  type GetBuffingTotalBalanceGroupByPayload<T extends BuffingTotalBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuffingTotalBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuffingTotalBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuffingTotalBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BuffingTotalBalanceGroupByOutputType[P]>
        }
      >
    >


  export type BuffingTotalBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    receipt_weight?: boolean
    remarks?: boolean
    wastage?: boolean
    total_scrap_weight?: boolean
    balance?: boolean
    buffing_entry_id?: boolean
    BuffingEntryId?: boolean | BuffingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buffingTotalBalance"]>



  export type BuffingTotalBalanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    receipt_weight?: boolean
    remarks?: boolean
    wastage?: boolean
    total_scrap_weight?: boolean
    balance?: boolean
    buffing_entry_id?: boolean
  }

  export type BuffingTotalBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "receipt_weight" | "remarks" | "wastage" | "total_scrap_weight" | "balance" | "buffing_entry_id", ExtArgs["result"]["buffingTotalBalance"]>
  export type BuffingTotalBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BuffingEntryId?: boolean | BuffingEntryDefaultArgs<ExtArgs>
  }

  export type $BuffingTotalBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuffingTotalBalance"
    objects: {
      BuffingEntryId: Prisma.$BuffingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      receipt_weight: number
      remarks: string | null
      wastage: boolean
      total_scrap_weight: number | null
      balance: number
      buffing_entry_id: number
    }, ExtArgs["result"]["buffingTotalBalance"]>
    composites: {}
  }

  type BuffingTotalBalanceGetPayload<S extends boolean | null | undefined | BuffingTotalBalanceDefaultArgs> = $Result.GetResult<Prisma.$BuffingTotalBalancePayload, S>

  type BuffingTotalBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuffingTotalBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuffingTotalBalanceCountAggregateInputType | true
    }

  export interface BuffingTotalBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuffingTotalBalance'], meta: { name: 'BuffingTotalBalance' } }
    /**
     * Find zero or one BuffingTotalBalance that matches the filter.
     * @param {BuffingTotalBalanceFindUniqueArgs} args - Arguments to find a BuffingTotalBalance
     * @example
     * // Get one BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuffingTotalBalanceFindUniqueArgs>(args: SelectSubset<T, BuffingTotalBalanceFindUniqueArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuffingTotalBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuffingTotalBalanceFindUniqueOrThrowArgs} args - Arguments to find a BuffingTotalBalance
     * @example
     * // Get one BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuffingTotalBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BuffingTotalBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingTotalBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceFindFirstArgs} args - Arguments to find a BuffingTotalBalance
     * @example
     * // Get one BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuffingTotalBalanceFindFirstArgs>(args?: SelectSubset<T, BuffingTotalBalanceFindFirstArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingTotalBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceFindFirstOrThrowArgs} args - Arguments to find a BuffingTotalBalance
     * @example
     * // Get one BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuffingTotalBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BuffingTotalBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuffingTotalBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuffingTotalBalances
     * const buffingTotalBalances = await prisma.buffingTotalBalance.findMany()
     * 
     * // Get first 10 BuffingTotalBalances
     * const buffingTotalBalances = await prisma.buffingTotalBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buffingTotalBalanceWithIdOnly = await prisma.buffingTotalBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuffingTotalBalanceFindManyArgs>(args?: SelectSubset<T, BuffingTotalBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuffingTotalBalance.
     * @param {BuffingTotalBalanceCreateArgs} args - Arguments to create a BuffingTotalBalance.
     * @example
     * // Create one BuffingTotalBalance
     * const BuffingTotalBalance = await prisma.buffingTotalBalance.create({
     *   data: {
     *     // ... data to create a BuffingTotalBalance
     *   }
     * })
     * 
     */
    create<T extends BuffingTotalBalanceCreateArgs>(args: SelectSubset<T, BuffingTotalBalanceCreateArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuffingTotalBalances.
     * @param {BuffingTotalBalanceCreateManyArgs} args - Arguments to create many BuffingTotalBalances.
     * @example
     * // Create many BuffingTotalBalances
     * const buffingTotalBalance = await prisma.buffingTotalBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuffingTotalBalanceCreateManyArgs>(args?: SelectSubset<T, BuffingTotalBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuffingTotalBalance.
     * @param {BuffingTotalBalanceDeleteArgs} args - Arguments to delete one BuffingTotalBalance.
     * @example
     * // Delete one BuffingTotalBalance
     * const BuffingTotalBalance = await prisma.buffingTotalBalance.delete({
     *   where: {
     *     // ... filter to delete one BuffingTotalBalance
     *   }
     * })
     * 
     */
    delete<T extends BuffingTotalBalanceDeleteArgs>(args: SelectSubset<T, BuffingTotalBalanceDeleteArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuffingTotalBalance.
     * @param {BuffingTotalBalanceUpdateArgs} args - Arguments to update one BuffingTotalBalance.
     * @example
     * // Update one BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuffingTotalBalanceUpdateArgs>(args: SelectSubset<T, BuffingTotalBalanceUpdateArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuffingTotalBalances.
     * @param {BuffingTotalBalanceDeleteManyArgs} args - Arguments to filter BuffingTotalBalances to delete.
     * @example
     * // Delete a few BuffingTotalBalances
     * const { count } = await prisma.buffingTotalBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuffingTotalBalanceDeleteManyArgs>(args?: SelectSubset<T, BuffingTotalBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuffingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuffingTotalBalances
     * const buffingTotalBalance = await prisma.buffingTotalBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuffingTotalBalanceUpdateManyArgs>(args: SelectSubset<T, BuffingTotalBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuffingTotalBalance.
     * @param {BuffingTotalBalanceUpsertArgs} args - Arguments to update or create a BuffingTotalBalance.
     * @example
     * // Update or create a BuffingTotalBalance
     * const buffingTotalBalance = await prisma.buffingTotalBalance.upsert({
     *   create: {
     *     // ... data to create a BuffingTotalBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuffingTotalBalance we want to update
     *   }
     * })
     */
    upsert<T extends BuffingTotalBalanceUpsertArgs>(args: SelectSubset<T, BuffingTotalBalanceUpsertArgs<ExtArgs>>): Prisma__BuffingTotalBalanceClient<$Result.GetResult<Prisma.$BuffingTotalBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuffingTotalBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceCountArgs} args - Arguments to filter BuffingTotalBalances to count.
     * @example
     * // Count the number of BuffingTotalBalances
     * const count = await prisma.buffingTotalBalance.count({
     *   where: {
     *     // ... the filter for the BuffingTotalBalances we want to count
     *   }
     * })
    **/
    count<T extends BuffingTotalBalanceCountArgs>(
      args?: Subset<T, BuffingTotalBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuffingTotalBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuffingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuffingTotalBalanceAggregateArgs>(args: Subset<T, BuffingTotalBalanceAggregateArgs>): Prisma.PrismaPromise<GetBuffingTotalBalanceAggregateType<T>>

    /**
     * Group by BuffingTotalBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingTotalBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuffingTotalBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuffingTotalBalanceGroupByArgs['orderBy'] }
        : { orderBy?: BuffingTotalBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuffingTotalBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuffingTotalBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuffingTotalBalance model
   */
  readonly fields: BuffingTotalBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuffingTotalBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuffingTotalBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BuffingEntryId<T extends BuffingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntryDefaultArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuffingTotalBalance model
   */
  interface BuffingTotalBalanceFieldRefs {
    readonly id: FieldRef<"BuffingTotalBalance", 'Int'>
    readonly createdAt: FieldRef<"BuffingTotalBalance", 'DateTime'>
    readonly receipt_weight: FieldRef<"BuffingTotalBalance", 'Float'>
    readonly remarks: FieldRef<"BuffingTotalBalance", 'String'>
    readonly wastage: FieldRef<"BuffingTotalBalance", 'Boolean'>
    readonly total_scrap_weight: FieldRef<"BuffingTotalBalance", 'Float'>
    readonly balance: FieldRef<"BuffingTotalBalance", 'Float'>
    readonly buffing_entry_id: FieldRef<"BuffingTotalBalance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BuffingTotalBalance findUnique
   */
  export type BuffingTotalBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BuffingTotalBalance to fetch.
     */
    where: BuffingTotalBalanceWhereUniqueInput
  }

  /**
   * BuffingTotalBalance findUniqueOrThrow
   */
  export type BuffingTotalBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BuffingTotalBalance to fetch.
     */
    where: BuffingTotalBalanceWhereUniqueInput
  }

  /**
   * BuffingTotalBalance findFirst
   */
  export type BuffingTotalBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BuffingTotalBalance to fetch.
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingTotalBalances to fetch.
     */
    orderBy?: BuffingTotalBalanceOrderByWithRelationInput | BuffingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingTotalBalances.
     */
    cursor?: BuffingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingTotalBalances.
     */
    distinct?: BuffingTotalBalanceScalarFieldEnum | BuffingTotalBalanceScalarFieldEnum[]
  }

  /**
   * BuffingTotalBalance findFirstOrThrow
   */
  export type BuffingTotalBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BuffingTotalBalance to fetch.
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingTotalBalances to fetch.
     */
    orderBy?: BuffingTotalBalanceOrderByWithRelationInput | BuffingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingTotalBalances.
     */
    cursor?: BuffingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingTotalBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingTotalBalances.
     */
    distinct?: BuffingTotalBalanceScalarFieldEnum | BuffingTotalBalanceScalarFieldEnum[]
  }

  /**
   * BuffingTotalBalance findMany
   */
  export type BuffingTotalBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BuffingTotalBalances to fetch.
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingTotalBalances to fetch.
     */
    orderBy?: BuffingTotalBalanceOrderByWithRelationInput | BuffingTotalBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuffingTotalBalances.
     */
    cursor?: BuffingTotalBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingTotalBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingTotalBalances.
     */
    skip?: number
    distinct?: BuffingTotalBalanceScalarFieldEnum | BuffingTotalBalanceScalarFieldEnum[]
  }

  /**
   * BuffingTotalBalance create
   */
  export type BuffingTotalBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a BuffingTotalBalance.
     */
    data: XOR<BuffingTotalBalanceCreateInput, BuffingTotalBalanceUncheckedCreateInput>
  }

  /**
   * BuffingTotalBalance createMany
   */
  export type BuffingTotalBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuffingTotalBalances.
     */
    data: BuffingTotalBalanceCreateManyInput | BuffingTotalBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuffingTotalBalance update
   */
  export type BuffingTotalBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a BuffingTotalBalance.
     */
    data: XOR<BuffingTotalBalanceUpdateInput, BuffingTotalBalanceUncheckedUpdateInput>
    /**
     * Choose, which BuffingTotalBalance to update.
     */
    where: BuffingTotalBalanceWhereUniqueInput
  }

  /**
   * BuffingTotalBalance updateMany
   */
  export type BuffingTotalBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuffingTotalBalances.
     */
    data: XOR<BuffingTotalBalanceUpdateManyMutationInput, BuffingTotalBalanceUncheckedUpdateManyInput>
    /**
     * Filter which BuffingTotalBalances to update
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * Limit how many BuffingTotalBalances to update.
     */
    limit?: number
  }

  /**
   * BuffingTotalBalance upsert
   */
  export type BuffingTotalBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the BuffingTotalBalance to update in case it exists.
     */
    where: BuffingTotalBalanceWhereUniqueInput
    /**
     * In case the BuffingTotalBalance found by the `where` argument doesn't exist, create a new BuffingTotalBalance with this data.
     */
    create: XOR<BuffingTotalBalanceCreateInput, BuffingTotalBalanceUncheckedCreateInput>
    /**
     * In case the BuffingTotalBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuffingTotalBalanceUpdateInput, BuffingTotalBalanceUncheckedUpdateInput>
  }

  /**
   * BuffingTotalBalance delete
   */
  export type BuffingTotalBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
    /**
     * Filter which BuffingTotalBalance to delete.
     */
    where: BuffingTotalBalanceWhereUniqueInput
  }

  /**
   * BuffingTotalBalance deleteMany
   */
  export type BuffingTotalBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingTotalBalances to delete
     */
    where?: BuffingTotalBalanceWhereInput
    /**
     * Limit how many BuffingTotalBalances to delete.
     */
    limit?: number
  }

  /**
   * BuffingTotalBalance without action
   */
  export type BuffingTotalBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingTotalBalance
     */
    select?: BuffingTotalBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingTotalBalance
     */
    omit?: BuffingTotalBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingTotalBalanceInclude<ExtArgs> | null
  }


  /**
   * Model LotBuffingMapper
   */

  export type AggregateLotBuffingMapper = {
    _count: LotBuffingMapperCountAggregateOutputType | null
    _avg: LotBuffingMapperAvgAggregateOutputType | null
    _sum: LotBuffingMapperSumAggregateOutputType | null
    _min: LotBuffingMapperMinAggregateOutputType | null
    _max: LotBuffingMapperMaxAggregateOutputType | null
  }

  export type LotBuffingMapperAvgAggregateOutputType = {
    id: number | null
    buffing_id: number | null
    lot_id: number | null
    setting_item_id: number | null
    filing_item_id: number | null
    buffing_entry_id: number | null
  }

  export type LotBuffingMapperSumAggregateOutputType = {
    id: number | null
    buffing_id: number | null
    lot_id: number | null
    setting_item_id: number | null
    filing_item_id: number | null
    buffing_entry_id: number | null
  }

  export type LotBuffingMapperMinAggregateOutputType = {
    id: number | null
    buffing_id: number | null
    lot_id: number | null
    setting_item_id: number | null
    filing_item_id: number | null
    buffing_entry_id: number | null
  }

  export type LotBuffingMapperMaxAggregateOutputType = {
    id: number | null
    buffing_id: number | null
    lot_id: number | null
    setting_item_id: number | null
    filing_item_id: number | null
    buffing_entry_id: number | null
  }

  export type LotBuffingMapperCountAggregateOutputType = {
    id: number
    buffing_id: number
    lot_id: number
    setting_item_id: number
    filing_item_id: number
    buffing_entry_id: number
    _all: number
  }


  export type LotBuffingMapperAvgAggregateInputType = {
    id?: true
    buffing_id?: true
    lot_id?: true
    setting_item_id?: true
    filing_item_id?: true
    buffing_entry_id?: true
  }

  export type LotBuffingMapperSumAggregateInputType = {
    id?: true
    buffing_id?: true
    lot_id?: true
    setting_item_id?: true
    filing_item_id?: true
    buffing_entry_id?: true
  }

  export type LotBuffingMapperMinAggregateInputType = {
    id?: true
    buffing_id?: true
    lot_id?: true
    setting_item_id?: true
    filing_item_id?: true
    buffing_entry_id?: true
  }

  export type LotBuffingMapperMaxAggregateInputType = {
    id?: true
    buffing_id?: true
    lot_id?: true
    setting_item_id?: true
    filing_item_id?: true
    buffing_entry_id?: true
  }

  export type LotBuffingMapperCountAggregateInputType = {
    id?: true
    buffing_id?: true
    lot_id?: true
    setting_item_id?: true
    filing_item_id?: true
    buffing_entry_id?: true
    _all?: true
  }

  export type LotBuffingMapperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotBuffingMapper to aggregate.
     */
    where?: LotBuffingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBuffingMappers to fetch.
     */
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotBuffingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBuffingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBuffingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotBuffingMappers
    **/
    _count?: true | LotBuffingMapperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotBuffingMapperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotBuffingMapperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotBuffingMapperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotBuffingMapperMaxAggregateInputType
  }

  export type GetLotBuffingMapperAggregateType<T extends LotBuffingMapperAggregateArgs> = {
        [P in keyof T & keyof AggregateLotBuffingMapper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotBuffingMapper[P]>
      : GetScalarType<T[P], AggregateLotBuffingMapper[P]>
  }




  export type LotBuffingMapperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBuffingMapperWhereInput
    orderBy?: LotBuffingMapperOrderByWithAggregationInput | LotBuffingMapperOrderByWithAggregationInput[]
    by: LotBuffingMapperScalarFieldEnum[] | LotBuffingMapperScalarFieldEnum
    having?: LotBuffingMapperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotBuffingMapperCountAggregateInputType | true
    _avg?: LotBuffingMapperAvgAggregateInputType
    _sum?: LotBuffingMapperSumAggregateInputType
    _min?: LotBuffingMapperMinAggregateInputType
    _max?: LotBuffingMapperMaxAggregateInputType
  }

  export type LotBuffingMapperGroupByOutputType = {
    id: number
    buffing_id: number
    lot_id: number
    setting_item_id: number | null
    filing_item_id: number | null
    buffing_entry_id: number
    _count: LotBuffingMapperCountAggregateOutputType | null
    _avg: LotBuffingMapperAvgAggregateOutputType | null
    _sum: LotBuffingMapperSumAggregateOutputType | null
    _min: LotBuffingMapperMinAggregateOutputType | null
    _max: LotBuffingMapperMaxAggregateOutputType | null
  }

  type GetLotBuffingMapperGroupByPayload<T extends LotBuffingMapperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotBuffingMapperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotBuffingMapperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotBuffingMapperGroupByOutputType[P]>
            : GetScalarType<T[P], LotBuffingMapperGroupByOutputType[P]>
        }
      >
    >


  export type LotBuffingMapperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buffing_id?: boolean
    lot_id?: boolean
    setting_item_id?: boolean
    filing_item_id?: boolean
    buffing_entry_id?: boolean
    buffingId?: boolean | AddBuffingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    settingItemId?: boolean | LotBuffingMapper$settingItemIdArgs<ExtArgs>
    filingItemId?: boolean | LotBuffingMapper$filingItemIdArgs<ExtArgs>
    buffingEntry?: boolean | BuffingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotBuffingMapper"]>



  export type LotBuffingMapperSelectScalar = {
    id?: boolean
    buffing_id?: boolean
    lot_id?: boolean
    setting_item_id?: boolean
    filing_item_id?: boolean
    buffing_entry_id?: boolean
  }

  export type LotBuffingMapperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buffing_id" | "lot_id" | "setting_item_id" | "filing_item_id" | "buffing_entry_id", ExtArgs["result"]["lotBuffingMapper"]>
  export type LotBuffingMapperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffingId?: boolean | AddBuffingDefaultArgs<ExtArgs>
    lotId?: boolean | LotInfoDefaultArgs<ExtArgs>
    settingItemId?: boolean | LotBuffingMapper$settingItemIdArgs<ExtArgs>
    filingItemId?: boolean | LotBuffingMapper$filingItemIdArgs<ExtArgs>
    buffingEntry?: boolean | BuffingEntryDefaultArgs<ExtArgs>
  }

  export type $LotBuffingMapperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotBuffingMapper"
    objects: {
      buffingId: Prisma.$AddBuffingPayload<ExtArgs>
      lotId: Prisma.$LotInfoPayload<ExtArgs>
      settingItemId: Prisma.$SettingItemsPayload<ExtArgs> | null
      filingItemId: Prisma.$FilingItemsPayload<ExtArgs> | null
      buffingEntry: Prisma.$BuffingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buffing_id: number
      lot_id: number
      setting_item_id: number | null
      filing_item_id: number | null
      buffing_entry_id: number
    }, ExtArgs["result"]["lotBuffingMapper"]>
    composites: {}
  }

  type LotBuffingMapperGetPayload<S extends boolean | null | undefined | LotBuffingMapperDefaultArgs> = $Result.GetResult<Prisma.$LotBuffingMapperPayload, S>

  type LotBuffingMapperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LotBuffingMapperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LotBuffingMapperCountAggregateInputType | true
    }

  export interface LotBuffingMapperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotBuffingMapper'], meta: { name: 'LotBuffingMapper' } }
    /**
     * Find zero or one LotBuffingMapper that matches the filter.
     * @param {LotBuffingMapperFindUniqueArgs} args - Arguments to find a LotBuffingMapper
     * @example
     * // Get one LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotBuffingMapperFindUniqueArgs>(args: SelectSubset<T, LotBuffingMapperFindUniqueArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LotBuffingMapper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LotBuffingMapperFindUniqueOrThrowArgs} args - Arguments to find a LotBuffingMapper
     * @example
     * // Get one LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotBuffingMapperFindUniqueOrThrowArgs>(args: SelectSubset<T, LotBuffingMapperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotBuffingMapper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperFindFirstArgs} args - Arguments to find a LotBuffingMapper
     * @example
     * // Get one LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotBuffingMapperFindFirstArgs>(args?: SelectSubset<T, LotBuffingMapperFindFirstArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LotBuffingMapper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperFindFirstOrThrowArgs} args - Arguments to find a LotBuffingMapper
     * @example
     * // Get one LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotBuffingMapperFindFirstOrThrowArgs>(args?: SelectSubset<T, LotBuffingMapperFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LotBuffingMappers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotBuffingMappers
     * const lotBuffingMappers = await prisma.lotBuffingMapper.findMany()
     * 
     * // Get first 10 LotBuffingMappers
     * const lotBuffingMappers = await prisma.lotBuffingMapper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotBuffingMapperWithIdOnly = await prisma.lotBuffingMapper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotBuffingMapperFindManyArgs>(args?: SelectSubset<T, LotBuffingMapperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LotBuffingMapper.
     * @param {LotBuffingMapperCreateArgs} args - Arguments to create a LotBuffingMapper.
     * @example
     * // Create one LotBuffingMapper
     * const LotBuffingMapper = await prisma.lotBuffingMapper.create({
     *   data: {
     *     // ... data to create a LotBuffingMapper
     *   }
     * })
     * 
     */
    create<T extends LotBuffingMapperCreateArgs>(args: SelectSubset<T, LotBuffingMapperCreateArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LotBuffingMappers.
     * @param {LotBuffingMapperCreateManyArgs} args - Arguments to create many LotBuffingMappers.
     * @example
     * // Create many LotBuffingMappers
     * const lotBuffingMapper = await prisma.lotBuffingMapper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotBuffingMapperCreateManyArgs>(args?: SelectSubset<T, LotBuffingMapperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LotBuffingMapper.
     * @param {LotBuffingMapperDeleteArgs} args - Arguments to delete one LotBuffingMapper.
     * @example
     * // Delete one LotBuffingMapper
     * const LotBuffingMapper = await prisma.lotBuffingMapper.delete({
     *   where: {
     *     // ... filter to delete one LotBuffingMapper
     *   }
     * })
     * 
     */
    delete<T extends LotBuffingMapperDeleteArgs>(args: SelectSubset<T, LotBuffingMapperDeleteArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LotBuffingMapper.
     * @param {LotBuffingMapperUpdateArgs} args - Arguments to update one LotBuffingMapper.
     * @example
     * // Update one LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotBuffingMapperUpdateArgs>(args: SelectSubset<T, LotBuffingMapperUpdateArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LotBuffingMappers.
     * @param {LotBuffingMapperDeleteManyArgs} args - Arguments to filter LotBuffingMappers to delete.
     * @example
     * // Delete a few LotBuffingMappers
     * const { count } = await prisma.lotBuffingMapper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotBuffingMapperDeleteManyArgs>(args?: SelectSubset<T, LotBuffingMapperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotBuffingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotBuffingMappers
     * const lotBuffingMapper = await prisma.lotBuffingMapper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotBuffingMapperUpdateManyArgs>(args: SelectSubset<T, LotBuffingMapperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotBuffingMapper.
     * @param {LotBuffingMapperUpsertArgs} args - Arguments to update or create a LotBuffingMapper.
     * @example
     * // Update or create a LotBuffingMapper
     * const lotBuffingMapper = await prisma.lotBuffingMapper.upsert({
     *   create: {
     *     // ... data to create a LotBuffingMapper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotBuffingMapper we want to update
     *   }
     * })
     */
    upsert<T extends LotBuffingMapperUpsertArgs>(args: SelectSubset<T, LotBuffingMapperUpsertArgs<ExtArgs>>): Prisma__LotBuffingMapperClient<$Result.GetResult<Prisma.$LotBuffingMapperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LotBuffingMappers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperCountArgs} args - Arguments to filter LotBuffingMappers to count.
     * @example
     * // Count the number of LotBuffingMappers
     * const count = await prisma.lotBuffingMapper.count({
     *   where: {
     *     // ... the filter for the LotBuffingMappers we want to count
     *   }
     * })
    **/
    count<T extends LotBuffingMapperCountArgs>(
      args?: Subset<T, LotBuffingMapperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotBuffingMapperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotBuffingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotBuffingMapperAggregateArgs>(args: Subset<T, LotBuffingMapperAggregateArgs>): Prisma.PrismaPromise<GetLotBuffingMapperAggregateType<T>>

    /**
     * Group by LotBuffingMapper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBuffingMapperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotBuffingMapperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotBuffingMapperGroupByArgs['orderBy'] }
        : { orderBy?: LotBuffingMapperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotBuffingMapperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotBuffingMapperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotBuffingMapper model
   */
  readonly fields: LotBuffingMapperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotBuffingMapper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotBuffingMapperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buffingId<T extends AddBuffingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddBuffingDefaultArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lotId<T extends LotInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotInfoDefaultArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    settingItemId<T extends LotBuffingMapper$settingItemIdArgs<ExtArgs> = {}>(args?: Subset<T, LotBuffingMapper$settingItemIdArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    filingItemId<T extends LotBuffingMapper$filingItemIdArgs<ExtArgs> = {}>(args?: Subset<T, LotBuffingMapper$filingItemIdArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buffingEntry<T extends BuffingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuffingEntryDefaultArgs<ExtArgs>>): Prisma__BuffingEntryClient<$Result.GetResult<Prisma.$BuffingEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotBuffingMapper model
   */
  interface LotBuffingMapperFieldRefs {
    readonly id: FieldRef<"LotBuffingMapper", 'Int'>
    readonly buffing_id: FieldRef<"LotBuffingMapper", 'Int'>
    readonly lot_id: FieldRef<"LotBuffingMapper", 'Int'>
    readonly setting_item_id: FieldRef<"LotBuffingMapper", 'Int'>
    readonly filing_item_id: FieldRef<"LotBuffingMapper", 'Int'>
    readonly buffing_entry_id: FieldRef<"LotBuffingMapper", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LotBuffingMapper findUnique
   */
  export type LotBuffingMapperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotBuffingMapper to fetch.
     */
    where: LotBuffingMapperWhereUniqueInput
  }

  /**
   * LotBuffingMapper findUniqueOrThrow
   */
  export type LotBuffingMapperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotBuffingMapper to fetch.
     */
    where: LotBuffingMapperWhereUniqueInput
  }

  /**
   * LotBuffingMapper findFirst
   */
  export type LotBuffingMapperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotBuffingMapper to fetch.
     */
    where?: LotBuffingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBuffingMappers to fetch.
     */
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotBuffingMappers.
     */
    cursor?: LotBuffingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBuffingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBuffingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotBuffingMappers.
     */
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * LotBuffingMapper findFirstOrThrow
   */
  export type LotBuffingMapperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotBuffingMapper to fetch.
     */
    where?: LotBuffingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBuffingMappers to fetch.
     */
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotBuffingMappers.
     */
    cursor?: LotBuffingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBuffingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBuffingMappers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotBuffingMappers.
     */
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * LotBuffingMapper findMany
   */
  export type LotBuffingMapperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter, which LotBuffingMappers to fetch.
     */
    where?: LotBuffingMapperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBuffingMappers to fetch.
     */
    orderBy?: LotBuffingMapperOrderByWithRelationInput | LotBuffingMapperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotBuffingMappers.
     */
    cursor?: LotBuffingMapperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBuffingMappers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBuffingMappers.
     */
    skip?: number
    distinct?: LotBuffingMapperScalarFieldEnum | LotBuffingMapperScalarFieldEnum[]
  }

  /**
   * LotBuffingMapper create
   */
  export type LotBuffingMapperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * The data needed to create a LotBuffingMapper.
     */
    data: XOR<LotBuffingMapperCreateInput, LotBuffingMapperUncheckedCreateInput>
  }

  /**
   * LotBuffingMapper createMany
   */
  export type LotBuffingMapperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotBuffingMappers.
     */
    data: LotBuffingMapperCreateManyInput | LotBuffingMapperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotBuffingMapper update
   */
  export type LotBuffingMapperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * The data needed to update a LotBuffingMapper.
     */
    data: XOR<LotBuffingMapperUpdateInput, LotBuffingMapperUncheckedUpdateInput>
    /**
     * Choose, which LotBuffingMapper to update.
     */
    where: LotBuffingMapperWhereUniqueInput
  }

  /**
   * LotBuffingMapper updateMany
   */
  export type LotBuffingMapperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotBuffingMappers.
     */
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyInput>
    /**
     * Filter which LotBuffingMappers to update
     */
    where?: LotBuffingMapperWhereInput
    /**
     * Limit how many LotBuffingMappers to update.
     */
    limit?: number
  }

  /**
   * LotBuffingMapper upsert
   */
  export type LotBuffingMapperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * The filter to search for the LotBuffingMapper to update in case it exists.
     */
    where: LotBuffingMapperWhereUniqueInput
    /**
     * In case the LotBuffingMapper found by the `where` argument doesn't exist, create a new LotBuffingMapper with this data.
     */
    create: XOR<LotBuffingMapperCreateInput, LotBuffingMapperUncheckedCreateInput>
    /**
     * In case the LotBuffingMapper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotBuffingMapperUpdateInput, LotBuffingMapperUncheckedUpdateInput>
  }

  /**
   * LotBuffingMapper delete
   */
  export type LotBuffingMapperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
    /**
     * Filter which LotBuffingMapper to delete.
     */
    where: LotBuffingMapperWhereUniqueInput
  }

  /**
   * LotBuffingMapper deleteMany
   */
  export type LotBuffingMapperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotBuffingMappers to delete
     */
    where?: LotBuffingMapperWhereInput
    /**
     * Limit how many LotBuffingMappers to delete.
     */
    limit?: number
  }

  /**
   * LotBuffingMapper.settingItemId
   */
  export type LotBuffingMapper$settingItemIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
  }

  /**
   * LotBuffingMapper.filingItemId
   */
  export type LotBuffingMapper$filingItemIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
  }

  /**
   * LotBuffingMapper without action
   */
  export type LotBuffingMapperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBuffingMapper
     */
    select?: LotBuffingMapperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotBuffingMapper
     */
    omit?: LotBuffingMapperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBuffingMapperInclude<ExtArgs> | null
  }


  /**
   * Model BuffingWastage
   */

  export type AggregateBuffingWastage = {
    _count: BuffingWastageCountAggregateOutputType | null
    _avg: BuffingWastageAvgAggregateOutputType | null
    _sum: BuffingWastageSumAggregateOutputType | null
    _min: BuffingWastageMinAggregateOutputType | null
    _max: BuffingWastageMaxAggregateOutputType | null
  }

  export type BuffingWastageAvgAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    buffing_person_id: number | null
    buffing_lot_id: number | null
  }

  export type BuffingWastageSumAggregateOutputType = {
    id: number | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    buffing_person_id: number | null
    buffing_lot_id: number | null
  }

  export type BuffingWastageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    buffing_person_id: number | null
    buffing_lot_id: number | null
  }

  export type BuffingWastageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    total_receipt: number | null
    total_wastage: number | null
    balance: number | null
    wastage_percentage: number | null
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number | null
    closing_balance: number | null
    opening_balance: number | null
    buffing_person_id: number | null
    buffing_lot_id: number | null
  }

  export type BuffingWastageCountAggregateOutputType = {
    id: number
    createdAt: number
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number
    add_wastage: number
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id: number
    buffing_lot_id: number
    _all: number
  }


  export type BuffingWastageAvgAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    buffing_person_id?: true
    buffing_lot_id?: true
  }

  export type BuffingWastageSumAggregateInputType = {
    id?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    buffing_person_id?: true
    buffing_lot_id?: true
  }

  export type BuffingWastageMinAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    buffing_person_id?: true
    buffing_lot_id?: true
  }

  export type BuffingWastageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    buffing_person_id?: true
    buffing_lot_id?: true
  }

  export type BuffingWastageCountAggregateInputType = {
    id?: true
    createdAt?: true
    total_receipt?: true
    total_wastage?: true
    balance?: true
    wastage_percentage?: true
    given_gold?: true
    add_wastage?: true
    overall_wastage?: true
    closing_balance?: true
    opening_balance?: true
    buffing_person_id?: true
    buffing_lot_id?: true
    _all?: true
  }

  export type BuffingWastageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingWastage to aggregate.
     */
    where?: BuffingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingWastages to fetch.
     */
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuffingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuffingWastages
    **/
    _count?: true | BuffingWastageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuffingWastageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuffingWastageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuffingWastageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuffingWastageMaxAggregateInputType
  }

  export type GetBuffingWastageAggregateType<T extends BuffingWastageAggregateArgs> = {
        [P in keyof T & keyof AggregateBuffingWastage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuffingWastage[P]>
      : GetScalarType<T[P], AggregateBuffingWastage[P]>
  }




  export type BuffingWastageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuffingWastageWhereInput
    orderBy?: BuffingWastageOrderByWithAggregationInput | BuffingWastageOrderByWithAggregationInput[]
    by: BuffingWastageScalarFieldEnum[] | BuffingWastageScalarFieldEnum
    having?: BuffingWastageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuffingWastageCountAggregateInputType | true
    _avg?: BuffingWastageAvgAggregateInputType
    _sum?: BuffingWastageSumAggregateInputType
    _min?: BuffingWastageMinAggregateInputType
    _max?: BuffingWastageMaxAggregateInputType
  }

  export type BuffingWastageGroupByOutputType = {
    id: number
    createdAt: Date
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold: number | null
    add_wastage: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id: number | null
    buffing_lot_id: number | null
    _count: BuffingWastageCountAggregateOutputType | null
    _avg: BuffingWastageAvgAggregateOutputType | null
    _sum: BuffingWastageSumAggregateOutputType | null
    _min: BuffingWastageMinAggregateOutputType | null
    _max: BuffingWastageMaxAggregateOutputType | null
  }

  type GetBuffingWastageGroupByPayload<T extends BuffingWastageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuffingWastageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuffingWastageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuffingWastageGroupByOutputType[P]>
            : GetScalarType<T[P], BuffingWastageGroupByOutputType[P]>
        }
      >
    >


  export type BuffingWastageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    buffing_person_id?: boolean
    buffing_lot_id?: boolean
    buffingPersonId?: boolean | BuffingWastage$buffingPersonIdArgs<ExtArgs>
    buffingLotId?: boolean | BuffingWastage$buffingLotIdArgs<ExtArgs>
    buffing_items?: boolean | BuffingWastage$buffing_itemsArgs<ExtArgs>
    _count?: boolean | BuffingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buffingWastage"]>



  export type BuffingWastageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    total_receipt?: boolean
    total_wastage?: boolean
    balance?: boolean
    wastage_percentage?: boolean
    given_gold?: boolean
    add_wastage?: boolean
    overall_wastage?: boolean
    closing_balance?: boolean
    opening_balance?: boolean
    buffing_person_id?: boolean
    buffing_lot_id?: boolean
  }

  export type BuffingWastageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "total_receipt" | "total_wastage" | "balance" | "wastage_percentage" | "given_gold" | "add_wastage" | "overall_wastage" | "closing_balance" | "opening_balance" | "buffing_person_id" | "buffing_lot_id", ExtArgs["result"]["buffingWastage"]>
  export type BuffingWastageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buffingPersonId?: boolean | BuffingWastage$buffingPersonIdArgs<ExtArgs>
    buffingLotId?: boolean | BuffingWastage$buffingLotIdArgs<ExtArgs>
    buffing_items?: boolean | BuffingWastage$buffing_itemsArgs<ExtArgs>
    _count?: boolean | BuffingWastageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuffingWastagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuffingWastage"
    objects: {
      buffingPersonId: Prisma.$AddBuffingPayload<ExtArgs> | null
      buffingLotId: Prisma.$LotInfoPayload<ExtArgs> | null
      buffing_items: Prisma.$BuffingItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      total_receipt: number
      total_wastage: number
      balance: number
      wastage_percentage: number
      given_gold: number | null
      add_wastage: number | null
      overall_wastage: number
      closing_balance: number
      opening_balance: number
      buffing_person_id: number | null
      buffing_lot_id: number | null
    }, ExtArgs["result"]["buffingWastage"]>
    composites: {}
  }

  type BuffingWastageGetPayload<S extends boolean | null | undefined | BuffingWastageDefaultArgs> = $Result.GetResult<Prisma.$BuffingWastagePayload, S>

  type BuffingWastageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuffingWastageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuffingWastageCountAggregateInputType | true
    }

  export interface BuffingWastageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuffingWastage'], meta: { name: 'BuffingWastage' } }
    /**
     * Find zero or one BuffingWastage that matches the filter.
     * @param {BuffingWastageFindUniqueArgs} args - Arguments to find a BuffingWastage
     * @example
     * // Get one BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuffingWastageFindUniqueArgs>(args: SelectSubset<T, BuffingWastageFindUniqueArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuffingWastage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuffingWastageFindUniqueOrThrowArgs} args - Arguments to find a BuffingWastage
     * @example
     * // Get one BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuffingWastageFindUniqueOrThrowArgs>(args: SelectSubset<T, BuffingWastageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingWastage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageFindFirstArgs} args - Arguments to find a BuffingWastage
     * @example
     * // Get one BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuffingWastageFindFirstArgs>(args?: SelectSubset<T, BuffingWastageFindFirstArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuffingWastage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageFindFirstOrThrowArgs} args - Arguments to find a BuffingWastage
     * @example
     * // Get one BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuffingWastageFindFirstOrThrowArgs>(args?: SelectSubset<T, BuffingWastageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuffingWastages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuffingWastages
     * const buffingWastages = await prisma.buffingWastage.findMany()
     * 
     * // Get first 10 BuffingWastages
     * const buffingWastages = await prisma.buffingWastage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buffingWastageWithIdOnly = await prisma.buffingWastage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuffingWastageFindManyArgs>(args?: SelectSubset<T, BuffingWastageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuffingWastage.
     * @param {BuffingWastageCreateArgs} args - Arguments to create a BuffingWastage.
     * @example
     * // Create one BuffingWastage
     * const BuffingWastage = await prisma.buffingWastage.create({
     *   data: {
     *     // ... data to create a BuffingWastage
     *   }
     * })
     * 
     */
    create<T extends BuffingWastageCreateArgs>(args: SelectSubset<T, BuffingWastageCreateArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuffingWastages.
     * @param {BuffingWastageCreateManyArgs} args - Arguments to create many BuffingWastages.
     * @example
     * // Create many BuffingWastages
     * const buffingWastage = await prisma.buffingWastage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuffingWastageCreateManyArgs>(args?: SelectSubset<T, BuffingWastageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuffingWastage.
     * @param {BuffingWastageDeleteArgs} args - Arguments to delete one BuffingWastage.
     * @example
     * // Delete one BuffingWastage
     * const BuffingWastage = await prisma.buffingWastage.delete({
     *   where: {
     *     // ... filter to delete one BuffingWastage
     *   }
     * })
     * 
     */
    delete<T extends BuffingWastageDeleteArgs>(args: SelectSubset<T, BuffingWastageDeleteArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuffingWastage.
     * @param {BuffingWastageUpdateArgs} args - Arguments to update one BuffingWastage.
     * @example
     * // Update one BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuffingWastageUpdateArgs>(args: SelectSubset<T, BuffingWastageUpdateArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuffingWastages.
     * @param {BuffingWastageDeleteManyArgs} args - Arguments to filter BuffingWastages to delete.
     * @example
     * // Delete a few BuffingWastages
     * const { count } = await prisma.buffingWastage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuffingWastageDeleteManyArgs>(args?: SelectSubset<T, BuffingWastageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuffingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuffingWastages
     * const buffingWastage = await prisma.buffingWastage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuffingWastageUpdateManyArgs>(args: SelectSubset<T, BuffingWastageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuffingWastage.
     * @param {BuffingWastageUpsertArgs} args - Arguments to update or create a BuffingWastage.
     * @example
     * // Update or create a BuffingWastage
     * const buffingWastage = await prisma.buffingWastage.upsert({
     *   create: {
     *     // ... data to create a BuffingWastage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuffingWastage we want to update
     *   }
     * })
     */
    upsert<T extends BuffingWastageUpsertArgs>(args: SelectSubset<T, BuffingWastageUpsertArgs<ExtArgs>>): Prisma__BuffingWastageClient<$Result.GetResult<Prisma.$BuffingWastagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuffingWastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageCountArgs} args - Arguments to filter BuffingWastages to count.
     * @example
     * // Count the number of BuffingWastages
     * const count = await prisma.buffingWastage.count({
     *   where: {
     *     // ... the filter for the BuffingWastages we want to count
     *   }
     * })
    **/
    count<T extends BuffingWastageCountArgs>(
      args?: Subset<T, BuffingWastageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuffingWastageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuffingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuffingWastageAggregateArgs>(args: Subset<T, BuffingWastageAggregateArgs>): Prisma.PrismaPromise<GetBuffingWastageAggregateType<T>>

    /**
     * Group by BuffingWastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuffingWastageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuffingWastageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuffingWastageGroupByArgs['orderBy'] }
        : { orderBy?: BuffingWastageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuffingWastageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuffingWastageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuffingWastage model
   */
  readonly fields: BuffingWastageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuffingWastage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuffingWastageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buffingPersonId<T extends BuffingWastage$buffingPersonIdArgs<ExtArgs> = {}>(args?: Subset<T, BuffingWastage$buffingPersonIdArgs<ExtArgs>>): Prisma__AddBuffingClient<$Result.GetResult<Prisma.$AddBuffingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buffingLotId<T extends BuffingWastage$buffingLotIdArgs<ExtArgs> = {}>(args?: Subset<T, BuffingWastage$buffingLotIdArgs<ExtArgs>>): Prisma__LotInfoClient<$Result.GetResult<Prisma.$LotInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buffing_items<T extends BuffingWastage$buffing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, BuffingWastage$buffing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuffingWastage model
   */
  interface BuffingWastageFieldRefs {
    readonly id: FieldRef<"BuffingWastage", 'Int'>
    readonly createdAt: FieldRef<"BuffingWastage", 'DateTime'>
    readonly total_receipt: FieldRef<"BuffingWastage", 'Float'>
    readonly total_wastage: FieldRef<"BuffingWastage", 'Float'>
    readonly balance: FieldRef<"BuffingWastage", 'Float'>
    readonly wastage_percentage: FieldRef<"BuffingWastage", 'Int'>
    readonly given_gold: FieldRef<"BuffingWastage", 'Float'>
    readonly add_wastage: FieldRef<"BuffingWastage", 'Float'>
    readonly overall_wastage: FieldRef<"BuffingWastage", 'Float'>
    readonly closing_balance: FieldRef<"BuffingWastage", 'Float'>
    readonly opening_balance: FieldRef<"BuffingWastage", 'Float'>
    readonly buffing_person_id: FieldRef<"BuffingWastage", 'Int'>
    readonly buffing_lot_id: FieldRef<"BuffingWastage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BuffingWastage findUnique
   */
  export type BuffingWastageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter, which BuffingWastage to fetch.
     */
    where: BuffingWastageWhereUniqueInput
  }

  /**
   * BuffingWastage findUniqueOrThrow
   */
  export type BuffingWastageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter, which BuffingWastage to fetch.
     */
    where: BuffingWastageWhereUniqueInput
  }

  /**
   * BuffingWastage findFirst
   */
  export type BuffingWastageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter, which BuffingWastage to fetch.
     */
    where?: BuffingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingWastages to fetch.
     */
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingWastages.
     */
    cursor?: BuffingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingWastages.
     */
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * BuffingWastage findFirstOrThrow
   */
  export type BuffingWastageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter, which BuffingWastage to fetch.
     */
    where?: BuffingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingWastages to fetch.
     */
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuffingWastages.
     */
    cursor?: BuffingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingWastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuffingWastages.
     */
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * BuffingWastage findMany
   */
  export type BuffingWastageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter, which BuffingWastages to fetch.
     */
    where?: BuffingWastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuffingWastages to fetch.
     */
    orderBy?: BuffingWastageOrderByWithRelationInput | BuffingWastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuffingWastages.
     */
    cursor?: BuffingWastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuffingWastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuffingWastages.
     */
    skip?: number
    distinct?: BuffingWastageScalarFieldEnum | BuffingWastageScalarFieldEnum[]
  }

  /**
   * BuffingWastage create
   */
  export type BuffingWastageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * The data needed to create a BuffingWastage.
     */
    data: XOR<BuffingWastageCreateInput, BuffingWastageUncheckedCreateInput>
  }

  /**
   * BuffingWastage createMany
   */
  export type BuffingWastageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuffingWastages.
     */
    data: BuffingWastageCreateManyInput | BuffingWastageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuffingWastage update
   */
  export type BuffingWastageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * The data needed to update a BuffingWastage.
     */
    data: XOR<BuffingWastageUpdateInput, BuffingWastageUncheckedUpdateInput>
    /**
     * Choose, which BuffingWastage to update.
     */
    where: BuffingWastageWhereUniqueInput
  }

  /**
   * BuffingWastage updateMany
   */
  export type BuffingWastageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuffingWastages.
     */
    data: XOR<BuffingWastageUpdateManyMutationInput, BuffingWastageUncheckedUpdateManyInput>
    /**
     * Filter which BuffingWastages to update
     */
    where?: BuffingWastageWhereInput
    /**
     * Limit how many BuffingWastages to update.
     */
    limit?: number
  }

  /**
   * BuffingWastage upsert
   */
  export type BuffingWastageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * The filter to search for the BuffingWastage to update in case it exists.
     */
    where: BuffingWastageWhereUniqueInput
    /**
     * In case the BuffingWastage found by the `where` argument doesn't exist, create a new BuffingWastage with this data.
     */
    create: XOR<BuffingWastageCreateInput, BuffingWastageUncheckedCreateInput>
    /**
     * In case the BuffingWastage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuffingWastageUpdateInput, BuffingWastageUncheckedUpdateInput>
  }

  /**
   * BuffingWastage delete
   */
  export type BuffingWastageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
    /**
     * Filter which BuffingWastage to delete.
     */
    where: BuffingWastageWhereUniqueInput
  }

  /**
   * BuffingWastage deleteMany
   */
  export type BuffingWastageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuffingWastages to delete
     */
    where?: BuffingWastageWhereInput
    /**
     * Limit how many BuffingWastages to delete.
     */
    limit?: number
  }

  /**
   * BuffingWastage.buffingPersonId
   */
  export type BuffingWastage$buffingPersonIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddBuffing
     */
    select?: AddBuffingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddBuffing
     */
    omit?: AddBuffingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddBuffingInclude<ExtArgs> | null
    where?: AddBuffingWhereInput
  }

  /**
   * BuffingWastage.buffingLotId
   */
  export type BuffingWastage$buffingLotIdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotInfo
     */
    select?: LotInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LotInfo
     */
    omit?: LotInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInfoInclude<ExtArgs> | null
    where?: LotInfoWhereInput
  }

  /**
   * BuffingWastage.buffing_items
   */
  export type BuffingWastage$buffing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    where?: BuffingItemsWhereInput
    orderBy?: BuffingItemsOrderByWithRelationInput | BuffingItemsOrderByWithRelationInput[]
    cursor?: BuffingItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuffingItemsScalarFieldEnum | BuffingItemsScalarFieldEnum[]
  }

  /**
   * BuffingWastage without action
   */
  export type BuffingWastageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingWastage
     */
    select?: BuffingWastageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingWastage
     */
    omit?: BuffingWastageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingWastageInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    id: number | null
    casting_item_id: number | null
    filing_item_id: number | null
    setting_item_id: number | null
    buffing_item_id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    casting_customer_id: number | null
  }

  export type StockSumAggregateOutputType = {
    id: number | null
    casting_item_id: number | null
    filing_item_id: number | null
    setting_item_id: number | null
    buffing_item_id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    casting_customer_id: number | null
  }

  export type StockMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    casting_item_id: number | null
    filing_item_id: number | null
    setting_item_id: number | null
    buffing_item_id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    casting_customer_id: number | null
  }

  export type StockMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    casting_item_id: number | null
    filing_item_id: number | null
    setting_item_id: number | null
    buffing_item_id: number | null
    item_id: number | null
    weight: number | null
    touch_id: number | null
    item_purity: number | null
    remarks: string | null
    casting_customer_id: number | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    createdAt: number
    casting_item_id: number
    filing_item_id: number
    setting_item_id: number
    buffing_item_id: number
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: number
    casting_customer_id: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    id?: true
    casting_item_id?: true
    filing_item_id?: true
    setting_item_id?: true
    buffing_item_id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    casting_customer_id?: true
  }

  export type StockSumAggregateInputType = {
    id?: true
    casting_item_id?: true
    filing_item_id?: true
    setting_item_id?: true
    buffing_item_id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    casting_customer_id?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    createdAt?: true
    casting_item_id?: true
    filing_item_id?: true
    setting_item_id?: true
    buffing_item_id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_customer_id?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    createdAt?: true
    casting_item_id?: true
    filing_item_id?: true
    setting_item_id?: true
    buffing_item_id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_customer_id?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    createdAt?: true
    casting_item_id?: true
    filing_item_id?: true
    setting_item_id?: true
    buffing_item_id?: true
    item_id?: true
    weight?: true
    touch_id?: true
    item_purity?: true
    remarks?: true
    casting_customer_id?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: number
    createdAt: Date
    casting_item_id: number | null
    filing_item_id: number | null
    setting_item_id: number | null
    buffing_item_id: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks: string | null
    casting_customer_id: number
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    casting_item_id?: boolean
    filing_item_id?: boolean
    setting_item_id?: boolean
    buffing_item_id?: boolean
    item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    casting_customer_id?: boolean
    castingItem?: boolean | Stock$castingItemArgs<ExtArgs>
    filingItem?: boolean | Stock$filingItemArgs<ExtArgs>
    settingItem?: boolean | Stock$settingItemArgs<ExtArgs>
    buffingItem?: boolean | Stock$buffingItemArgs<ExtArgs>
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>



  export type StockSelectScalar = {
    id?: boolean
    createdAt?: boolean
    casting_item_id?: boolean
    filing_item_id?: boolean
    setting_item_id?: boolean
    buffing_item_id?: boolean
    item_id?: boolean
    weight?: boolean
    touch_id?: boolean
    item_purity?: boolean
    remarks?: boolean
    casting_customer_id?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "casting_item_id" | "filing_item_id" | "setting_item_id" | "buffing_item_id" | "item_id" | "weight" | "touch_id" | "item_purity" | "remarks" | "casting_customer_id", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    castingItem?: boolean | Stock$castingItemArgs<ExtArgs>
    filingItem?: boolean | Stock$filingItemArgs<ExtArgs>
    settingItem?: boolean | Stock$settingItemArgs<ExtArgs>
    buffingItem?: boolean | Stock$buffingItemArgs<ExtArgs>
    item?: boolean | AddItemDefaultArgs<ExtArgs>
    touch?: boolean | AddTouchDefaultArgs<ExtArgs>
    casting_customer?: boolean | AddCastingDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      castingItem: Prisma.$CastingItemsPayload<ExtArgs> | null
      filingItem: Prisma.$FilingItemsPayload<ExtArgs> | null
      settingItem: Prisma.$SettingItemsPayload<ExtArgs> | null
      buffingItem: Prisma.$BuffingItemsPayload<ExtArgs> | null
      item: Prisma.$AddItemPayload<ExtArgs>
      touch: Prisma.$AddTouchPayload<ExtArgs>
      casting_customer: Prisma.$AddCastingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      casting_item_id: number | null
      filing_item_id: number | null
      setting_item_id: number | null
      buffing_item_id: number | null
      item_id: number
      weight: number
      touch_id: number
      item_purity: number
      remarks: string | null
      casting_customer_id: number
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    castingItem<T extends Stock$castingItemArgs<ExtArgs> = {}>(args?: Subset<T, Stock$castingItemArgs<ExtArgs>>): Prisma__CastingItemsClient<$Result.GetResult<Prisma.$CastingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    filingItem<T extends Stock$filingItemArgs<ExtArgs> = {}>(args?: Subset<T, Stock$filingItemArgs<ExtArgs>>): Prisma__FilingItemsClient<$Result.GetResult<Prisma.$FilingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settingItem<T extends Stock$settingItemArgs<ExtArgs> = {}>(args?: Subset<T, Stock$settingItemArgs<ExtArgs>>): Prisma__SettingItemsClient<$Result.GetResult<Prisma.$SettingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buffingItem<T extends Stock$buffingItemArgs<ExtArgs> = {}>(args?: Subset<T, Stock$buffingItemArgs<ExtArgs>>): Prisma__BuffingItemsClient<$Result.GetResult<Prisma.$BuffingItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    item<T extends AddItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddItemDefaultArgs<ExtArgs>>): Prisma__AddItemClient<$Result.GetResult<Prisma.$AddItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    touch<T extends AddTouchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddTouchDefaultArgs<ExtArgs>>): Prisma__AddTouchClient<$Result.GetResult<Prisma.$AddTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    casting_customer<T extends AddCastingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddCastingDefaultArgs<ExtArgs>>): Prisma__AddCastingClient<$Result.GetResult<Prisma.$AddCastingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'Int'>
    readonly createdAt: FieldRef<"Stock", 'DateTime'>
    readonly casting_item_id: FieldRef<"Stock", 'Int'>
    readonly filing_item_id: FieldRef<"Stock", 'Int'>
    readonly setting_item_id: FieldRef<"Stock", 'Int'>
    readonly buffing_item_id: FieldRef<"Stock", 'Int'>
    readonly item_id: FieldRef<"Stock", 'Int'>
    readonly weight: FieldRef<"Stock", 'Float'>
    readonly touch_id: FieldRef<"Stock", 'Int'>
    readonly item_purity: FieldRef<"Stock", 'Float'>
    readonly remarks: FieldRef<"Stock", 'String'>
    readonly casting_customer_id: FieldRef<"Stock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock.castingItem
   */
  export type Stock$castingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CastingItems
     */
    select?: CastingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CastingItems
     */
    omit?: CastingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CastingItemsInclude<ExtArgs> | null
    where?: CastingItemsWhereInput
  }

  /**
   * Stock.filingItem
   */
  export type Stock$filingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilingItems
     */
    select?: FilingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilingItems
     */
    omit?: FilingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilingItemsInclude<ExtArgs> | null
    where?: FilingItemsWhereInput
  }

  /**
   * Stock.settingItem
   */
  export type Stock$settingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingItems
     */
    select?: SettingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SettingItems
     */
    omit?: SettingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingItemsInclude<ExtArgs> | null
    where?: SettingItemsWhereInput
  }

  /**
   * Stock.buffingItem
   */
  export type Stock$buffingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuffingItems
     */
    select?: BuffingItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuffingItems
     */
    omit?: BuffingItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuffingItemsInclude<ExtArgs> | null
    where?: BuffingItemsWhereInput
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AddCustomerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddCustomerScalarFieldEnum = (typeof AddCustomerScalarFieldEnum)[keyof typeof AddCustomerScalarFieldEnum]


  export const AddCastingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddCastingScalarFieldEnum = (typeof AddCastingScalarFieldEnum)[keyof typeof AddCastingScalarFieldEnum]


  export const AddFilingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddFilingScalarFieldEnum = (typeof AddFilingScalarFieldEnum)[keyof typeof AddFilingScalarFieldEnum]


  export const AddSettingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddSettingScalarFieldEnum = (typeof AddSettingScalarFieldEnum)[keyof typeof AddSettingScalarFieldEnum]


  export const AddBuffingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddBuffingScalarFieldEnum = (typeof AddBuffingScalarFieldEnum)[keyof typeof AddBuffingScalarFieldEnum]


  export const AddSupplierItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    address: 'address'
  };

  export type AddSupplierItemScalarFieldEnum = (typeof AddSupplierItemScalarFieldEnum)[keyof typeof AddSupplierItemScalarFieldEnum]


  export const AddPurchaseStockScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    item: 'item',
    goldWeight: 'goldWeight',
    goldTouch: 'goldTouch',
    goldPurity: 'goldPurity',
    goldRate: 'goldRate',
    goldtotalValue: 'goldtotalValue',
    silverWeight: 'silverWeight',
    silverTouch: 'silverTouch',
    silverPurity: 'silverPurity',
    silverRate: 'silverRate',
    silvertotalValue: 'silvertotalValue'
  };

  export type AddPurchaseStockScalarFieldEnum = (typeof AddPurchaseStockScalarFieldEnum)[keyof typeof AddPurchaseStockScalarFieldEnum]


  export const CustomerTransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    value: 'value',
    type: 'type',
    touch: 'touch',
    purity: 'purity',
    goldRate: 'goldRate',
    customerId: 'customerId'
  };

  export type CustomerTransactionScalarFieldEnum = (typeof CustomerTransactionScalarFieldEnum)[keyof typeof CustomerTransactionScalarFieldEnum]


  export const AddItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name'
  };

  export type AddItemScalarFieldEnum = (typeof AddItemScalarFieldEnum)[keyof typeof AddItemScalarFieldEnum]


  export const AddTouchScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    touch: 'touch'
  };

  export type AddTouchScalarFieldEnum = (typeof AddTouchScalarFieldEnum)[keyof typeof AddTouchScalarFieldEnum]


  export const CastingEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    given_gold: 'given_gold',
    touch_id: 'touch_id',
    purity: 'purity',
    final_touch: 'final_touch',
    pure_value: 'pure_value',
    copper: 'copper',
    final_weight: 'final_weight',
    casting_customer_id: 'casting_customer_id'
  };

  export type CastingEntryScalarFieldEnum = (typeof CastingEntryScalarFieldEnum)[keyof typeof CastingEntryScalarFieldEnum]


  export const CastingItemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    type: 'type',
    item_id: 'item_id',
    weight: 'weight',
    touch_id: 'touch_id',
    item_purity: 'item_purity',
    remarks: 'remarks',
    casting_entry_id: 'casting_entry_id',
    casting_customer_id: 'casting_customer_id'
  };

  export type CastingItemsScalarFieldEnum = (typeof CastingItemsScalarFieldEnum)[keyof typeof CastingItemsScalarFieldEnum]


  export const CastiingTotalBalanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    total_item_weight: 'total_item_weight',
    current_balance_weight: 'current_balance_weight',
    total_scrap_weight: 'total_scrap_weight',
    total_wastage: 'total_wastage',
    item_entry: 'item_entry'
  };

  export type CastiingTotalBalanceScalarFieldEnum = (typeof CastiingTotalBalanceScalarFieldEnum)[keyof typeof CastiingTotalBalanceScalarFieldEnum]


  export const LotInfoScalarFieldEnum: {
    id: 'id',
    lotNumber: 'lotNumber',
    filing_customer_id: 'filing_customer_id',
    setting_customer_id: 'setting_customer_id',
    buffing_customer_id: 'buffing_customer_id',
    IsActive: 'IsActive'
  };

  export type LotInfoScalarFieldEnum = (typeof LotInfoScalarFieldEnum)[keyof typeof LotInfoScalarFieldEnum]


  export const FilingEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    filing_person_id: 'filing_person_id',
    casting_item_id: 'casting_item_id'
  };

  export type FilingEntryScalarFieldEnum = (typeof FilingEntryScalarFieldEnum)[keyof typeof FilingEntryScalarFieldEnum]


  export const LotFilingMapperScalarFieldEnum: {
    id: 'id',
    filing_id: 'filing_id',
    lot_id: 'lot_id',
    item_id: 'item_id',
    filing_entry_id: 'filing_entry_id'
  };

  export type LotFilingMapperScalarFieldEnum = (typeof LotFilingMapperScalarFieldEnum)[keyof typeof LotFilingMapperScalarFieldEnum]


  export const FilingItemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    filing_entry_id: 'filing_entry_id',
    type: 'type',
    filing_item_id: 'filing_item_id',
    weight: 'weight',
    touch_id: 'touch_id',
    item_purity: 'item_purity',
    remarks: 'remarks',
    stone_option: 'stone_option',
    lot_filing_mapper_id: 'lot_filing_mapper_id'
  };

  export type FilingItemsScalarFieldEnum = (typeof FilingItemsScalarFieldEnum)[keyof typeof FilingItemsScalarFieldEnum]


  export const FilingTotalBalanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    after_weight: 'after_weight',
    total_product_weight: 'total_product_weight',
    current_balance_weight: 'current_balance_weight',
    total_scrap_weight: 'total_scrap_weight',
    wastage: 'wastage',
    balance: 'balance',
    filing_entry_id: 'filing_entry_id'
  };

  export type FilingTotalBalanceScalarFieldEnum = (typeof FilingTotalBalanceScalarFieldEnum)[keyof typeof FilingTotalBalanceScalarFieldEnum]


  export const FilingWastageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    total_receipt: 'total_receipt',
    total_wastage: 'total_wastage',
    balance: 'balance',
    wastage_percentage: 'wastage_percentage',
    given_gold: 'given_gold',
    add_wastage: 'add_wastage',
    overall_wastage: 'overall_wastage',
    closing_balance: 'closing_balance',
    opening_balance: 'opening_balance',
    filing_person_id: 'filing_person_id',
    filing_lot_id: 'filing_lot_id'
  };

  export type FilingWastageScalarFieldEnum = (typeof FilingWastageScalarFieldEnum)[keyof typeof FilingWastageScalarFieldEnum]


  export const SettingEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    setting_person_id: 'setting_person_id',
    casting_item_id: 'casting_item_id'
  };

  export type SettingEntryScalarFieldEnum = (typeof SettingEntryScalarFieldEnum)[keyof typeof SettingEntryScalarFieldEnum]


  export const SettingItemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    type: 'type',
    setting_item_id: 'setting_item_id',
    scrap_weight: 'scrap_weight',
    touch_id: 'touch_id',
    item_purity: 'item_purity',
    scrap_remarks: 'scrap_remarks',
    setting_entry_id: 'setting_entry_id'
  };

  export type SettingItemsScalarFieldEnum = (typeof SettingItemsScalarFieldEnum)[keyof typeof SettingItemsScalarFieldEnum]


  export const LotSettingMapperScalarFieldEnum: {
    id: 'id',
    setting_id: 'setting_id',
    lot_id: 'lot_id',
    filing_item_id: 'filing_item_id',
    setting_entry_id: 'setting_entry_id'
  };

  export type LotSettingMapperScalarFieldEnum = (typeof LotSettingMapperScalarFieldEnum)[keyof typeof LotSettingMapperScalarFieldEnum]


  export const SettingTotalBalanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    receipt_weight: 'receipt_weight',
    stone_count: 'stone_count',
    stone_weight: 'stone_weight',
    remarks: 'remarks',
    wastage: 'wastage',
    total_product_weight: 'total_product_weight',
    current_balance_weight: 'current_balance_weight',
    total_scrap_weight: 'total_scrap_weight',
    balance: 'balance',
    setting_entry_id: 'setting_entry_id'
  };

  export type SettingTotalBalanceScalarFieldEnum = (typeof SettingTotalBalanceScalarFieldEnum)[keyof typeof SettingTotalBalanceScalarFieldEnum]


  export const SettingWastageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    total_receipt: 'total_receipt',
    total_wastage: 'total_wastage',
    balance: 'balance',
    wastage_percentage: 'wastage_percentage',
    given_gold: 'given_gold',
    add_wastage: 'add_wastage',
    overall_wastage: 'overall_wastage',
    closing_balance: 'closing_balance',
    opening_balance: 'opening_balance',
    setting_entry_id: 'setting_entry_id'
  };

  export type SettingWastageScalarFieldEnum = (typeof SettingWastageScalarFieldEnum)[keyof typeof SettingWastageScalarFieldEnum]


  export const BuffingEntryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    buffing_person_id: 'buffing_person_id',
    casting_item_id: 'casting_item_id'
  };

  export type BuffingEntryScalarFieldEnum = (typeof BuffingEntryScalarFieldEnum)[keyof typeof BuffingEntryScalarFieldEnum]


  export const BuffingItemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    type: 'type',
    buffing_item_id: 'buffing_item_id',
    scrap_weight: 'scrap_weight',
    touch_id: 'touch_id',
    item_purity: 'item_purity',
    scrap_remarks: 'scrap_remarks',
    buffing_entry_id: 'buffing_entry_id'
  };

  export type BuffingItemsScalarFieldEnum = (typeof BuffingItemsScalarFieldEnum)[keyof typeof BuffingItemsScalarFieldEnum]


  export const BuffingTotalBalanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    receipt_weight: 'receipt_weight',
    remarks: 'remarks',
    wastage: 'wastage',
    total_scrap_weight: 'total_scrap_weight',
    balance: 'balance',
    buffing_entry_id: 'buffing_entry_id'
  };

  export type BuffingTotalBalanceScalarFieldEnum = (typeof BuffingTotalBalanceScalarFieldEnum)[keyof typeof BuffingTotalBalanceScalarFieldEnum]


  export const LotBuffingMapperScalarFieldEnum: {
    id: 'id',
    buffing_id: 'buffing_id',
    lot_id: 'lot_id',
    setting_item_id: 'setting_item_id',
    filing_item_id: 'filing_item_id',
    buffing_entry_id: 'buffing_entry_id'
  };

  export type LotBuffingMapperScalarFieldEnum = (typeof LotBuffingMapperScalarFieldEnum)[keyof typeof LotBuffingMapperScalarFieldEnum]


  export const BuffingWastageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    total_receipt: 'total_receipt',
    total_wastage: 'total_wastage',
    balance: 'balance',
    wastage_percentage: 'wastage_percentage',
    given_gold: 'given_gold',
    add_wastage: 'add_wastage',
    overall_wastage: 'overall_wastage',
    closing_balance: 'closing_balance',
    opening_balance: 'opening_balance',
    buffing_person_id: 'buffing_person_id',
    buffing_lot_id: 'buffing_lot_id'
  };

  export type BuffingWastageScalarFieldEnum = (typeof BuffingWastageScalarFieldEnum)[keyof typeof BuffingWastageScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    casting_item_id: 'casting_item_id',
    filing_item_id: 'filing_item_id',
    setting_item_id: 'setting_item_id',
    buffing_item_id: 'buffing_item_id',
    item_id: 'item_id',
    weight: 'weight',
    touch_id: 'touch_id',
    item_purity: 'item_purity',
    remarks: 'remarks',
    casting_customer_id: 'casting_customer_id'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AddCustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddCustomerOrderByRelevanceFieldEnum = (typeof AddCustomerOrderByRelevanceFieldEnum)[keyof typeof AddCustomerOrderByRelevanceFieldEnum]


  export const AddCastingOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddCastingOrderByRelevanceFieldEnum = (typeof AddCastingOrderByRelevanceFieldEnum)[keyof typeof AddCastingOrderByRelevanceFieldEnum]


  export const AddFilingOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddFilingOrderByRelevanceFieldEnum = (typeof AddFilingOrderByRelevanceFieldEnum)[keyof typeof AddFilingOrderByRelevanceFieldEnum]


  export const AddSettingOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddSettingOrderByRelevanceFieldEnum = (typeof AddSettingOrderByRelevanceFieldEnum)[keyof typeof AddSettingOrderByRelevanceFieldEnum]


  export const AddBuffingOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    email: 'email'
  };

  export type AddBuffingOrderByRelevanceFieldEnum = (typeof AddBuffingOrderByRelevanceFieldEnum)[keyof typeof AddBuffingOrderByRelevanceFieldEnum]


  export const AddSupplierItemOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    address: 'address'
  };

  export type AddSupplierItemOrderByRelevanceFieldEnum = (typeof AddSupplierItemOrderByRelevanceFieldEnum)[keyof typeof AddSupplierItemOrderByRelevanceFieldEnum]


  export const AddPurchaseStockOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type AddPurchaseStockOrderByRelevanceFieldEnum = (typeof AddPurchaseStockOrderByRelevanceFieldEnum)[keyof typeof AddPurchaseStockOrderByRelevanceFieldEnum]


  export const CustomerTransactionOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type CustomerTransactionOrderByRelevanceFieldEnum = (typeof CustomerTransactionOrderByRelevanceFieldEnum)[keyof typeof CustomerTransactionOrderByRelevanceFieldEnum]


  export const AddItemOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type AddItemOrderByRelevanceFieldEnum = (typeof AddItemOrderByRelevanceFieldEnum)[keyof typeof AddItemOrderByRelevanceFieldEnum]


  export const CastingItemsOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type CastingItemsOrderByRelevanceFieldEnum = (typeof CastingItemsOrderByRelevanceFieldEnum)[keyof typeof CastingItemsOrderByRelevanceFieldEnum]


  export const FilingItemsOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type FilingItemsOrderByRelevanceFieldEnum = (typeof FilingItemsOrderByRelevanceFieldEnum)[keyof typeof FilingItemsOrderByRelevanceFieldEnum]


  export const SettingItemsOrderByRelevanceFieldEnum: {
    scrap_remarks: 'scrap_remarks'
  };

  export type SettingItemsOrderByRelevanceFieldEnum = (typeof SettingItemsOrderByRelevanceFieldEnum)[keyof typeof SettingItemsOrderByRelevanceFieldEnum]


  export const SettingTotalBalanceOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type SettingTotalBalanceOrderByRelevanceFieldEnum = (typeof SettingTotalBalanceOrderByRelevanceFieldEnum)[keyof typeof SettingTotalBalanceOrderByRelevanceFieldEnum]


  export const BuffingItemsOrderByRelevanceFieldEnum: {
    scrap_remarks: 'scrap_remarks'
  };

  export type BuffingItemsOrderByRelevanceFieldEnum = (typeof BuffingItemsOrderByRelevanceFieldEnum)[keyof typeof BuffingItemsOrderByRelevanceFieldEnum]


  export const BuffingTotalBalanceOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type BuffingTotalBalanceOrderByRelevanceFieldEnum = (typeof BuffingTotalBalanceOrderByRelevanceFieldEnum)[keyof typeof BuffingTotalBalanceOrderByRelevanceFieldEnum]


  export const StockOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type StockOrderByRelevanceFieldEnum = (typeof StockOrderByRelevanceFieldEnum)[keyof typeof StockOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'ITEMTYPE'
   */
  export type EnumITEMTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ITEMTYPE'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'CASTINGENTRYTYPE'
   */
  export type EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CASTINGENTRYTYPE'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'STONEOPTION'
   */
  export type EnumSTONEOPTIONFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STONEOPTION'>
    
  /**
   * Deep Input Types
   */


  export type AddCustomerWhereInput = {
    AND?: AddCustomerWhereInput | AddCustomerWhereInput[]
    OR?: AddCustomerWhereInput[]
    NOT?: AddCustomerWhereInput | AddCustomerWhereInput[]
    id?: IntFilter<"AddCustomer"> | number
    createdAt?: DateTimeFilter<"AddCustomer"> | Date | string
    name?: StringFilter<"AddCustomer"> | string
    phoneNumber?: StringNullableFilter<"AddCustomer"> | string | null
    address?: StringNullableFilter<"AddCustomer"> | string | null
    email?: StringNullableFilter<"AddCustomer"> | string | null
    transactions?: CustomerTransactionListRelationFilter
  }

  export type AddCustomerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    transactions?: CustomerTransactionOrderByRelationAggregateInput
    _relevance?: AddCustomerOrderByRelevanceInput
  }

  export type AddCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddCustomerWhereInput | AddCustomerWhereInput[]
    OR?: AddCustomerWhereInput[]
    NOT?: AddCustomerWhereInput | AddCustomerWhereInput[]
    createdAt?: DateTimeFilter<"AddCustomer"> | Date | string
    name?: StringFilter<"AddCustomer"> | string
    phoneNumber?: StringNullableFilter<"AddCustomer"> | string | null
    address?: StringNullableFilter<"AddCustomer"> | string | null
    email?: StringNullableFilter<"AddCustomer"> | string | null
    transactions?: CustomerTransactionListRelationFilter
  }, "id">

  export type AddCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: AddCustomerCountOrderByAggregateInput
    _avg?: AddCustomerAvgOrderByAggregateInput
    _max?: AddCustomerMaxOrderByAggregateInput
    _min?: AddCustomerMinOrderByAggregateInput
    _sum?: AddCustomerSumOrderByAggregateInput
  }

  export type AddCustomerScalarWhereWithAggregatesInput = {
    AND?: AddCustomerScalarWhereWithAggregatesInput | AddCustomerScalarWhereWithAggregatesInput[]
    OR?: AddCustomerScalarWhereWithAggregatesInput[]
    NOT?: AddCustomerScalarWhereWithAggregatesInput | AddCustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddCustomer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddCustomer"> | Date | string
    name?: StringWithAggregatesFilter<"AddCustomer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"AddCustomer"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddCustomer"> | string | null
    email?: StringNullableWithAggregatesFilter<"AddCustomer"> | string | null
  }

  export type AddCastingWhereInput = {
    AND?: AddCastingWhereInput | AddCastingWhereInput[]
    OR?: AddCastingWhereInput[]
    NOT?: AddCastingWhereInput | AddCastingWhereInput[]
    id?: IntFilter<"AddCasting"> | number
    createdAt?: DateTimeFilter<"AddCasting"> | Date | string
    name?: StringFilter<"AddCasting"> | string
    phoneNumber?: StringNullableFilter<"AddCasting"> | string | null
    address?: StringNullableFilter<"AddCasting"> | string | null
    email?: StringNullableFilter<"AddCasting"> | string | null
    entries?: CastingEntryListRelationFilter
    castingitems?: CastingItemsListRelationFilter
    stock?: StockListRelationFilter
  }

  export type AddCastingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    entries?: CastingEntryOrderByRelationAggregateInput
    castingitems?: CastingItemsOrderByRelationAggregateInput
    stock?: StockOrderByRelationAggregateInput
    _relevance?: AddCastingOrderByRelevanceInput
  }

  export type AddCastingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddCastingWhereInput | AddCastingWhereInput[]
    OR?: AddCastingWhereInput[]
    NOT?: AddCastingWhereInput | AddCastingWhereInput[]
    createdAt?: DateTimeFilter<"AddCasting"> | Date | string
    name?: StringFilter<"AddCasting"> | string
    phoneNumber?: StringNullableFilter<"AddCasting"> | string | null
    address?: StringNullableFilter<"AddCasting"> | string | null
    email?: StringNullableFilter<"AddCasting"> | string | null
    entries?: CastingEntryListRelationFilter
    castingitems?: CastingItemsListRelationFilter
    stock?: StockListRelationFilter
  }, "id">

  export type AddCastingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: AddCastingCountOrderByAggregateInput
    _avg?: AddCastingAvgOrderByAggregateInput
    _max?: AddCastingMaxOrderByAggregateInput
    _min?: AddCastingMinOrderByAggregateInput
    _sum?: AddCastingSumOrderByAggregateInput
  }

  export type AddCastingScalarWhereWithAggregatesInput = {
    AND?: AddCastingScalarWhereWithAggregatesInput | AddCastingScalarWhereWithAggregatesInput[]
    OR?: AddCastingScalarWhereWithAggregatesInput[]
    NOT?: AddCastingScalarWhereWithAggregatesInput | AddCastingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddCasting"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddCasting"> | Date | string
    name?: StringWithAggregatesFilter<"AddCasting"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"AddCasting"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddCasting"> | string | null
    email?: StringNullableWithAggregatesFilter<"AddCasting"> | string | null
  }

  export type AddFilingWhereInput = {
    AND?: AddFilingWhereInput | AddFilingWhereInput[]
    OR?: AddFilingWhereInput[]
    NOT?: AddFilingWhereInput | AddFilingWhereInput[]
    id?: IntFilter<"AddFiling"> | number
    createdAt?: DateTimeFilter<"AddFiling"> | Date | string
    name?: StringFilter<"AddFiling"> | string
    phoneNumber?: StringNullableFilter<"AddFiling"> | string | null
    address?: StringNullableFilter<"AddFiling"> | string | null
    email?: StringNullableFilter<"AddFiling"> | string | null
    filingWastages?: FilingWastageListRelationFilter
    filings?: FilingEntryListRelationFilter
    lotInfo?: LotInfoListRelationFilter
    lotFilingMapper?: LotFilingMapperListRelationFilter
  }

  export type AddFilingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    filingWastages?: FilingWastageOrderByRelationAggregateInput
    filings?: FilingEntryOrderByRelationAggregateInput
    lotInfo?: LotInfoOrderByRelationAggregateInput
    lotFilingMapper?: LotFilingMapperOrderByRelationAggregateInput
    _relevance?: AddFilingOrderByRelevanceInput
  }

  export type AddFilingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddFilingWhereInput | AddFilingWhereInput[]
    OR?: AddFilingWhereInput[]
    NOT?: AddFilingWhereInput | AddFilingWhereInput[]
    createdAt?: DateTimeFilter<"AddFiling"> | Date | string
    name?: StringFilter<"AddFiling"> | string
    phoneNumber?: StringNullableFilter<"AddFiling"> | string | null
    address?: StringNullableFilter<"AddFiling"> | string | null
    email?: StringNullableFilter<"AddFiling"> | string | null
    filingWastages?: FilingWastageListRelationFilter
    filings?: FilingEntryListRelationFilter
    lotInfo?: LotInfoListRelationFilter
    lotFilingMapper?: LotFilingMapperListRelationFilter
  }, "id">

  export type AddFilingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: AddFilingCountOrderByAggregateInput
    _avg?: AddFilingAvgOrderByAggregateInput
    _max?: AddFilingMaxOrderByAggregateInput
    _min?: AddFilingMinOrderByAggregateInput
    _sum?: AddFilingSumOrderByAggregateInput
  }

  export type AddFilingScalarWhereWithAggregatesInput = {
    AND?: AddFilingScalarWhereWithAggregatesInput | AddFilingScalarWhereWithAggregatesInput[]
    OR?: AddFilingScalarWhereWithAggregatesInput[]
    NOT?: AddFilingScalarWhereWithAggregatesInput | AddFilingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddFiling"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddFiling"> | Date | string
    name?: StringWithAggregatesFilter<"AddFiling"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"AddFiling"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddFiling"> | string | null
    email?: StringNullableWithAggregatesFilter<"AddFiling"> | string | null
  }

  export type AddSettingWhereInput = {
    AND?: AddSettingWhereInput | AddSettingWhereInput[]
    OR?: AddSettingWhereInput[]
    NOT?: AddSettingWhereInput | AddSettingWhereInput[]
    id?: IntFilter<"AddSetting"> | number
    createdAt?: DateTimeFilter<"AddSetting"> | Date | string
    name?: StringFilter<"AddSetting"> | string
    phoneNumber?: StringNullableFilter<"AddSetting"> | string | null
    address?: StringNullableFilter<"AddSetting"> | string | null
    email?: StringNullableFilter<"AddSetting"> | string | null
    settings?: SettingEntryListRelationFilter
    settingMapper?: LotSettingMapperListRelationFilter
    lotInfo?: LotInfoListRelationFilter
  }

  export type AddSettingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    settings?: SettingEntryOrderByRelationAggregateInput
    settingMapper?: LotSettingMapperOrderByRelationAggregateInput
    lotInfo?: LotInfoOrderByRelationAggregateInput
    _relevance?: AddSettingOrderByRelevanceInput
  }

  export type AddSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddSettingWhereInput | AddSettingWhereInput[]
    OR?: AddSettingWhereInput[]
    NOT?: AddSettingWhereInput | AddSettingWhereInput[]
    createdAt?: DateTimeFilter<"AddSetting"> | Date | string
    name?: StringFilter<"AddSetting"> | string
    phoneNumber?: StringNullableFilter<"AddSetting"> | string | null
    address?: StringNullableFilter<"AddSetting"> | string | null
    email?: StringNullableFilter<"AddSetting"> | string | null
    settings?: SettingEntryListRelationFilter
    settingMapper?: LotSettingMapperListRelationFilter
    lotInfo?: LotInfoListRelationFilter
  }, "id">

  export type AddSettingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: AddSettingCountOrderByAggregateInput
    _avg?: AddSettingAvgOrderByAggregateInput
    _max?: AddSettingMaxOrderByAggregateInput
    _min?: AddSettingMinOrderByAggregateInput
    _sum?: AddSettingSumOrderByAggregateInput
  }

  export type AddSettingScalarWhereWithAggregatesInput = {
    AND?: AddSettingScalarWhereWithAggregatesInput | AddSettingScalarWhereWithAggregatesInput[]
    OR?: AddSettingScalarWhereWithAggregatesInput[]
    NOT?: AddSettingScalarWhereWithAggregatesInput | AddSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddSetting"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddSetting"> | Date | string
    name?: StringWithAggregatesFilter<"AddSetting"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"AddSetting"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddSetting"> | string | null
    email?: StringNullableWithAggregatesFilter<"AddSetting"> | string | null
  }

  export type AddBuffingWhereInput = {
    AND?: AddBuffingWhereInput | AddBuffingWhereInput[]
    OR?: AddBuffingWhereInput[]
    NOT?: AddBuffingWhereInput | AddBuffingWhereInput[]
    id?: IntFilter<"AddBuffing"> | number
    createdAt?: DateTimeFilter<"AddBuffing"> | Date | string
    name?: StringFilter<"AddBuffing"> | string
    phoneNumber?: StringNullableFilter<"AddBuffing"> | string | null
    address?: StringNullableFilter<"AddBuffing"> | string | null
    email?: StringNullableFilter<"AddBuffing"> | string | null
    buffings?: BuffingEntryListRelationFilter
    buffingMapper?: LotBuffingMapperListRelationFilter
    lotInfo?: LotInfoListRelationFilter
    buffingWastages?: BuffingWastageListRelationFilter
  }

  export type AddBuffingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    buffings?: BuffingEntryOrderByRelationAggregateInput
    buffingMapper?: LotBuffingMapperOrderByRelationAggregateInput
    lotInfo?: LotInfoOrderByRelationAggregateInput
    buffingWastages?: BuffingWastageOrderByRelationAggregateInput
    _relevance?: AddBuffingOrderByRelevanceInput
  }

  export type AddBuffingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddBuffingWhereInput | AddBuffingWhereInput[]
    OR?: AddBuffingWhereInput[]
    NOT?: AddBuffingWhereInput | AddBuffingWhereInput[]
    createdAt?: DateTimeFilter<"AddBuffing"> | Date | string
    name?: StringFilter<"AddBuffing"> | string
    phoneNumber?: StringNullableFilter<"AddBuffing"> | string | null
    address?: StringNullableFilter<"AddBuffing"> | string | null
    email?: StringNullableFilter<"AddBuffing"> | string | null
    buffings?: BuffingEntryListRelationFilter
    buffingMapper?: LotBuffingMapperListRelationFilter
    lotInfo?: LotInfoListRelationFilter
    buffingWastages?: BuffingWastageListRelationFilter
  }, "id">

  export type AddBuffingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: AddBuffingCountOrderByAggregateInput
    _avg?: AddBuffingAvgOrderByAggregateInput
    _max?: AddBuffingMaxOrderByAggregateInput
    _min?: AddBuffingMinOrderByAggregateInput
    _sum?: AddBuffingSumOrderByAggregateInput
  }

  export type AddBuffingScalarWhereWithAggregatesInput = {
    AND?: AddBuffingScalarWhereWithAggregatesInput | AddBuffingScalarWhereWithAggregatesInput[]
    OR?: AddBuffingScalarWhereWithAggregatesInput[]
    NOT?: AddBuffingScalarWhereWithAggregatesInput | AddBuffingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddBuffing"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddBuffing"> | Date | string
    name?: StringWithAggregatesFilter<"AddBuffing"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"AddBuffing"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddBuffing"> | string | null
    email?: StringNullableWithAggregatesFilter<"AddBuffing"> | string | null
  }

  export type AddSupplierItemWhereInput = {
    AND?: AddSupplierItemWhereInput | AddSupplierItemWhereInput[]
    OR?: AddSupplierItemWhereInput[]
    NOT?: AddSupplierItemWhereInput | AddSupplierItemWhereInput[]
    id?: IntFilter<"AddSupplierItem"> | number
    createdAt?: DateTimeFilter<"AddSupplierItem"> | Date | string
    name?: StringFilter<"AddSupplierItem"> | string
    email?: StringNullableFilter<"AddSupplierItem"> | string | null
    phoneNumber?: StringNullableFilter<"AddSupplierItem"> | string | null
    address?: StringNullableFilter<"AddSupplierItem"> | string | null
  }

  export type AddSupplierItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _relevance?: AddSupplierItemOrderByRelevanceInput
  }

  export type AddSupplierItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddSupplierItemWhereInput | AddSupplierItemWhereInput[]
    OR?: AddSupplierItemWhereInput[]
    NOT?: AddSupplierItemWhereInput | AddSupplierItemWhereInput[]
    createdAt?: DateTimeFilter<"AddSupplierItem"> | Date | string
    name?: StringFilter<"AddSupplierItem"> | string
    email?: StringNullableFilter<"AddSupplierItem"> | string | null
    phoneNumber?: StringNullableFilter<"AddSupplierItem"> | string | null
    address?: StringNullableFilter<"AddSupplierItem"> | string | null
  }, "id">

  export type AddSupplierItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: AddSupplierItemCountOrderByAggregateInput
    _avg?: AddSupplierItemAvgOrderByAggregateInput
    _max?: AddSupplierItemMaxOrderByAggregateInput
    _min?: AddSupplierItemMinOrderByAggregateInput
    _sum?: AddSupplierItemSumOrderByAggregateInput
  }

  export type AddSupplierItemScalarWhereWithAggregatesInput = {
    AND?: AddSupplierItemScalarWhereWithAggregatesInput | AddSupplierItemScalarWhereWithAggregatesInput[]
    OR?: AddSupplierItemScalarWhereWithAggregatesInput[]
    NOT?: AddSupplierItemScalarWhereWithAggregatesInput | AddSupplierItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddSupplierItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddSupplierItem"> | Date | string
    name?: StringWithAggregatesFilter<"AddSupplierItem"> | string
    email?: StringNullableWithAggregatesFilter<"AddSupplierItem"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"AddSupplierItem"> | string | null
    address?: StringNullableWithAggregatesFilter<"AddSupplierItem"> | string | null
  }

  export type AddPurchaseStockWhereInput = {
    AND?: AddPurchaseStockWhereInput | AddPurchaseStockWhereInput[]
    OR?: AddPurchaseStockWhereInput[]
    NOT?: AddPurchaseStockWhereInput | AddPurchaseStockWhereInput[]
    id?: IntFilter<"AddPurchaseStock"> | number
    createdAt?: DateTimeFilter<"AddPurchaseStock"> | Date | string
    name?: StringFilter<"AddPurchaseStock"> | string
    item?: EnumITEMTYPEFilter<"AddPurchaseStock"> | $Enums.ITEMTYPE
    goldWeight?: IntNullableFilter<"AddPurchaseStock"> | number | null
    goldTouch?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldPurity?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldRate?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldtotalValue?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverWeight?: IntNullableFilter<"AddPurchaseStock"> | number | null
    silverTouch?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverPurity?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverRate?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silvertotalValue?: FloatNullableFilter<"AddPurchaseStock"> | number | null
  }

  export type AddPurchaseStockOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    item?: SortOrder
    goldWeight?: SortOrderInput | SortOrder
    goldTouch?: SortOrderInput | SortOrder
    goldPurity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    goldtotalValue?: SortOrderInput | SortOrder
    silverWeight?: SortOrderInput | SortOrder
    silverTouch?: SortOrderInput | SortOrder
    silverPurity?: SortOrderInput | SortOrder
    silverRate?: SortOrderInput | SortOrder
    silvertotalValue?: SortOrderInput | SortOrder
    _relevance?: AddPurchaseStockOrderByRelevanceInput
  }

  export type AddPurchaseStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddPurchaseStockWhereInput | AddPurchaseStockWhereInput[]
    OR?: AddPurchaseStockWhereInput[]
    NOT?: AddPurchaseStockWhereInput | AddPurchaseStockWhereInput[]
    createdAt?: DateTimeFilter<"AddPurchaseStock"> | Date | string
    name?: StringFilter<"AddPurchaseStock"> | string
    item?: EnumITEMTYPEFilter<"AddPurchaseStock"> | $Enums.ITEMTYPE
    goldWeight?: IntNullableFilter<"AddPurchaseStock"> | number | null
    goldTouch?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldPurity?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldRate?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    goldtotalValue?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverWeight?: IntNullableFilter<"AddPurchaseStock"> | number | null
    silverTouch?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverPurity?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silverRate?: FloatNullableFilter<"AddPurchaseStock"> | number | null
    silvertotalValue?: FloatNullableFilter<"AddPurchaseStock"> | number | null
  }, "id">

  export type AddPurchaseStockOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    item?: SortOrder
    goldWeight?: SortOrderInput | SortOrder
    goldTouch?: SortOrderInput | SortOrder
    goldPurity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    goldtotalValue?: SortOrderInput | SortOrder
    silverWeight?: SortOrderInput | SortOrder
    silverTouch?: SortOrderInput | SortOrder
    silverPurity?: SortOrderInput | SortOrder
    silverRate?: SortOrderInput | SortOrder
    silvertotalValue?: SortOrderInput | SortOrder
    _count?: AddPurchaseStockCountOrderByAggregateInput
    _avg?: AddPurchaseStockAvgOrderByAggregateInput
    _max?: AddPurchaseStockMaxOrderByAggregateInput
    _min?: AddPurchaseStockMinOrderByAggregateInput
    _sum?: AddPurchaseStockSumOrderByAggregateInput
  }

  export type AddPurchaseStockScalarWhereWithAggregatesInput = {
    AND?: AddPurchaseStockScalarWhereWithAggregatesInput | AddPurchaseStockScalarWhereWithAggregatesInput[]
    OR?: AddPurchaseStockScalarWhereWithAggregatesInput[]
    NOT?: AddPurchaseStockScalarWhereWithAggregatesInput | AddPurchaseStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddPurchaseStock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddPurchaseStock"> | Date | string
    name?: StringWithAggregatesFilter<"AddPurchaseStock"> | string
    item?: EnumITEMTYPEWithAggregatesFilter<"AddPurchaseStock"> | $Enums.ITEMTYPE
    goldWeight?: IntNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    goldTouch?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    goldPurity?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    goldRate?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    goldtotalValue?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    silverWeight?: IntNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    silverTouch?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    silverPurity?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    silverRate?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
    silvertotalValue?: FloatNullableWithAggregatesFilter<"AddPurchaseStock"> | number | null
  }

  export type CustomerTransactionWhereInput = {
    AND?: CustomerTransactionWhereInput | CustomerTransactionWhereInput[]
    OR?: CustomerTransactionWhereInput[]
    NOT?: CustomerTransactionWhereInput | CustomerTransactionWhereInput[]
    id?: IntFilter<"CustomerTransaction"> | number
    createdAt?: DateTimeFilter<"CustomerTransaction"> | Date | string
    date?: DateTimeFilter<"CustomerTransaction"> | Date | string
    value?: FloatFilter<"CustomerTransaction"> | number
    type?: StringFilter<"CustomerTransaction"> | string
    touch?: FloatNullableFilter<"CustomerTransaction"> | number | null
    purity?: FloatNullableFilter<"CustomerTransaction"> | number | null
    goldRate?: FloatNullableFilter<"CustomerTransaction"> | number | null
    customerId?: IntFilter<"CustomerTransaction"> | number
    customer?: XOR<AddCustomerScalarRelationFilter, AddCustomerWhereInput>
  }

  export type CustomerTransactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    value?: SortOrder
    type?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    customerId?: SortOrder
    customer?: AddCustomerOrderByWithRelationInput
    _relevance?: CustomerTransactionOrderByRelevanceInput
  }

  export type CustomerTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerTransactionWhereInput | CustomerTransactionWhereInput[]
    OR?: CustomerTransactionWhereInput[]
    NOT?: CustomerTransactionWhereInput | CustomerTransactionWhereInput[]
    createdAt?: DateTimeFilter<"CustomerTransaction"> | Date | string
    date?: DateTimeFilter<"CustomerTransaction"> | Date | string
    value?: FloatFilter<"CustomerTransaction"> | number
    type?: StringFilter<"CustomerTransaction"> | string
    touch?: FloatNullableFilter<"CustomerTransaction"> | number | null
    purity?: FloatNullableFilter<"CustomerTransaction"> | number | null
    goldRate?: FloatNullableFilter<"CustomerTransaction"> | number | null
    customerId?: IntFilter<"CustomerTransaction"> | number
    customer?: XOR<AddCustomerScalarRelationFilter, AddCustomerWhereInput>
  }, "id">

  export type CustomerTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    value?: SortOrder
    type?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    customerId?: SortOrder
    _count?: CustomerTransactionCountOrderByAggregateInput
    _avg?: CustomerTransactionAvgOrderByAggregateInput
    _max?: CustomerTransactionMaxOrderByAggregateInput
    _min?: CustomerTransactionMinOrderByAggregateInput
    _sum?: CustomerTransactionSumOrderByAggregateInput
  }

  export type CustomerTransactionScalarWhereWithAggregatesInput = {
    AND?: CustomerTransactionScalarWhereWithAggregatesInput | CustomerTransactionScalarWhereWithAggregatesInput[]
    OR?: CustomerTransactionScalarWhereWithAggregatesInput[]
    NOT?: CustomerTransactionScalarWhereWithAggregatesInput | CustomerTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomerTransaction"> | Date | string
    date?: DateTimeWithAggregatesFilter<"CustomerTransaction"> | Date | string
    value?: FloatWithAggregatesFilter<"CustomerTransaction"> | number
    type?: StringWithAggregatesFilter<"CustomerTransaction"> | string
    touch?: FloatNullableWithAggregatesFilter<"CustomerTransaction"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"CustomerTransaction"> | number | null
    goldRate?: FloatNullableWithAggregatesFilter<"CustomerTransaction"> | number | null
    customerId?: IntWithAggregatesFilter<"CustomerTransaction"> | number
  }

  export type AddItemWhereInput = {
    AND?: AddItemWhereInput | AddItemWhereInput[]
    OR?: AddItemWhereInput[]
    NOT?: AddItemWhereInput | AddItemWhereInput[]
    id?: IntFilter<"AddItem"> | number
    createdAt?: DateTimeFilter<"AddItem"> | Date | string
    name?: StringFilter<"AddItem"> | string
    casting_items?: CastingItemsListRelationFilter
    stock?: StockListRelationFilter
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    buffing_items?: BuffingItemsListRelationFilter
  }

  export type AddItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    casting_items?: CastingItemsOrderByRelationAggregateInput
    stock?: StockOrderByRelationAggregateInput
    filing_items?: FilingItemsOrderByRelationAggregateInput
    setting_items?: SettingItemsOrderByRelationAggregateInput
    buffing_items?: BuffingItemsOrderByRelationAggregateInput
    _relevance?: AddItemOrderByRelevanceInput
  }

  export type AddItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddItemWhereInput | AddItemWhereInput[]
    OR?: AddItemWhereInput[]
    NOT?: AddItemWhereInput | AddItemWhereInput[]
    createdAt?: DateTimeFilter<"AddItem"> | Date | string
    name?: StringFilter<"AddItem"> | string
    casting_items?: CastingItemsListRelationFilter
    stock?: StockListRelationFilter
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    buffing_items?: BuffingItemsListRelationFilter
  }, "id">

  export type AddItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    _count?: AddItemCountOrderByAggregateInput
    _avg?: AddItemAvgOrderByAggregateInput
    _max?: AddItemMaxOrderByAggregateInput
    _min?: AddItemMinOrderByAggregateInput
    _sum?: AddItemSumOrderByAggregateInput
  }

  export type AddItemScalarWhereWithAggregatesInput = {
    AND?: AddItemScalarWhereWithAggregatesInput | AddItemScalarWhereWithAggregatesInput[]
    OR?: AddItemScalarWhereWithAggregatesInput[]
    NOT?: AddItemScalarWhereWithAggregatesInput | AddItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddItem"> | Date | string
    name?: StringWithAggregatesFilter<"AddItem"> | string
  }

  export type AddTouchWhereInput = {
    AND?: AddTouchWhereInput | AddTouchWhereInput[]
    OR?: AddTouchWhereInput[]
    NOT?: AddTouchWhereInput | AddTouchWhereInput[]
    id?: IntFilter<"AddTouch"> | number
    createdAt?: DateTimeFilter<"AddTouch"> | Date | string
    touch?: FloatFilter<"AddTouch"> | number
    casting_entry?: CastingEntryListRelationFilter
    casting_items?: CastingItemsListRelationFilter
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    buffing_items?: BuffingItemsListRelationFilter
    stock?: StockListRelationFilter
  }

  export type AddTouchOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    touch?: SortOrder
    casting_entry?: CastingEntryOrderByRelationAggregateInput
    casting_items?: CastingItemsOrderByRelationAggregateInput
    filing_items?: FilingItemsOrderByRelationAggregateInput
    setting_items?: SettingItemsOrderByRelationAggregateInput
    buffing_items?: BuffingItemsOrderByRelationAggregateInput
    stock?: StockOrderByRelationAggregateInput
  }

  export type AddTouchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddTouchWhereInput | AddTouchWhereInput[]
    OR?: AddTouchWhereInput[]
    NOT?: AddTouchWhereInput | AddTouchWhereInput[]
    createdAt?: DateTimeFilter<"AddTouch"> | Date | string
    touch?: FloatFilter<"AddTouch"> | number
    casting_entry?: CastingEntryListRelationFilter
    casting_items?: CastingItemsListRelationFilter
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    buffing_items?: BuffingItemsListRelationFilter
    stock?: StockListRelationFilter
  }, "id">

  export type AddTouchOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    touch?: SortOrder
    _count?: AddTouchCountOrderByAggregateInput
    _avg?: AddTouchAvgOrderByAggregateInput
    _max?: AddTouchMaxOrderByAggregateInput
    _min?: AddTouchMinOrderByAggregateInput
    _sum?: AddTouchSumOrderByAggregateInput
  }

  export type AddTouchScalarWhereWithAggregatesInput = {
    AND?: AddTouchScalarWhereWithAggregatesInput | AddTouchScalarWhereWithAggregatesInput[]
    OR?: AddTouchScalarWhereWithAggregatesInput[]
    NOT?: AddTouchScalarWhereWithAggregatesInput | AddTouchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddTouch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AddTouch"> | Date | string
    touch?: FloatWithAggregatesFilter<"AddTouch"> | number
  }

  export type CastingEntryWhereInput = {
    AND?: CastingEntryWhereInput | CastingEntryWhereInput[]
    OR?: CastingEntryWhereInput[]
    NOT?: CastingEntryWhereInput | CastingEntryWhereInput[]
    id?: IntFilter<"CastingEntry"> | number
    createdAt?: DateTimeFilter<"CastingEntry"> | Date | string
    date?: DateTimeFilter<"CastingEntry"> | Date | string
    given_gold?: FloatFilter<"CastingEntry"> | number
    touch_id?: IntFilter<"CastingEntry"> | number
    purity?: FloatFilter<"CastingEntry"> | number
    final_touch?: FloatFilter<"CastingEntry"> | number
    pure_value?: FloatFilter<"CastingEntry"> | number
    copper?: FloatFilter<"CastingEntry"> | number
    final_weight?: FloatFilter<"CastingEntry"> | number
    casting_customer_id?: IntFilter<"CastingEntry"> | number
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
    items?: CastingItemsListRelationFilter
    CastiingTotalBalance?: CastiingTotalBalanceListRelationFilter
  }

  export type CastingEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
    touch?: AddTouchOrderByWithRelationInput
    casting_customer?: AddCastingOrderByWithRelationInput
    items?: CastingItemsOrderByRelationAggregateInput
    CastiingTotalBalance?: CastiingTotalBalanceOrderByRelationAggregateInput
  }

  export type CastingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CastingEntryWhereInput | CastingEntryWhereInput[]
    OR?: CastingEntryWhereInput[]
    NOT?: CastingEntryWhereInput | CastingEntryWhereInput[]
    createdAt?: DateTimeFilter<"CastingEntry"> | Date | string
    date?: DateTimeFilter<"CastingEntry"> | Date | string
    given_gold?: FloatFilter<"CastingEntry"> | number
    touch_id?: IntFilter<"CastingEntry"> | number
    purity?: FloatFilter<"CastingEntry"> | number
    final_touch?: FloatFilter<"CastingEntry"> | number
    pure_value?: FloatFilter<"CastingEntry"> | number
    copper?: FloatFilter<"CastingEntry"> | number
    final_weight?: FloatFilter<"CastingEntry"> | number
    casting_customer_id?: IntFilter<"CastingEntry"> | number
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
    items?: CastingItemsListRelationFilter
    CastiingTotalBalance?: CastiingTotalBalanceListRelationFilter
  }, "id">

  export type CastingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
    _count?: CastingEntryCountOrderByAggregateInput
    _avg?: CastingEntryAvgOrderByAggregateInput
    _max?: CastingEntryMaxOrderByAggregateInput
    _min?: CastingEntryMinOrderByAggregateInput
    _sum?: CastingEntrySumOrderByAggregateInput
  }

  export type CastingEntryScalarWhereWithAggregatesInput = {
    AND?: CastingEntryScalarWhereWithAggregatesInput | CastingEntryScalarWhereWithAggregatesInput[]
    OR?: CastingEntryScalarWhereWithAggregatesInput[]
    NOT?: CastingEntryScalarWhereWithAggregatesInput | CastingEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CastingEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CastingEntry"> | Date | string
    date?: DateTimeWithAggregatesFilter<"CastingEntry"> | Date | string
    given_gold?: FloatWithAggregatesFilter<"CastingEntry"> | number
    touch_id?: IntWithAggregatesFilter<"CastingEntry"> | number
    purity?: FloatWithAggregatesFilter<"CastingEntry"> | number
    final_touch?: FloatWithAggregatesFilter<"CastingEntry"> | number
    pure_value?: FloatWithAggregatesFilter<"CastingEntry"> | number
    copper?: FloatWithAggregatesFilter<"CastingEntry"> | number
    final_weight?: FloatWithAggregatesFilter<"CastingEntry"> | number
    casting_customer_id?: IntWithAggregatesFilter<"CastingEntry"> | number
  }

  export type CastingItemsWhereInput = {
    AND?: CastingItemsWhereInput | CastingItemsWhereInput[]
    OR?: CastingItemsWhereInput[]
    NOT?: CastingItemsWhereInput | CastingItemsWhereInput[]
    id?: IntFilter<"CastingItems"> | number
    createdAt?: DateTimeFilter<"CastingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"CastingItems"> | $Enums.CASTINGENTRYTYPE
    item_id?: IntFilter<"CastingItems"> | number
    weight?: FloatFilter<"CastingItems"> | number
    touch_id?: IntFilter<"CastingItems"> | number
    item_purity?: FloatFilter<"CastingItems"> | number
    remarks?: StringNullableFilter<"CastingItems"> | string | null
    casting_entry_id?: IntFilter<"CastingItems"> | number
    casting_customer_id?: IntFilter<"CastingItems"> | number
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    castingEntry?: XOR<CastingEntryScalarRelationFilter, CastingEntryWhereInput>
    filingEntry?: FilingEntryListRelationFilter
    settingEntry?: SettingEntryListRelationFilter
    buffingEntry?: BuffingEntryListRelationFilter
    stock?: StockListRelationFilter
    filingLotMapper?: LotFilingMapperListRelationFilter
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
  }

  export type CastingItemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
    touch?: AddTouchOrderByWithRelationInput
    item?: AddItemOrderByWithRelationInput
    castingEntry?: CastingEntryOrderByWithRelationInput
    filingEntry?: FilingEntryOrderByRelationAggregateInput
    settingEntry?: SettingEntryOrderByRelationAggregateInput
    buffingEntry?: BuffingEntryOrderByRelationAggregateInput
    stock?: StockOrderByRelationAggregateInput
    filingLotMapper?: LotFilingMapperOrderByRelationAggregateInput
    casting_customer?: AddCastingOrderByWithRelationInput
    _relevance?: CastingItemsOrderByRelevanceInput
  }

  export type CastingItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CastingItemsWhereInput | CastingItemsWhereInput[]
    OR?: CastingItemsWhereInput[]
    NOT?: CastingItemsWhereInput | CastingItemsWhereInput[]
    createdAt?: DateTimeFilter<"CastingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"CastingItems"> | $Enums.CASTINGENTRYTYPE
    item_id?: IntFilter<"CastingItems"> | number
    weight?: FloatFilter<"CastingItems"> | number
    touch_id?: IntFilter<"CastingItems"> | number
    item_purity?: FloatFilter<"CastingItems"> | number
    remarks?: StringNullableFilter<"CastingItems"> | string | null
    casting_entry_id?: IntFilter<"CastingItems"> | number
    casting_customer_id?: IntFilter<"CastingItems"> | number
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    castingEntry?: XOR<CastingEntryScalarRelationFilter, CastingEntryWhereInput>
    filingEntry?: FilingEntryListRelationFilter
    settingEntry?: SettingEntryListRelationFilter
    buffingEntry?: BuffingEntryListRelationFilter
    stock?: StockListRelationFilter
    filingLotMapper?: LotFilingMapperListRelationFilter
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
  }, "id">

  export type CastingItemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
    _count?: CastingItemsCountOrderByAggregateInput
    _avg?: CastingItemsAvgOrderByAggregateInput
    _max?: CastingItemsMaxOrderByAggregateInput
    _min?: CastingItemsMinOrderByAggregateInput
    _sum?: CastingItemsSumOrderByAggregateInput
  }

  export type CastingItemsScalarWhereWithAggregatesInput = {
    AND?: CastingItemsScalarWhereWithAggregatesInput | CastingItemsScalarWhereWithAggregatesInput[]
    OR?: CastingItemsScalarWhereWithAggregatesInput[]
    NOT?: CastingItemsScalarWhereWithAggregatesInput | CastingItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CastingItems"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CastingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEWithAggregatesFilter<"CastingItems"> | $Enums.CASTINGENTRYTYPE
    item_id?: IntWithAggregatesFilter<"CastingItems"> | number
    weight?: FloatWithAggregatesFilter<"CastingItems"> | number
    touch_id?: IntWithAggregatesFilter<"CastingItems"> | number
    item_purity?: FloatWithAggregatesFilter<"CastingItems"> | number
    remarks?: StringNullableWithAggregatesFilter<"CastingItems"> | string | null
    casting_entry_id?: IntWithAggregatesFilter<"CastingItems"> | number
    casting_customer_id?: IntWithAggregatesFilter<"CastingItems"> | number
  }

  export type CastiingTotalBalanceWhereInput = {
    AND?: CastiingTotalBalanceWhereInput | CastiingTotalBalanceWhereInput[]
    OR?: CastiingTotalBalanceWhereInput[]
    NOT?: CastiingTotalBalanceWhereInput | CastiingTotalBalanceWhereInput[]
    id?: IntFilter<"CastiingTotalBalance"> | number
    createdAt?: DateTimeFilter<"CastiingTotalBalance"> | Date | string
    total_item_weight?: FloatFilter<"CastiingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"CastiingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"CastiingTotalBalance"> | number | null
    total_wastage?: FloatFilter<"CastiingTotalBalance"> | number
    item_entry?: IntFilter<"CastiingTotalBalance"> | number
    item_entry_id?: XOR<CastingEntryScalarRelationFilter, CastingEntryWhereInput>
  }

  export type CastiingTotalBalanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
    item_entry_id?: CastingEntryOrderByWithRelationInput
  }

  export type CastiingTotalBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    item_entry?: number
    AND?: CastiingTotalBalanceWhereInput | CastiingTotalBalanceWhereInput[]
    OR?: CastiingTotalBalanceWhereInput[]
    NOT?: CastiingTotalBalanceWhereInput | CastiingTotalBalanceWhereInput[]
    createdAt?: DateTimeFilter<"CastiingTotalBalance"> | Date | string
    total_item_weight?: FloatFilter<"CastiingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"CastiingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"CastiingTotalBalance"> | number | null
    total_wastage?: FloatFilter<"CastiingTotalBalance"> | number
    item_entry_id?: XOR<CastingEntryScalarRelationFilter, CastingEntryWhereInput>
  }, "id" | "item_entry">

  export type CastiingTotalBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
    _count?: CastiingTotalBalanceCountOrderByAggregateInput
    _avg?: CastiingTotalBalanceAvgOrderByAggregateInput
    _max?: CastiingTotalBalanceMaxOrderByAggregateInput
    _min?: CastiingTotalBalanceMinOrderByAggregateInput
    _sum?: CastiingTotalBalanceSumOrderByAggregateInput
  }

  export type CastiingTotalBalanceScalarWhereWithAggregatesInput = {
    AND?: CastiingTotalBalanceScalarWhereWithAggregatesInput | CastiingTotalBalanceScalarWhereWithAggregatesInput[]
    OR?: CastiingTotalBalanceScalarWhereWithAggregatesInput[]
    NOT?: CastiingTotalBalanceScalarWhereWithAggregatesInput | CastiingTotalBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CastiingTotalBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CastiingTotalBalance"> | Date | string
    total_item_weight?: FloatWithAggregatesFilter<"CastiingTotalBalance"> | number
    current_balance_weight?: FloatWithAggregatesFilter<"CastiingTotalBalance"> | number
    total_scrap_weight?: FloatNullableWithAggregatesFilter<"CastiingTotalBalance"> | number | null
    total_wastage?: FloatWithAggregatesFilter<"CastiingTotalBalance"> | number
    item_entry?: IntWithAggregatesFilter<"CastiingTotalBalance"> | number
  }

  export type LotInfoWhereInput = {
    AND?: LotInfoWhereInput | LotInfoWhereInput[]
    OR?: LotInfoWhereInput[]
    NOT?: LotInfoWhereInput | LotInfoWhereInput[]
    id?: IntFilter<"LotInfo"> | number
    lotNumber?: IntFilter<"LotInfo"> | number
    filing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    setting_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    buffing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    IsActive?: BoolFilter<"LotInfo"> | boolean
    filingCustomerId?: XOR<AddFilingNullableScalarRelationFilter, AddFilingWhereInput> | null
    settingCustomerId?: XOR<AddSettingNullableScalarRelationFilter, AddSettingWhereInput> | null
    buffingCustomerId?: XOR<AddBuffingNullableScalarRelationFilter, AddBuffingWhereInput> | null
    filingMapper?: LotFilingMapperListRelationFilter
    settingMapper?: LotSettingMapperListRelationFilter
    buffingMapper?: LotBuffingMapperListRelationFilter
    filingWastages?: FilingWastageListRelationFilter
    buffingWastages?: BuffingWastageListRelationFilter
  }

  export type LotInfoOrderByWithRelationInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrderInput | SortOrder
    setting_customer_id?: SortOrderInput | SortOrder
    buffing_customer_id?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    filingCustomerId?: AddFilingOrderByWithRelationInput
    settingCustomerId?: AddSettingOrderByWithRelationInput
    buffingCustomerId?: AddBuffingOrderByWithRelationInput
    filingMapper?: LotFilingMapperOrderByRelationAggregateInput
    settingMapper?: LotSettingMapperOrderByRelationAggregateInput
    buffingMapper?: LotBuffingMapperOrderByRelationAggregateInput
    filingWastages?: FilingWastageOrderByRelationAggregateInput
    buffingWastages?: BuffingWastageOrderByRelationAggregateInput
  }

  export type LotInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LotInfoWhereInput | LotInfoWhereInput[]
    OR?: LotInfoWhereInput[]
    NOT?: LotInfoWhereInput | LotInfoWhereInput[]
    lotNumber?: IntFilter<"LotInfo"> | number
    filing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    setting_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    buffing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    IsActive?: BoolFilter<"LotInfo"> | boolean
    filingCustomerId?: XOR<AddFilingNullableScalarRelationFilter, AddFilingWhereInput> | null
    settingCustomerId?: XOR<AddSettingNullableScalarRelationFilter, AddSettingWhereInput> | null
    buffingCustomerId?: XOR<AddBuffingNullableScalarRelationFilter, AddBuffingWhereInput> | null
    filingMapper?: LotFilingMapperListRelationFilter
    settingMapper?: LotSettingMapperListRelationFilter
    buffingMapper?: LotBuffingMapperListRelationFilter
    filingWastages?: FilingWastageListRelationFilter
    buffingWastages?: BuffingWastageListRelationFilter
  }, "id">

  export type LotInfoOrderByWithAggregationInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrderInput | SortOrder
    setting_customer_id?: SortOrderInput | SortOrder
    buffing_customer_id?: SortOrderInput | SortOrder
    IsActive?: SortOrder
    _count?: LotInfoCountOrderByAggregateInput
    _avg?: LotInfoAvgOrderByAggregateInput
    _max?: LotInfoMaxOrderByAggregateInput
    _min?: LotInfoMinOrderByAggregateInput
    _sum?: LotInfoSumOrderByAggregateInput
  }

  export type LotInfoScalarWhereWithAggregatesInput = {
    AND?: LotInfoScalarWhereWithAggregatesInput | LotInfoScalarWhereWithAggregatesInput[]
    OR?: LotInfoScalarWhereWithAggregatesInput[]
    NOT?: LotInfoScalarWhereWithAggregatesInput | LotInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LotInfo"> | number
    lotNumber?: IntWithAggregatesFilter<"LotInfo"> | number
    filing_customer_id?: IntNullableWithAggregatesFilter<"LotInfo"> | number | null
    setting_customer_id?: IntNullableWithAggregatesFilter<"LotInfo"> | number | null
    buffing_customer_id?: IntNullableWithAggregatesFilter<"LotInfo"> | number | null
    IsActive?: BoolWithAggregatesFilter<"LotInfo"> | boolean
  }

  export type FilingEntryWhereInput = {
    AND?: FilingEntryWhereInput | FilingEntryWhereInput[]
    OR?: FilingEntryWhereInput[]
    NOT?: FilingEntryWhereInput | FilingEntryWhereInput[]
    id?: IntFilter<"FilingEntry"> | number
    createdAt?: DateTimeFilter<"FilingEntry"> | Date | string
    filing_person_id?: IntFilter<"FilingEntry"> | number
    casting_item_id?: IntFilter<"FilingEntry"> | number
    filing_person?: XOR<AddFilingScalarRelationFilter, AddFilingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filingItems?: FilingItemsListRelationFilter
    filingTotalBalance?: FilingTotalBalanceListRelationFilter
    LotFilingMapper?: LotFilingMapperListRelationFilter
  }

  export type FilingEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
    filing_person?: AddFilingOrderByWithRelationInput
    castingItem?: CastingItemsOrderByWithRelationInput
    filingItems?: FilingItemsOrderByRelationAggregateInput
    filingTotalBalance?: FilingTotalBalanceOrderByRelationAggregateInput
    LotFilingMapper?: LotFilingMapperOrderByRelationAggregateInput
  }

  export type FilingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilingEntryWhereInput | FilingEntryWhereInput[]
    OR?: FilingEntryWhereInput[]
    NOT?: FilingEntryWhereInput | FilingEntryWhereInput[]
    createdAt?: DateTimeFilter<"FilingEntry"> | Date | string
    filing_person_id?: IntFilter<"FilingEntry"> | number
    casting_item_id?: IntFilter<"FilingEntry"> | number
    filing_person?: XOR<AddFilingScalarRelationFilter, AddFilingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filingItems?: FilingItemsListRelationFilter
    filingTotalBalance?: FilingTotalBalanceListRelationFilter
    LotFilingMapper?: LotFilingMapperListRelationFilter
  }, "id">

  export type FilingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
    _count?: FilingEntryCountOrderByAggregateInput
    _avg?: FilingEntryAvgOrderByAggregateInput
    _max?: FilingEntryMaxOrderByAggregateInput
    _min?: FilingEntryMinOrderByAggregateInput
    _sum?: FilingEntrySumOrderByAggregateInput
  }

  export type FilingEntryScalarWhereWithAggregatesInput = {
    AND?: FilingEntryScalarWhereWithAggregatesInput | FilingEntryScalarWhereWithAggregatesInput[]
    OR?: FilingEntryScalarWhereWithAggregatesInput[]
    NOT?: FilingEntryScalarWhereWithAggregatesInput | FilingEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilingEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FilingEntry"> | Date | string
    filing_person_id?: IntWithAggregatesFilter<"FilingEntry"> | number
    casting_item_id?: IntWithAggregatesFilter<"FilingEntry"> | number
  }

  export type LotFilingMapperWhereInput = {
    AND?: LotFilingMapperWhereInput | LotFilingMapperWhereInput[]
    OR?: LotFilingMapperWhereInput[]
    NOT?: LotFilingMapperWhereInput | LotFilingMapperWhereInput[]
    id?: IntFilter<"LotFilingMapper"> | number
    filing_id?: IntFilter<"LotFilingMapper"> | number
    lot_id?: IntFilter<"LotFilingMapper"> | number
    item_id?: IntFilter<"LotFilingMapper"> | number
    filing_entry_id?: IntFilter<"LotFilingMapper"> | number
    filingId?: XOR<AddFilingScalarRelationFilter, AddFilingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    itemId?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filing_items?: FilingItemsListRelationFilter
    filingEntry?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
  }

  export type LotFilingMapperOrderByWithRelationInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
    filingId?: AddFilingOrderByWithRelationInput
    lotId?: LotInfoOrderByWithRelationInput
    itemId?: CastingItemsOrderByWithRelationInput
    filing_items?: FilingItemsOrderByRelationAggregateInput
    filingEntry?: FilingEntryOrderByWithRelationInput
  }

  export type LotFilingMapperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LotFilingMapperWhereInput | LotFilingMapperWhereInput[]
    OR?: LotFilingMapperWhereInput[]
    NOT?: LotFilingMapperWhereInput | LotFilingMapperWhereInput[]
    filing_id?: IntFilter<"LotFilingMapper"> | number
    lot_id?: IntFilter<"LotFilingMapper"> | number
    item_id?: IntFilter<"LotFilingMapper"> | number
    filing_entry_id?: IntFilter<"LotFilingMapper"> | number
    filingId?: XOR<AddFilingScalarRelationFilter, AddFilingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    itemId?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filing_items?: FilingItemsListRelationFilter
    filingEntry?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
  }, "id">

  export type LotFilingMapperOrderByWithAggregationInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
    _count?: LotFilingMapperCountOrderByAggregateInput
    _avg?: LotFilingMapperAvgOrderByAggregateInput
    _max?: LotFilingMapperMaxOrderByAggregateInput
    _min?: LotFilingMapperMinOrderByAggregateInput
    _sum?: LotFilingMapperSumOrderByAggregateInput
  }

  export type LotFilingMapperScalarWhereWithAggregatesInput = {
    AND?: LotFilingMapperScalarWhereWithAggregatesInput | LotFilingMapperScalarWhereWithAggregatesInput[]
    OR?: LotFilingMapperScalarWhereWithAggregatesInput[]
    NOT?: LotFilingMapperScalarWhereWithAggregatesInput | LotFilingMapperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LotFilingMapper"> | number
    filing_id?: IntWithAggregatesFilter<"LotFilingMapper"> | number
    lot_id?: IntWithAggregatesFilter<"LotFilingMapper"> | number
    item_id?: IntWithAggregatesFilter<"LotFilingMapper"> | number
    filing_entry_id?: IntWithAggregatesFilter<"LotFilingMapper"> | number
  }

  export type FilingItemsWhereInput = {
    AND?: FilingItemsWhereInput | FilingItemsWhereInput[]
    OR?: FilingItemsWhereInput[]
    NOT?: FilingItemsWhereInput | FilingItemsWhereInput[]
    id?: IntFilter<"FilingItems"> | number
    createdAt?: DateTimeFilter<"FilingItems"> | Date | string
    filing_entry_id?: IntFilter<"FilingItems"> | number
    type?: EnumCASTINGENTRYTYPEFilter<"FilingItems"> | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFilter<"FilingItems"> | number
    weight?: FloatFilter<"FilingItems"> | number
    touch_id?: IntFilter<"FilingItems"> | number
    item_purity?: FloatFilter<"FilingItems"> | number
    remarks?: StringNullableFilter<"FilingItems"> | string | null
    stone_option?: EnumSTONEOPTIONNullableFilter<"FilingItems"> | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: IntNullableFilter<"FilingItems"> | number | null
    filing_entry?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
    filingitem?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    stock?: StockListRelationFilter
    setting_entry?: SettingEntryListRelationFilter
    buffing_entry?: BuffingEntryListRelationFilter
    filing_wastage?: FilingWastageListRelationFilter
    lot_setting_mapper?: LotSettingMapperListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    lotFilingMapperId?: XOR<LotFilingMapperNullableScalarRelationFilter, LotFilingMapperWhereInput> | null
  }

  export type FilingItemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_entry_id?: SortOrder
    type?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    stone_option?: SortOrderInput | SortOrder
    lot_filing_mapper_id?: SortOrderInput | SortOrder
    filing_entry?: FilingEntryOrderByWithRelationInput
    filingitem?: AddItemOrderByWithRelationInput
    touch?: AddTouchOrderByWithRelationInput
    stock?: StockOrderByRelationAggregateInput
    setting_entry?: SettingEntryOrderByRelationAggregateInput
    buffing_entry?: BuffingEntryOrderByRelationAggregateInput
    filing_wastage?: FilingWastageOrderByRelationAggregateInput
    lot_setting_mapper?: LotSettingMapperOrderByRelationAggregateInput
    LotBuffingMapper?: LotBuffingMapperOrderByRelationAggregateInput
    lotFilingMapperId?: LotFilingMapperOrderByWithRelationInput
    _relevance?: FilingItemsOrderByRelevanceInput
  }

  export type FilingItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilingItemsWhereInput | FilingItemsWhereInput[]
    OR?: FilingItemsWhereInput[]
    NOT?: FilingItemsWhereInput | FilingItemsWhereInput[]
    createdAt?: DateTimeFilter<"FilingItems"> | Date | string
    filing_entry_id?: IntFilter<"FilingItems"> | number
    type?: EnumCASTINGENTRYTYPEFilter<"FilingItems"> | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFilter<"FilingItems"> | number
    weight?: FloatFilter<"FilingItems"> | number
    touch_id?: IntFilter<"FilingItems"> | number
    item_purity?: FloatFilter<"FilingItems"> | number
    remarks?: StringNullableFilter<"FilingItems"> | string | null
    stone_option?: EnumSTONEOPTIONNullableFilter<"FilingItems"> | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: IntNullableFilter<"FilingItems"> | number | null
    filing_entry?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
    filingitem?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    stock?: StockListRelationFilter
    setting_entry?: SettingEntryListRelationFilter
    buffing_entry?: BuffingEntryListRelationFilter
    filing_wastage?: FilingWastageListRelationFilter
    lot_setting_mapper?: LotSettingMapperListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    lotFilingMapperId?: XOR<LotFilingMapperNullableScalarRelationFilter, LotFilingMapperWhereInput> | null
  }, "id">

  export type FilingItemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_entry_id?: SortOrder
    type?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    stone_option?: SortOrderInput | SortOrder
    lot_filing_mapper_id?: SortOrderInput | SortOrder
    _count?: FilingItemsCountOrderByAggregateInput
    _avg?: FilingItemsAvgOrderByAggregateInput
    _max?: FilingItemsMaxOrderByAggregateInput
    _min?: FilingItemsMinOrderByAggregateInput
    _sum?: FilingItemsSumOrderByAggregateInput
  }

  export type FilingItemsScalarWhereWithAggregatesInput = {
    AND?: FilingItemsScalarWhereWithAggregatesInput | FilingItemsScalarWhereWithAggregatesInput[]
    OR?: FilingItemsScalarWhereWithAggregatesInput[]
    NOT?: FilingItemsScalarWhereWithAggregatesInput | FilingItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilingItems"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FilingItems"> | Date | string
    filing_entry_id?: IntWithAggregatesFilter<"FilingItems"> | number
    type?: EnumCASTINGENTRYTYPEWithAggregatesFilter<"FilingItems"> | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntWithAggregatesFilter<"FilingItems"> | number
    weight?: FloatWithAggregatesFilter<"FilingItems"> | number
    touch_id?: IntWithAggregatesFilter<"FilingItems"> | number
    item_purity?: FloatWithAggregatesFilter<"FilingItems"> | number
    remarks?: StringNullableWithAggregatesFilter<"FilingItems"> | string | null
    stone_option?: EnumSTONEOPTIONNullableWithAggregatesFilter<"FilingItems"> | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: IntNullableWithAggregatesFilter<"FilingItems"> | number | null
  }

  export type FilingTotalBalanceWhereInput = {
    AND?: FilingTotalBalanceWhereInput | FilingTotalBalanceWhereInput[]
    OR?: FilingTotalBalanceWhereInput[]
    NOT?: FilingTotalBalanceWhereInput | FilingTotalBalanceWhereInput[]
    id?: IntFilter<"FilingTotalBalance"> | number
    createdAt?: DateTimeFilter<"FilingTotalBalance"> | Date | string
    after_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    total_product_weight?: FloatFilter<"FilingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"FilingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    wastage?: BoolFilter<"FilingTotalBalance"> | boolean
    balance?: FloatFilter<"FilingTotalBalance"> | number
    filing_entry_id?: IntFilter<"FilingTotalBalance"> | number
    filingEntryId?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
  }

  export type FilingTotalBalanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    after_weight?: SortOrderInput | SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    wastage?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
    filingEntryId?: FilingEntryOrderByWithRelationInput
  }

  export type FilingTotalBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilingTotalBalanceWhereInput | FilingTotalBalanceWhereInput[]
    OR?: FilingTotalBalanceWhereInput[]
    NOT?: FilingTotalBalanceWhereInput | FilingTotalBalanceWhereInput[]
    createdAt?: DateTimeFilter<"FilingTotalBalance"> | Date | string
    after_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    total_product_weight?: FloatFilter<"FilingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"FilingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    wastage?: BoolFilter<"FilingTotalBalance"> | boolean
    balance?: FloatFilter<"FilingTotalBalance"> | number
    filing_entry_id?: IntFilter<"FilingTotalBalance"> | number
    filingEntryId?: XOR<FilingEntryScalarRelationFilter, FilingEntryWhereInput>
  }, "id">

  export type FilingTotalBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    after_weight?: SortOrderInput | SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    wastage?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
    _count?: FilingTotalBalanceCountOrderByAggregateInput
    _avg?: FilingTotalBalanceAvgOrderByAggregateInput
    _max?: FilingTotalBalanceMaxOrderByAggregateInput
    _min?: FilingTotalBalanceMinOrderByAggregateInput
    _sum?: FilingTotalBalanceSumOrderByAggregateInput
  }

  export type FilingTotalBalanceScalarWhereWithAggregatesInput = {
    AND?: FilingTotalBalanceScalarWhereWithAggregatesInput | FilingTotalBalanceScalarWhereWithAggregatesInput[]
    OR?: FilingTotalBalanceScalarWhereWithAggregatesInput[]
    NOT?: FilingTotalBalanceScalarWhereWithAggregatesInput | FilingTotalBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilingTotalBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FilingTotalBalance"> | Date | string
    after_weight?: FloatNullableWithAggregatesFilter<"FilingTotalBalance"> | number | null
    total_product_weight?: FloatWithAggregatesFilter<"FilingTotalBalance"> | number
    current_balance_weight?: FloatWithAggregatesFilter<"FilingTotalBalance"> | number
    total_scrap_weight?: FloatNullableWithAggregatesFilter<"FilingTotalBalance"> | number | null
    wastage?: BoolWithAggregatesFilter<"FilingTotalBalance"> | boolean
    balance?: FloatWithAggregatesFilter<"FilingTotalBalance"> | number
    filing_entry_id?: IntWithAggregatesFilter<"FilingTotalBalance"> | number
  }

  export type FilingWastageWhereInput = {
    AND?: FilingWastageWhereInput | FilingWastageWhereInput[]
    OR?: FilingWastageWhereInput[]
    NOT?: FilingWastageWhereInput | FilingWastageWhereInput[]
    id?: IntFilter<"FilingWastage"> | number
    createdAt?: DateTimeFilter<"FilingWastage"> | Date | string
    total_receipt?: FloatFilter<"FilingWastage"> | number
    total_wastage?: FloatFilter<"FilingWastage"> | number
    balance?: FloatFilter<"FilingWastage"> | number
    wastage_percentage?: IntFilter<"FilingWastage"> | number
    given_gold?: FloatNullableFilter<"FilingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"FilingWastage"> | number | null
    overall_wastage?: FloatFilter<"FilingWastage"> | number
    closing_balance?: FloatFilter<"FilingWastage"> | number
    opening_balance?: FloatFilter<"FilingWastage"> | number
    filing_person_id?: IntNullableFilter<"FilingWastage"> | number | null
    filing_lot_id?: IntNullableFilter<"FilingWastage"> | number | null
    filingPersonId?: XOR<AddFilingNullableScalarRelationFilter, AddFilingWhereInput> | null
    filingLotId?: XOR<LotInfoNullableScalarRelationFilter, LotInfoWhereInput> | null
    filing_items?: FilingItemsListRelationFilter
  }

  export type FilingWastageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrderInput | SortOrder
    filing_lot_id?: SortOrderInput | SortOrder
    filingPersonId?: AddFilingOrderByWithRelationInput
    filingLotId?: LotInfoOrderByWithRelationInput
    filing_items?: FilingItemsOrderByRelationAggregateInput
  }

  export type FilingWastageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilingWastageWhereInput | FilingWastageWhereInput[]
    OR?: FilingWastageWhereInput[]
    NOT?: FilingWastageWhereInput | FilingWastageWhereInput[]
    createdAt?: DateTimeFilter<"FilingWastage"> | Date | string
    total_receipt?: FloatFilter<"FilingWastage"> | number
    total_wastage?: FloatFilter<"FilingWastage"> | number
    balance?: FloatFilter<"FilingWastage"> | number
    wastage_percentage?: IntFilter<"FilingWastage"> | number
    given_gold?: FloatNullableFilter<"FilingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"FilingWastage"> | number | null
    overall_wastage?: FloatFilter<"FilingWastage"> | number
    closing_balance?: FloatFilter<"FilingWastage"> | number
    opening_balance?: FloatFilter<"FilingWastage"> | number
    filing_person_id?: IntNullableFilter<"FilingWastage"> | number | null
    filing_lot_id?: IntNullableFilter<"FilingWastage"> | number | null
    filingPersonId?: XOR<AddFilingNullableScalarRelationFilter, AddFilingWhereInput> | null
    filingLotId?: XOR<LotInfoNullableScalarRelationFilter, LotInfoWhereInput> | null
    filing_items?: FilingItemsListRelationFilter
  }, "id">

  export type FilingWastageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrderInput | SortOrder
    filing_lot_id?: SortOrderInput | SortOrder
    _count?: FilingWastageCountOrderByAggregateInput
    _avg?: FilingWastageAvgOrderByAggregateInput
    _max?: FilingWastageMaxOrderByAggregateInput
    _min?: FilingWastageMinOrderByAggregateInput
    _sum?: FilingWastageSumOrderByAggregateInput
  }

  export type FilingWastageScalarWhereWithAggregatesInput = {
    AND?: FilingWastageScalarWhereWithAggregatesInput | FilingWastageScalarWhereWithAggregatesInput[]
    OR?: FilingWastageScalarWhereWithAggregatesInput[]
    NOT?: FilingWastageScalarWhereWithAggregatesInput | FilingWastageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilingWastage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FilingWastage"> | Date | string
    total_receipt?: FloatWithAggregatesFilter<"FilingWastage"> | number
    total_wastage?: FloatWithAggregatesFilter<"FilingWastage"> | number
    balance?: FloatWithAggregatesFilter<"FilingWastage"> | number
    wastage_percentage?: IntWithAggregatesFilter<"FilingWastage"> | number
    given_gold?: FloatNullableWithAggregatesFilter<"FilingWastage"> | number | null
    add_wastage?: FloatNullableWithAggregatesFilter<"FilingWastage"> | number | null
    overall_wastage?: FloatWithAggregatesFilter<"FilingWastage"> | number
    closing_balance?: FloatWithAggregatesFilter<"FilingWastage"> | number
    opening_balance?: FloatWithAggregatesFilter<"FilingWastage"> | number
    filing_person_id?: IntNullableWithAggregatesFilter<"FilingWastage"> | number | null
    filing_lot_id?: IntNullableWithAggregatesFilter<"FilingWastage"> | number | null
  }

  export type SettingEntryWhereInput = {
    AND?: SettingEntryWhereInput | SettingEntryWhereInput[]
    OR?: SettingEntryWhereInput[]
    NOT?: SettingEntryWhereInput | SettingEntryWhereInput[]
    id?: IntFilter<"SettingEntry"> | number
    createdAt?: DateTimeFilter<"SettingEntry"> | Date | string
    setting_person_id?: IntFilter<"SettingEntry"> | number
    casting_item_id?: IntFilter<"SettingEntry"> | number
    setting_person?: XOR<AddSettingScalarRelationFilter, AddSettingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filingItems?: FilingItemsListRelationFilter
    settingTotalBalance?: SettingTotalBalanceListRelationFilter
    settingWastage?: SettingWastageListRelationFilter
    LotSettingMapper?: LotSettingMapperListRelationFilter
    SettingItems?: SettingItemsListRelationFilter
  }

  export type SettingEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
    setting_person?: AddSettingOrderByWithRelationInput
    castingItem?: CastingItemsOrderByWithRelationInput
    filingItems?: FilingItemsOrderByRelationAggregateInput
    settingTotalBalance?: SettingTotalBalanceOrderByRelationAggregateInput
    settingWastage?: SettingWastageOrderByRelationAggregateInput
    LotSettingMapper?: LotSettingMapperOrderByRelationAggregateInput
    SettingItems?: SettingItemsOrderByRelationAggregateInput
  }

  export type SettingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingEntryWhereInput | SettingEntryWhereInput[]
    OR?: SettingEntryWhereInput[]
    NOT?: SettingEntryWhereInput | SettingEntryWhereInput[]
    createdAt?: DateTimeFilter<"SettingEntry"> | Date | string
    setting_person_id?: IntFilter<"SettingEntry"> | number
    casting_item_id?: IntFilter<"SettingEntry"> | number
    setting_person?: XOR<AddSettingScalarRelationFilter, AddSettingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filingItems?: FilingItemsListRelationFilter
    settingTotalBalance?: SettingTotalBalanceListRelationFilter
    settingWastage?: SettingWastageListRelationFilter
    LotSettingMapper?: LotSettingMapperListRelationFilter
    SettingItems?: SettingItemsListRelationFilter
  }, "id">

  export type SettingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
    _count?: SettingEntryCountOrderByAggregateInput
    _avg?: SettingEntryAvgOrderByAggregateInput
    _max?: SettingEntryMaxOrderByAggregateInput
    _min?: SettingEntryMinOrderByAggregateInput
    _sum?: SettingEntrySumOrderByAggregateInput
  }

  export type SettingEntryScalarWhereWithAggregatesInput = {
    AND?: SettingEntryScalarWhereWithAggregatesInput | SettingEntryScalarWhereWithAggregatesInput[]
    OR?: SettingEntryScalarWhereWithAggregatesInput[]
    NOT?: SettingEntryScalarWhereWithAggregatesInput | SettingEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SettingEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingEntry"> | Date | string
    setting_person_id?: IntWithAggregatesFilter<"SettingEntry"> | number
    casting_item_id?: IntWithAggregatesFilter<"SettingEntry"> | number
  }

  export type SettingItemsWhereInput = {
    AND?: SettingItemsWhereInput | SettingItemsWhereInput[]
    OR?: SettingItemsWhereInput[]
    NOT?: SettingItemsWhereInput | SettingItemsWhereInput[]
    id?: IntFilter<"SettingItems"> | number
    createdAt?: DateTimeFilter<"SettingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPENullableFilter<"SettingItems"> | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFilter<"SettingItems"> | number
    scrap_weight?: FloatFilter<"SettingItems"> | number
    touch_id?: IntFilter<"SettingItems"> | number
    item_purity?: FloatFilter<"SettingItems"> | number
    scrap_remarks?: StringNullableFilter<"SettingItems"> | string | null
    setting_entry_id?: IntFilter<"SettingItems"> | number
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    setting_wastage?: SettingWastageListRelationFilter
    buffing_entry?: BuffingEntryListRelationFilter
    stock?: StockListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    settingEntryId?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }

  export type SettingItemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrderInput | SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    item?: AddItemOrderByWithRelationInput
    touch?: AddTouchOrderByWithRelationInput
    setting_wastage?: SettingWastageOrderByRelationAggregateInput
    buffing_entry?: BuffingEntryOrderByRelationAggregateInput
    stock?: StockOrderByRelationAggregateInput
    LotBuffingMapper?: LotBuffingMapperOrderByRelationAggregateInput
    settingEntryId?: SettingEntryOrderByWithRelationInput
    _relevance?: SettingItemsOrderByRelevanceInput
  }

  export type SettingItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingItemsWhereInput | SettingItemsWhereInput[]
    OR?: SettingItemsWhereInput[]
    NOT?: SettingItemsWhereInput | SettingItemsWhereInput[]
    createdAt?: DateTimeFilter<"SettingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPENullableFilter<"SettingItems"> | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFilter<"SettingItems"> | number
    scrap_weight?: FloatFilter<"SettingItems"> | number
    touch_id?: IntFilter<"SettingItems"> | number
    item_purity?: FloatFilter<"SettingItems"> | number
    scrap_remarks?: StringNullableFilter<"SettingItems"> | string | null
    setting_entry_id?: IntFilter<"SettingItems"> | number
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    setting_wastage?: SettingWastageListRelationFilter
    buffing_entry?: BuffingEntryListRelationFilter
    stock?: StockListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    settingEntryId?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }, "id">

  export type SettingItemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrderInput | SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    _count?: SettingItemsCountOrderByAggregateInput
    _avg?: SettingItemsAvgOrderByAggregateInput
    _max?: SettingItemsMaxOrderByAggregateInput
    _min?: SettingItemsMinOrderByAggregateInput
    _sum?: SettingItemsSumOrderByAggregateInput
  }

  export type SettingItemsScalarWhereWithAggregatesInput = {
    AND?: SettingItemsScalarWhereWithAggregatesInput | SettingItemsScalarWhereWithAggregatesInput[]
    OR?: SettingItemsScalarWhereWithAggregatesInput[]
    NOT?: SettingItemsScalarWhereWithAggregatesInput | SettingItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SettingItems"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPENullableWithAggregatesFilter<"SettingItems"> | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntWithAggregatesFilter<"SettingItems"> | number
    scrap_weight?: FloatWithAggregatesFilter<"SettingItems"> | number
    touch_id?: IntWithAggregatesFilter<"SettingItems"> | number
    item_purity?: FloatWithAggregatesFilter<"SettingItems"> | number
    scrap_remarks?: StringNullableWithAggregatesFilter<"SettingItems"> | string | null
    setting_entry_id?: IntWithAggregatesFilter<"SettingItems"> | number
  }

  export type LotSettingMapperWhereInput = {
    AND?: LotSettingMapperWhereInput | LotSettingMapperWhereInput[]
    OR?: LotSettingMapperWhereInput[]
    NOT?: LotSettingMapperWhereInput | LotSettingMapperWhereInput[]
    id?: IntFilter<"LotSettingMapper"> | number
    setting_id?: IntFilter<"LotSettingMapper"> | number
    lot_id?: IntFilter<"LotSettingMapper"> | number
    filing_item_id?: IntNullableFilter<"LotSettingMapper"> | number | null
    setting_entry_id?: IntFilter<"LotSettingMapper"> | number
    settingId?: XOR<AddSettingScalarRelationFilter, AddSettingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    itemId?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    settingEntry?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }

  export type LotSettingMapperOrderByWithRelationInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    settingId?: AddSettingOrderByWithRelationInput
    lotId?: LotInfoOrderByWithRelationInput
    itemId?: FilingItemsOrderByWithRelationInput
    settingEntry?: SettingEntryOrderByWithRelationInput
  }

  export type LotSettingMapperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LotSettingMapperWhereInput | LotSettingMapperWhereInput[]
    OR?: LotSettingMapperWhereInput[]
    NOT?: LotSettingMapperWhereInput | LotSettingMapperWhereInput[]
    setting_id?: IntFilter<"LotSettingMapper"> | number
    lot_id?: IntFilter<"LotSettingMapper"> | number
    filing_item_id?: IntNullableFilter<"LotSettingMapper"> | number | null
    setting_entry_id?: IntFilter<"LotSettingMapper"> | number
    settingId?: XOR<AddSettingScalarRelationFilter, AddSettingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    itemId?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    settingEntry?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }, "id">

  export type LotSettingMapperOrderByWithAggregationInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    _count?: LotSettingMapperCountOrderByAggregateInput
    _avg?: LotSettingMapperAvgOrderByAggregateInput
    _max?: LotSettingMapperMaxOrderByAggregateInput
    _min?: LotSettingMapperMinOrderByAggregateInput
    _sum?: LotSettingMapperSumOrderByAggregateInput
  }

  export type LotSettingMapperScalarWhereWithAggregatesInput = {
    AND?: LotSettingMapperScalarWhereWithAggregatesInput | LotSettingMapperScalarWhereWithAggregatesInput[]
    OR?: LotSettingMapperScalarWhereWithAggregatesInput[]
    NOT?: LotSettingMapperScalarWhereWithAggregatesInput | LotSettingMapperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LotSettingMapper"> | number
    setting_id?: IntWithAggregatesFilter<"LotSettingMapper"> | number
    lot_id?: IntWithAggregatesFilter<"LotSettingMapper"> | number
    filing_item_id?: IntNullableWithAggregatesFilter<"LotSettingMapper"> | number | null
    setting_entry_id?: IntWithAggregatesFilter<"LotSettingMapper"> | number
  }

  export type SettingTotalBalanceWhereInput = {
    AND?: SettingTotalBalanceWhereInput | SettingTotalBalanceWhereInput[]
    OR?: SettingTotalBalanceWhereInput[]
    NOT?: SettingTotalBalanceWhereInput | SettingTotalBalanceWhereInput[]
    id?: IntFilter<"SettingTotalBalance"> | number
    createdAt?: DateTimeFilter<"SettingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"SettingTotalBalance"> | number
    stone_count?: FloatFilter<"SettingTotalBalance"> | number
    stone_weight?: FloatFilter<"SettingTotalBalance"> | number
    remarks?: StringNullableFilter<"SettingTotalBalance"> | string | null
    wastage?: BoolFilter<"SettingTotalBalance"> | boolean
    total_product_weight?: FloatFilter<"SettingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"SettingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    balance?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    setting_entry_id?: IntFilter<"SettingTotalBalance"> | number
    setting_entry?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }

  export type SettingTotalBalanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    remarks?: SortOrderInput | SortOrder
    wastage?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    setting_entry?: SettingEntryOrderByWithRelationInput
    _relevance?: SettingTotalBalanceOrderByRelevanceInput
  }

  export type SettingTotalBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingTotalBalanceWhereInput | SettingTotalBalanceWhereInput[]
    OR?: SettingTotalBalanceWhereInput[]
    NOT?: SettingTotalBalanceWhereInput | SettingTotalBalanceWhereInput[]
    createdAt?: DateTimeFilter<"SettingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"SettingTotalBalance"> | number
    stone_count?: FloatFilter<"SettingTotalBalance"> | number
    stone_weight?: FloatFilter<"SettingTotalBalance"> | number
    remarks?: StringNullableFilter<"SettingTotalBalance"> | string | null
    wastage?: BoolFilter<"SettingTotalBalance"> | boolean
    total_product_weight?: FloatFilter<"SettingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"SettingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    balance?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    setting_entry_id?: IntFilter<"SettingTotalBalance"> | number
    setting_entry?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }, "id">

  export type SettingTotalBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    remarks?: SortOrderInput | SortOrder
    wastage?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    setting_entry_id?: SortOrder
    _count?: SettingTotalBalanceCountOrderByAggregateInput
    _avg?: SettingTotalBalanceAvgOrderByAggregateInput
    _max?: SettingTotalBalanceMaxOrderByAggregateInput
    _min?: SettingTotalBalanceMinOrderByAggregateInput
    _sum?: SettingTotalBalanceSumOrderByAggregateInput
  }

  export type SettingTotalBalanceScalarWhereWithAggregatesInput = {
    AND?: SettingTotalBalanceScalarWhereWithAggregatesInput | SettingTotalBalanceScalarWhereWithAggregatesInput[]
    OR?: SettingTotalBalanceScalarWhereWithAggregatesInput[]
    NOT?: SettingTotalBalanceScalarWhereWithAggregatesInput | SettingTotalBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SettingTotalBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingTotalBalance"> | Date | string
    receipt_weight?: FloatWithAggregatesFilter<"SettingTotalBalance"> | number
    stone_count?: FloatWithAggregatesFilter<"SettingTotalBalance"> | number
    stone_weight?: FloatWithAggregatesFilter<"SettingTotalBalance"> | number
    remarks?: StringNullableWithAggregatesFilter<"SettingTotalBalance"> | string | null
    wastage?: BoolWithAggregatesFilter<"SettingTotalBalance"> | boolean
    total_product_weight?: FloatWithAggregatesFilter<"SettingTotalBalance"> | number
    current_balance_weight?: FloatWithAggregatesFilter<"SettingTotalBalance"> | number
    total_scrap_weight?: FloatNullableWithAggregatesFilter<"SettingTotalBalance"> | number | null
    balance?: FloatNullableWithAggregatesFilter<"SettingTotalBalance"> | number | null
    setting_entry_id?: IntWithAggregatesFilter<"SettingTotalBalance"> | number
  }

  export type SettingWastageWhereInput = {
    AND?: SettingWastageWhereInput | SettingWastageWhereInput[]
    OR?: SettingWastageWhereInput[]
    NOT?: SettingWastageWhereInput | SettingWastageWhereInput[]
    id?: IntFilter<"SettingWastage"> | number
    createdAt?: DateTimeFilter<"SettingWastage"> | Date | string
    total_receipt?: FloatFilter<"SettingWastage"> | number
    total_wastage?: FloatFilter<"SettingWastage"> | number
    balance?: FloatFilter<"SettingWastage"> | number
    wastage_percentage?: IntFilter<"SettingWastage"> | number
    given_gold?: IntNullableFilter<"SettingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"SettingWastage"> | number | null
    overall_wastage?: FloatFilter<"SettingWastage"> | number
    closing_balance?: FloatFilter<"SettingWastage"> | number
    opening_balance?: FloatFilter<"SettingWastage"> | number
    setting_entry_id?: IntFilter<"SettingWastage"> | number
    setting_items?: SettingItemsListRelationFilter
    SettingEntryId?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }

  export type SettingWastageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
    setting_items?: SettingItemsOrderByRelationAggregateInput
    SettingEntryId?: SettingEntryOrderByWithRelationInput
  }

  export type SettingWastageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingWastageWhereInput | SettingWastageWhereInput[]
    OR?: SettingWastageWhereInput[]
    NOT?: SettingWastageWhereInput | SettingWastageWhereInput[]
    createdAt?: DateTimeFilter<"SettingWastage"> | Date | string
    total_receipt?: FloatFilter<"SettingWastage"> | number
    total_wastage?: FloatFilter<"SettingWastage"> | number
    balance?: FloatFilter<"SettingWastage"> | number
    wastage_percentage?: IntFilter<"SettingWastage"> | number
    given_gold?: IntNullableFilter<"SettingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"SettingWastage"> | number | null
    overall_wastage?: FloatFilter<"SettingWastage"> | number
    closing_balance?: FloatFilter<"SettingWastage"> | number
    opening_balance?: FloatFilter<"SettingWastage"> | number
    setting_entry_id?: IntFilter<"SettingWastage"> | number
    setting_items?: SettingItemsListRelationFilter
    SettingEntryId?: XOR<SettingEntryScalarRelationFilter, SettingEntryWhereInput>
  }, "id">

  export type SettingWastageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
    _count?: SettingWastageCountOrderByAggregateInput
    _avg?: SettingWastageAvgOrderByAggregateInput
    _max?: SettingWastageMaxOrderByAggregateInput
    _min?: SettingWastageMinOrderByAggregateInput
    _sum?: SettingWastageSumOrderByAggregateInput
  }

  export type SettingWastageScalarWhereWithAggregatesInput = {
    AND?: SettingWastageScalarWhereWithAggregatesInput | SettingWastageScalarWhereWithAggregatesInput[]
    OR?: SettingWastageScalarWhereWithAggregatesInput[]
    NOT?: SettingWastageScalarWhereWithAggregatesInput | SettingWastageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SettingWastage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingWastage"> | Date | string
    total_receipt?: FloatWithAggregatesFilter<"SettingWastage"> | number
    total_wastage?: FloatWithAggregatesFilter<"SettingWastage"> | number
    balance?: FloatWithAggregatesFilter<"SettingWastage"> | number
    wastage_percentage?: IntWithAggregatesFilter<"SettingWastage"> | number
    given_gold?: IntNullableWithAggregatesFilter<"SettingWastage"> | number | null
    add_wastage?: FloatNullableWithAggregatesFilter<"SettingWastage"> | number | null
    overall_wastage?: FloatWithAggregatesFilter<"SettingWastage"> | number
    closing_balance?: FloatWithAggregatesFilter<"SettingWastage"> | number
    opening_balance?: FloatWithAggregatesFilter<"SettingWastage"> | number
    setting_entry_id?: IntWithAggregatesFilter<"SettingWastage"> | number
  }

  export type BuffingEntryWhereInput = {
    AND?: BuffingEntryWhereInput | BuffingEntryWhereInput[]
    OR?: BuffingEntryWhereInput[]
    NOT?: BuffingEntryWhereInput | BuffingEntryWhereInput[]
    id?: IntFilter<"BuffingEntry"> | number
    createdAt?: DateTimeFilter<"BuffingEntry"> | Date | string
    buffing_person_id?: IntFilter<"BuffingEntry"> | number
    casting_item_id?: IntFilter<"BuffingEntry"> | number
    buffing_person?: XOR<AddBuffingScalarRelationFilter, AddBuffingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    BuffingTotalBalance?: BuffingTotalBalanceListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    BuffingItems?: BuffingItemsListRelationFilter
  }

  export type BuffingEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
    buffing_person?: AddBuffingOrderByWithRelationInput
    castingItem?: CastingItemsOrderByWithRelationInput
    filing_items?: FilingItemsOrderByRelationAggregateInput
    setting_items?: SettingItemsOrderByRelationAggregateInput
    BuffingTotalBalance?: BuffingTotalBalanceOrderByRelationAggregateInput
    LotBuffingMapper?: LotBuffingMapperOrderByRelationAggregateInput
    BuffingItems?: BuffingItemsOrderByRelationAggregateInput
  }

  export type BuffingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuffingEntryWhereInput | BuffingEntryWhereInput[]
    OR?: BuffingEntryWhereInput[]
    NOT?: BuffingEntryWhereInput | BuffingEntryWhereInput[]
    createdAt?: DateTimeFilter<"BuffingEntry"> | Date | string
    buffing_person_id?: IntFilter<"BuffingEntry"> | number
    casting_item_id?: IntFilter<"BuffingEntry"> | number
    buffing_person?: XOR<AddBuffingScalarRelationFilter, AddBuffingWhereInput>
    castingItem?: XOR<CastingItemsScalarRelationFilter, CastingItemsWhereInput>
    filing_items?: FilingItemsListRelationFilter
    setting_items?: SettingItemsListRelationFilter
    BuffingTotalBalance?: BuffingTotalBalanceListRelationFilter
    LotBuffingMapper?: LotBuffingMapperListRelationFilter
    BuffingItems?: BuffingItemsListRelationFilter
  }, "id">

  export type BuffingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
    _count?: BuffingEntryCountOrderByAggregateInput
    _avg?: BuffingEntryAvgOrderByAggregateInput
    _max?: BuffingEntryMaxOrderByAggregateInput
    _min?: BuffingEntryMinOrderByAggregateInput
    _sum?: BuffingEntrySumOrderByAggregateInput
  }

  export type BuffingEntryScalarWhereWithAggregatesInput = {
    AND?: BuffingEntryScalarWhereWithAggregatesInput | BuffingEntryScalarWhereWithAggregatesInput[]
    OR?: BuffingEntryScalarWhereWithAggregatesInput[]
    NOT?: BuffingEntryScalarWhereWithAggregatesInput | BuffingEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuffingEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuffingEntry"> | Date | string
    buffing_person_id?: IntWithAggregatesFilter<"BuffingEntry"> | number
    casting_item_id?: IntWithAggregatesFilter<"BuffingEntry"> | number
  }

  export type BuffingItemsWhereInput = {
    AND?: BuffingItemsWhereInput | BuffingItemsWhereInput[]
    OR?: BuffingItemsWhereInput[]
    NOT?: BuffingItemsWhereInput | BuffingItemsWhereInput[]
    id?: IntFilter<"BuffingItems"> | number
    createdAt?: DateTimeFilter<"BuffingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"BuffingItems"> | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFilter<"BuffingItems"> | number
    scrap_weight?: FloatFilter<"BuffingItems"> | number
    touch_id?: IntFilter<"BuffingItems"> | number
    item_purity?: FloatFilter<"BuffingItems"> | number
    scrap_remarks?: StringNullableFilter<"BuffingItems"> | string | null
    buffing_entry_id?: IntFilter<"BuffingItems"> | number
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    stock?: StockListRelationFilter
    buffing_wastage?: BuffingWastageListRelationFilter
    buffingEntryId?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }

  export type BuffingItemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrderInput | SortOrder
    buffing_entry_id?: SortOrder
    item?: AddItemOrderByWithRelationInput
    touch?: AddTouchOrderByWithRelationInput
    stock?: StockOrderByRelationAggregateInput
    buffing_wastage?: BuffingWastageOrderByRelationAggregateInput
    buffingEntryId?: BuffingEntryOrderByWithRelationInput
    _relevance?: BuffingItemsOrderByRelevanceInput
  }

  export type BuffingItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuffingItemsWhereInput | BuffingItemsWhereInput[]
    OR?: BuffingItemsWhereInput[]
    NOT?: BuffingItemsWhereInput | BuffingItemsWhereInput[]
    createdAt?: DateTimeFilter<"BuffingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"BuffingItems"> | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFilter<"BuffingItems"> | number
    scrap_weight?: FloatFilter<"BuffingItems"> | number
    touch_id?: IntFilter<"BuffingItems"> | number
    item_purity?: FloatFilter<"BuffingItems"> | number
    scrap_remarks?: StringNullableFilter<"BuffingItems"> | string | null
    buffing_entry_id?: IntFilter<"BuffingItems"> | number
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    stock?: StockListRelationFilter
    buffing_wastage?: BuffingWastageListRelationFilter
    buffingEntryId?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }, "id">

  export type BuffingItemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrderInput | SortOrder
    buffing_entry_id?: SortOrder
    _count?: BuffingItemsCountOrderByAggregateInput
    _avg?: BuffingItemsAvgOrderByAggregateInput
    _max?: BuffingItemsMaxOrderByAggregateInput
    _min?: BuffingItemsMinOrderByAggregateInput
    _sum?: BuffingItemsSumOrderByAggregateInput
  }

  export type BuffingItemsScalarWhereWithAggregatesInput = {
    AND?: BuffingItemsScalarWhereWithAggregatesInput | BuffingItemsScalarWhereWithAggregatesInput[]
    OR?: BuffingItemsScalarWhereWithAggregatesInput[]
    NOT?: BuffingItemsScalarWhereWithAggregatesInput | BuffingItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuffingItems"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuffingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEWithAggregatesFilter<"BuffingItems"> | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntWithAggregatesFilter<"BuffingItems"> | number
    scrap_weight?: FloatWithAggregatesFilter<"BuffingItems"> | number
    touch_id?: IntWithAggregatesFilter<"BuffingItems"> | number
    item_purity?: FloatWithAggregatesFilter<"BuffingItems"> | number
    scrap_remarks?: StringNullableWithAggregatesFilter<"BuffingItems"> | string | null
    buffing_entry_id?: IntWithAggregatesFilter<"BuffingItems"> | number
  }

  export type BuffingTotalBalanceWhereInput = {
    AND?: BuffingTotalBalanceWhereInput | BuffingTotalBalanceWhereInput[]
    OR?: BuffingTotalBalanceWhereInput[]
    NOT?: BuffingTotalBalanceWhereInput | BuffingTotalBalanceWhereInput[]
    id?: IntFilter<"BuffingTotalBalance"> | number
    createdAt?: DateTimeFilter<"BuffingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"BuffingTotalBalance"> | number
    remarks?: StringNullableFilter<"BuffingTotalBalance"> | string | null
    wastage?: BoolFilter<"BuffingTotalBalance"> | boolean
    total_scrap_weight?: FloatNullableFilter<"BuffingTotalBalance"> | number | null
    balance?: FloatFilter<"BuffingTotalBalance"> | number
    buffing_entry_id?: IntFilter<"BuffingTotalBalance"> | number
    BuffingEntryId?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }

  export type BuffingTotalBalanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    remarks?: SortOrderInput | SortOrder
    wastage?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
    BuffingEntryId?: BuffingEntryOrderByWithRelationInput
    _relevance?: BuffingTotalBalanceOrderByRelevanceInput
  }

  export type BuffingTotalBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuffingTotalBalanceWhereInput | BuffingTotalBalanceWhereInput[]
    OR?: BuffingTotalBalanceWhereInput[]
    NOT?: BuffingTotalBalanceWhereInput | BuffingTotalBalanceWhereInput[]
    createdAt?: DateTimeFilter<"BuffingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"BuffingTotalBalance"> | number
    remarks?: StringNullableFilter<"BuffingTotalBalance"> | string | null
    wastage?: BoolFilter<"BuffingTotalBalance"> | boolean
    total_scrap_weight?: FloatNullableFilter<"BuffingTotalBalance"> | number | null
    balance?: FloatFilter<"BuffingTotalBalance"> | number
    buffing_entry_id?: IntFilter<"BuffingTotalBalance"> | number
    BuffingEntryId?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }, "id">

  export type BuffingTotalBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    remarks?: SortOrderInput | SortOrder
    wastage?: SortOrder
    total_scrap_weight?: SortOrderInput | SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
    _count?: BuffingTotalBalanceCountOrderByAggregateInput
    _avg?: BuffingTotalBalanceAvgOrderByAggregateInput
    _max?: BuffingTotalBalanceMaxOrderByAggregateInput
    _min?: BuffingTotalBalanceMinOrderByAggregateInput
    _sum?: BuffingTotalBalanceSumOrderByAggregateInput
  }

  export type BuffingTotalBalanceScalarWhereWithAggregatesInput = {
    AND?: BuffingTotalBalanceScalarWhereWithAggregatesInput | BuffingTotalBalanceScalarWhereWithAggregatesInput[]
    OR?: BuffingTotalBalanceScalarWhereWithAggregatesInput[]
    NOT?: BuffingTotalBalanceScalarWhereWithAggregatesInput | BuffingTotalBalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuffingTotalBalance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuffingTotalBalance"> | Date | string
    receipt_weight?: FloatWithAggregatesFilter<"BuffingTotalBalance"> | number
    remarks?: StringNullableWithAggregatesFilter<"BuffingTotalBalance"> | string | null
    wastage?: BoolWithAggregatesFilter<"BuffingTotalBalance"> | boolean
    total_scrap_weight?: FloatNullableWithAggregatesFilter<"BuffingTotalBalance"> | number | null
    balance?: FloatWithAggregatesFilter<"BuffingTotalBalance"> | number
    buffing_entry_id?: IntWithAggregatesFilter<"BuffingTotalBalance"> | number
  }

  export type LotBuffingMapperWhereInput = {
    AND?: LotBuffingMapperWhereInput | LotBuffingMapperWhereInput[]
    OR?: LotBuffingMapperWhereInput[]
    NOT?: LotBuffingMapperWhereInput | LotBuffingMapperWhereInput[]
    id?: IntFilter<"LotBuffingMapper"> | number
    buffing_id?: IntFilter<"LotBuffingMapper"> | number
    lot_id?: IntFilter<"LotBuffingMapper"> | number
    setting_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    filing_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    buffing_entry_id?: IntFilter<"LotBuffingMapper"> | number
    buffingId?: XOR<AddBuffingScalarRelationFilter, AddBuffingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    settingItemId?: XOR<SettingItemsNullableScalarRelationFilter, SettingItemsWhereInput> | null
    filingItemId?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    buffingEntry?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }

  export type LotBuffingMapperOrderByWithRelationInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrderInput | SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    buffing_entry_id?: SortOrder
    buffingId?: AddBuffingOrderByWithRelationInput
    lotId?: LotInfoOrderByWithRelationInput
    settingItemId?: SettingItemsOrderByWithRelationInput
    filingItemId?: FilingItemsOrderByWithRelationInput
    buffingEntry?: BuffingEntryOrderByWithRelationInput
  }

  export type LotBuffingMapperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LotBuffingMapperWhereInput | LotBuffingMapperWhereInput[]
    OR?: LotBuffingMapperWhereInput[]
    NOT?: LotBuffingMapperWhereInput | LotBuffingMapperWhereInput[]
    buffing_id?: IntFilter<"LotBuffingMapper"> | number
    lot_id?: IntFilter<"LotBuffingMapper"> | number
    setting_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    filing_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    buffing_entry_id?: IntFilter<"LotBuffingMapper"> | number
    buffingId?: XOR<AddBuffingScalarRelationFilter, AddBuffingWhereInput>
    lotId?: XOR<LotInfoScalarRelationFilter, LotInfoWhereInput>
    settingItemId?: XOR<SettingItemsNullableScalarRelationFilter, SettingItemsWhereInput> | null
    filingItemId?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    buffingEntry?: XOR<BuffingEntryScalarRelationFilter, BuffingEntryWhereInput>
  }, "id">

  export type LotBuffingMapperOrderByWithAggregationInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrderInput | SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    buffing_entry_id?: SortOrder
    _count?: LotBuffingMapperCountOrderByAggregateInput
    _avg?: LotBuffingMapperAvgOrderByAggregateInput
    _max?: LotBuffingMapperMaxOrderByAggregateInput
    _min?: LotBuffingMapperMinOrderByAggregateInput
    _sum?: LotBuffingMapperSumOrderByAggregateInput
  }

  export type LotBuffingMapperScalarWhereWithAggregatesInput = {
    AND?: LotBuffingMapperScalarWhereWithAggregatesInput | LotBuffingMapperScalarWhereWithAggregatesInput[]
    OR?: LotBuffingMapperScalarWhereWithAggregatesInput[]
    NOT?: LotBuffingMapperScalarWhereWithAggregatesInput | LotBuffingMapperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LotBuffingMapper"> | number
    buffing_id?: IntWithAggregatesFilter<"LotBuffingMapper"> | number
    lot_id?: IntWithAggregatesFilter<"LotBuffingMapper"> | number
    setting_item_id?: IntNullableWithAggregatesFilter<"LotBuffingMapper"> | number | null
    filing_item_id?: IntNullableWithAggregatesFilter<"LotBuffingMapper"> | number | null
    buffing_entry_id?: IntWithAggregatesFilter<"LotBuffingMapper"> | number
  }

  export type BuffingWastageWhereInput = {
    AND?: BuffingWastageWhereInput | BuffingWastageWhereInput[]
    OR?: BuffingWastageWhereInput[]
    NOT?: BuffingWastageWhereInput | BuffingWastageWhereInput[]
    id?: IntFilter<"BuffingWastage"> | number
    createdAt?: DateTimeFilter<"BuffingWastage"> | Date | string
    total_receipt?: FloatFilter<"BuffingWastage"> | number
    total_wastage?: FloatFilter<"BuffingWastage"> | number
    balance?: FloatFilter<"BuffingWastage"> | number
    wastage_percentage?: IntFilter<"BuffingWastage"> | number
    given_gold?: FloatNullableFilter<"BuffingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"BuffingWastage"> | number | null
    overall_wastage?: FloatFilter<"BuffingWastage"> | number
    closing_balance?: FloatFilter<"BuffingWastage"> | number
    opening_balance?: FloatFilter<"BuffingWastage"> | number
    buffing_person_id?: IntNullableFilter<"BuffingWastage"> | number | null
    buffing_lot_id?: IntNullableFilter<"BuffingWastage"> | number | null
    buffingPersonId?: XOR<AddBuffingNullableScalarRelationFilter, AddBuffingWhereInput> | null
    buffingLotId?: XOR<LotInfoNullableScalarRelationFilter, LotInfoWhereInput> | null
    buffing_items?: BuffingItemsListRelationFilter
  }

  export type BuffingWastageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrderInput | SortOrder
    buffing_lot_id?: SortOrderInput | SortOrder
    buffingPersonId?: AddBuffingOrderByWithRelationInput
    buffingLotId?: LotInfoOrderByWithRelationInput
    buffing_items?: BuffingItemsOrderByRelationAggregateInput
  }

  export type BuffingWastageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuffingWastageWhereInput | BuffingWastageWhereInput[]
    OR?: BuffingWastageWhereInput[]
    NOT?: BuffingWastageWhereInput | BuffingWastageWhereInput[]
    createdAt?: DateTimeFilter<"BuffingWastage"> | Date | string
    total_receipt?: FloatFilter<"BuffingWastage"> | number
    total_wastage?: FloatFilter<"BuffingWastage"> | number
    balance?: FloatFilter<"BuffingWastage"> | number
    wastage_percentage?: IntFilter<"BuffingWastage"> | number
    given_gold?: FloatNullableFilter<"BuffingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"BuffingWastage"> | number | null
    overall_wastage?: FloatFilter<"BuffingWastage"> | number
    closing_balance?: FloatFilter<"BuffingWastage"> | number
    opening_balance?: FloatFilter<"BuffingWastage"> | number
    buffing_person_id?: IntNullableFilter<"BuffingWastage"> | number | null
    buffing_lot_id?: IntNullableFilter<"BuffingWastage"> | number | null
    buffingPersonId?: XOR<AddBuffingNullableScalarRelationFilter, AddBuffingWhereInput> | null
    buffingLotId?: XOR<LotInfoNullableScalarRelationFilter, LotInfoWhereInput> | null
    buffing_items?: BuffingItemsListRelationFilter
  }, "id">

  export type BuffingWastageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrderInput | SortOrder
    add_wastage?: SortOrderInput | SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrderInput | SortOrder
    buffing_lot_id?: SortOrderInput | SortOrder
    _count?: BuffingWastageCountOrderByAggregateInput
    _avg?: BuffingWastageAvgOrderByAggregateInput
    _max?: BuffingWastageMaxOrderByAggregateInput
    _min?: BuffingWastageMinOrderByAggregateInput
    _sum?: BuffingWastageSumOrderByAggregateInput
  }

  export type BuffingWastageScalarWhereWithAggregatesInput = {
    AND?: BuffingWastageScalarWhereWithAggregatesInput | BuffingWastageScalarWhereWithAggregatesInput[]
    OR?: BuffingWastageScalarWhereWithAggregatesInput[]
    NOT?: BuffingWastageScalarWhereWithAggregatesInput | BuffingWastageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuffingWastage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BuffingWastage"> | Date | string
    total_receipt?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    total_wastage?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    balance?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    wastage_percentage?: IntWithAggregatesFilter<"BuffingWastage"> | number
    given_gold?: FloatNullableWithAggregatesFilter<"BuffingWastage"> | number | null
    add_wastage?: FloatNullableWithAggregatesFilter<"BuffingWastage"> | number | null
    overall_wastage?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    closing_balance?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    opening_balance?: FloatWithAggregatesFilter<"BuffingWastage"> | number
    buffing_person_id?: IntNullableWithAggregatesFilter<"BuffingWastage"> | number | null
    buffing_lot_id?: IntNullableWithAggregatesFilter<"BuffingWastage"> | number | null
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: IntFilter<"Stock"> | number
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    casting_item_id?: IntNullableFilter<"Stock"> | number | null
    filing_item_id?: IntNullableFilter<"Stock"> | number | null
    setting_item_id?: IntNullableFilter<"Stock"> | number | null
    buffing_item_id?: IntNullableFilter<"Stock"> | number | null
    item_id?: IntFilter<"Stock"> | number
    weight?: FloatFilter<"Stock"> | number
    touch_id?: IntFilter<"Stock"> | number
    item_purity?: FloatFilter<"Stock"> | number
    remarks?: StringNullableFilter<"Stock"> | string | null
    casting_customer_id?: IntFilter<"Stock"> | number
    castingItem?: XOR<CastingItemsNullableScalarRelationFilter, CastingItemsWhereInput> | null
    filingItem?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    settingItem?: XOR<SettingItemsNullableScalarRelationFilter, SettingItemsWhereInput> | null
    buffingItem?: XOR<BuffingItemsNullableScalarRelationFilter, BuffingItemsWhereInput> | null
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    casting_item_id?: SortOrderInput | SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    setting_item_id?: SortOrderInput | SortOrder
    buffing_item_id?: SortOrderInput | SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    casting_customer_id?: SortOrder
    castingItem?: CastingItemsOrderByWithRelationInput
    filingItem?: FilingItemsOrderByWithRelationInput
    settingItem?: SettingItemsOrderByWithRelationInput
    buffingItem?: BuffingItemsOrderByWithRelationInput
    item?: AddItemOrderByWithRelationInput
    touch?: AddTouchOrderByWithRelationInput
    casting_customer?: AddCastingOrderByWithRelationInput
    _relevance?: StockOrderByRelevanceInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    casting_item_id?: IntNullableFilter<"Stock"> | number | null
    filing_item_id?: IntNullableFilter<"Stock"> | number | null
    setting_item_id?: IntNullableFilter<"Stock"> | number | null
    buffing_item_id?: IntNullableFilter<"Stock"> | number | null
    item_id?: IntFilter<"Stock"> | number
    weight?: FloatFilter<"Stock"> | number
    touch_id?: IntFilter<"Stock"> | number
    item_purity?: FloatFilter<"Stock"> | number
    remarks?: StringNullableFilter<"Stock"> | string | null
    casting_customer_id?: IntFilter<"Stock"> | number
    castingItem?: XOR<CastingItemsNullableScalarRelationFilter, CastingItemsWhereInput> | null
    filingItem?: XOR<FilingItemsNullableScalarRelationFilter, FilingItemsWhereInput> | null
    settingItem?: XOR<SettingItemsNullableScalarRelationFilter, SettingItemsWhereInput> | null
    buffingItem?: XOR<BuffingItemsNullableScalarRelationFilter, BuffingItemsWhereInput> | null
    item?: XOR<AddItemScalarRelationFilter, AddItemWhereInput>
    touch?: XOR<AddTouchScalarRelationFilter, AddTouchWhereInput>
    casting_customer?: XOR<AddCastingScalarRelationFilter, AddCastingWhereInput>
  }, "id">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    casting_item_id?: SortOrderInput | SortOrder
    filing_item_id?: SortOrderInput | SortOrder
    setting_item_id?: SortOrderInput | SortOrder
    buffing_item_id?: SortOrderInput | SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    casting_customer_id?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    casting_item_id?: IntNullableWithAggregatesFilter<"Stock"> | number | null
    filing_item_id?: IntNullableWithAggregatesFilter<"Stock"> | number | null
    setting_item_id?: IntNullableWithAggregatesFilter<"Stock"> | number | null
    buffing_item_id?: IntNullableWithAggregatesFilter<"Stock"> | number | null
    item_id?: IntWithAggregatesFilter<"Stock"> | number
    weight?: FloatWithAggregatesFilter<"Stock"> | number
    touch_id?: IntWithAggregatesFilter<"Stock"> | number
    item_purity?: FloatWithAggregatesFilter<"Stock"> | number
    remarks?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    casting_customer_id?: IntWithAggregatesFilter<"Stock"> | number
  }

  export type AddCustomerCreateInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    transactions?: CustomerTransactionCreateNestedManyWithoutCustomerInput
  }

  export type AddCustomerUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    transactions?: CustomerTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AddCustomerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: CustomerTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type AddCustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: CustomerTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AddCustomerCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddCustomerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddCustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddCastingCreateInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryCreateNestedManyWithoutCasting_customerInput
    castingitems?: CastingItemsCreateNestedManyWithoutCasting_customerInput
    stock?: StockCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryUncheckedCreateNestedManyWithoutCasting_customerInput
    castingitems?: CastingItemsUncheckedCreateNestedManyWithoutCasting_customerInput
    stock?: StockUncheckedCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUpdateManyWithoutCasting_customerNestedInput
    castingitems?: CastingItemsUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUpdateManyWithoutCasting_customerNestedInput
  }

  export type AddCastingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUncheckedUpdateManyWithoutCasting_customerNestedInput
    castingitems?: CastingItemsUncheckedUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUncheckedUpdateManyWithoutCasting_customerNestedInput
  }

  export type AddCastingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddCastingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddCastingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddFilingCreateInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryUncheckedCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingIdNestedInput
  }

  export type AddFilingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUncheckedUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingIdNestedInput
  }

  export type AddFilingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddFilingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddFilingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSettingCreateInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryCreateNestedManyWithoutSetting_personInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutSettingIdInput
    lotInfo?: LotInfoCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryUncheckedCreateNestedManyWithoutSetting_personInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingIdInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUpdateManyWithoutSetting_personNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutSettingIdNestedInput
    lotInfo?: LotInfoUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type AddSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUncheckedUpdateManyWithoutSetting_personNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingIdNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type AddSettingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddSettingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddBuffingCreateInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryCreateNestedManyWithoutBuffing_personInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingIdInput
    lotInfo?: LotInfoCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryUncheckedCreateNestedManyWithoutBuffing_personInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingIdInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUpdateManyWithoutBuffing_personNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingIdNestedInput
    lotInfo?: LotInfoUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type AddBuffingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUncheckedUpdateManyWithoutBuffing_personNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type AddBuffingCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddBuffingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddBuffingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSupplierItemCreateInput = {
    createdAt?: Date | string
    name: string
    email?: string | null
    phoneNumber?: string | null
    address?: string | null
  }

  export type AddSupplierItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    email?: string | null
    phoneNumber?: string | null
    address?: string | null
  }

  export type AddSupplierItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSupplierItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSupplierItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    email?: string | null
    phoneNumber?: string | null
    address?: string | null
  }

  export type AddSupplierItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddSupplierItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddPurchaseStockCreateInput = {
    createdAt?: Date | string
    name: string
    item: $Enums.ITEMTYPE
    goldWeight?: number | null
    goldTouch?: number | null
    goldPurity?: number | null
    goldRate?: number | null
    goldtotalValue?: number | null
    silverWeight?: number | null
    silverTouch?: number | null
    silverPurity?: number | null
    silverRate?: number | null
    silvertotalValue?: number | null
  }

  export type AddPurchaseStockUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    item: $Enums.ITEMTYPE
    goldWeight?: number | null
    goldTouch?: number | null
    goldPurity?: number | null
    goldRate?: number | null
    goldtotalValue?: number | null
    silverWeight?: number | null
    silverTouch?: number | null
    silverPurity?: number | null
    silverRate?: number | null
    silvertotalValue?: number | null
  }

  export type AddPurchaseStockUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    item?: EnumITEMTYPEFieldUpdateOperationsInput | $Enums.ITEMTYPE
    goldWeight?: NullableIntFieldUpdateOperationsInput | number | null
    goldTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    goldPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    goldtotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    silverWeight?: NullableIntFieldUpdateOperationsInput | number | null
    silverTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    silverPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    silverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    silvertotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AddPurchaseStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    item?: EnumITEMTYPEFieldUpdateOperationsInput | $Enums.ITEMTYPE
    goldWeight?: NullableIntFieldUpdateOperationsInput | number | null
    goldTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    goldPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    goldtotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    silverWeight?: NullableIntFieldUpdateOperationsInput | number | null
    silverTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    silverPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    silverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    silvertotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AddPurchaseStockCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
    item: $Enums.ITEMTYPE
    goldWeight?: number | null
    goldTouch?: number | null
    goldPurity?: number | null
    goldRate?: number | null
    goldtotalValue?: number | null
    silverWeight?: number | null
    silverTouch?: number | null
    silverPurity?: number | null
    silverRate?: number | null
    silvertotalValue?: number | null
  }

  export type AddPurchaseStockUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    item?: EnumITEMTYPEFieldUpdateOperationsInput | $Enums.ITEMTYPE
    goldWeight?: NullableIntFieldUpdateOperationsInput | number | null
    goldTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    goldPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    goldtotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    silverWeight?: NullableIntFieldUpdateOperationsInput | number | null
    silverTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    silverPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    silverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    silvertotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AddPurchaseStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    item?: EnumITEMTYPEFieldUpdateOperationsInput | $Enums.ITEMTYPE
    goldWeight?: NullableIntFieldUpdateOperationsInput | number | null
    goldTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    goldPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    goldtotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
    silverWeight?: NullableIntFieldUpdateOperationsInput | number | null
    silverTouch?: NullableFloatFieldUpdateOperationsInput | number | null
    silverPurity?: NullableFloatFieldUpdateOperationsInput | number | null
    silverRate?: NullableFloatFieldUpdateOperationsInput | number | null
    silvertotalValue?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerTransactionCreateInput = {
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    customer: AddCustomerCreateNestedOneWithoutTransactionsInput
  }

  export type CustomerTransactionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    customerId: number
  }

  export type CustomerTransactionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customer?: AddCustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type CustomerTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerTransactionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    customerId: number
  }

  export type CustomerTransactionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
  }

  export type AddItemCreateInput = {
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsCreateNestedManyWithoutItemInput
    stock?: StockCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutItemInput
    stock?: StockUncheckedCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUpdateManyWithoutItemNestedInput
    stock?: StockUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUncheckedUpdateManyWithoutItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AddItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    name: string
  }

  export type AddItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddTouchCreateInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchCreateManyInput = {
    id?: number
    createdAt?: Date | string
    touch: number
  }

  export type AddTouchUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
  }

  export type AddTouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
  }

  export type CastingEntryCreateInput = {
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    touch: AddTouchCreateNestedOneWithoutCasting_entryInput
    casting_customer: AddCastingCreateNestedOneWithoutEntriesInput
    items?: CastingItemsCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    items?: CastingItemsUncheckedCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    touch?: AddTouchUpdateOneRequiredWithoutCasting_entryNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutEntriesNestedInput
    items?: CastingItemsUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    items?: CastingItemsUncheckedUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
  }

  export type CastingEntryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
  }

  export type CastingEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastingItemsCreateInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
  }

  export type CastingItemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceCreateInput = {
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
    item_entry_id: CastingEntryCreateNestedOneWithoutCastiingTotalBalanceInput
  }

  export type CastiingTotalBalanceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
    item_entry: number
  }

  export type CastiingTotalBalanceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
    item_entry_id?: CastingEntryUpdateOneRequiredWithoutCastiingTotalBalanceNestedInput
  }

  export type CastiingTotalBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
    item_entry?: IntFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
    item_entry: number
  }

  export type CastiingTotalBalanceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
    item_entry?: IntFieldUpdateOperationsInput | number
  }

  export type LotInfoCreateInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUpdateInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoCreateManyInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
  }

  export type LotInfoUpdateManyMutationInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LotInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FilingEntryCreateInput = {
    createdAt?: Date | string
    filing_person: AddFilingCreateNestedOneWithoutFilingsInput
    castingItem: CastingItemsCreateNestedOneWithoutFilingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person?: AddFilingUpdateOneRequiredWithoutFilingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    casting_item_id: number
  }

  export type FilingEntryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilingEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotFilingMapperCreateInput = {
    filingId: AddFilingCreateNestedOneWithoutLotFilingMapperInput
    lotId: LotInfoCreateNestedOneWithoutFilingMapperInput
    itemId: CastingItemsCreateNestedOneWithoutFilingLotMapperInput
    filing_items?: FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput
    filingEntry: FilingEntryCreateNestedOneWithoutLotFilingMapperInput
  }

  export type LotFilingMapperUncheckedCreateInput = {
    id?: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_entry_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperUpdateInput = {
    filingId?: AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput
    itemId?: CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput
    filing_items?: FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput
    filingEntry?: FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput
  }

  export type LotFilingMapperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperCreateManyInput = {
    id?: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_entry_id: number
  }

  export type LotFilingMapperUpdateManyMutationInput = {

  }

  export type LotFilingMapperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingItemsCreateInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
  }

  export type FilingItemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
  }

  export type FilingItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilingTotalBalanceCreateInput = {
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
    filingEntryId: FilingEntryCreateNestedOneWithoutFilingTotalBalanceInput
  }

  export type FilingTotalBalanceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
    filing_entry_id: number
  }

  export type FilingTotalBalanceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
    filingEntryId?: FilingEntryUpdateOneRequiredWithoutFilingTotalBalanceNestedInput
  }

  export type FilingTotalBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingTotalBalanceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
    filing_entry_id: number
  }

  export type FilingTotalBalanceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type FilingTotalBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingWastageCreateInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filingPersonId?: AddFilingCreateNestedOneWithoutFilingWastagesInput
    filingLotId?: LotInfoCreateNestedOneWithoutFilingWastagesInput
    filing_items?: FilingItemsCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id?: number | null
    filing_lot_id?: number | null
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filingPersonId?: AddFilingUpdateOneWithoutFilingWastagesNestedInput
    filingLotId?: LotInfoUpdateOneWithoutFilingWastagesNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id?: number | null
    filing_lot_id?: number | null
  }

  export type FilingWastageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
  }

  export type FilingWastageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingEntryCreateInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
  }

  export type SettingEntryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingItemsCreateInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
  }

  export type SettingItemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperCreateInput = {
    settingId: AddSettingCreateNestedOneWithoutSettingMapperInput
    lotId: LotInfoCreateNestedOneWithoutSettingMapperInput
    itemId?: FilingItemsCreateNestedOneWithoutLot_setting_mapperInput
    settingEntry: SettingEntryCreateNestedOneWithoutLotSettingMapperInput
  }

  export type LotSettingMapperUncheckedCreateInput = {
    id?: number
    setting_id: number
    lot_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotSettingMapperUpdateInput = {
    settingId?: AddSettingUpdateOneRequiredWithoutSettingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutSettingMapperNestedInput
    itemId?: FilingItemsUpdateOneWithoutLot_setting_mapperNestedInput
    settingEntry?: SettingEntryUpdateOneRequiredWithoutLotSettingMapperNestedInput
  }

  export type LotSettingMapperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperCreateManyInput = {
    id?: number
    setting_id: number
    lot_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotSettingMapperUpdateManyMutationInput = {

  }

  export type LotSettingMapperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingTotalBalanceCreateInput = {
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
    setting_entry: SettingEntryCreateNestedOneWithoutSettingTotalBalanceInput
  }

  export type SettingTotalBalanceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
    setting_entry_id: number
  }

  export type SettingTotalBalanceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    setting_entry?: SettingEntryUpdateOneRequiredWithoutSettingTotalBalanceNestedInput
  }

  export type SettingTotalBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingTotalBalanceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
    setting_entry_id: number
  }

  export type SettingTotalBalanceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SettingTotalBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingWastageCreateInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_items?: SettingItemsCreateNestedManyWithoutSetting_wastageInput
    SettingEntryId: SettingEntryCreateNestedOneWithoutSettingWastageInput
  }

  export type SettingWastageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_entry_id: number
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutSetting_wastageInput
  }

  export type SettingWastageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_items?: SettingItemsUpdateManyWithoutSetting_wastageNestedInput
    SettingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingWastageNestedInput
  }

  export type SettingWastageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_items?: SettingItemsUncheckedUpdateManyWithoutSetting_wastageNestedInput
  }

  export type SettingWastageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_entry_id: number
  }

  export type SettingWastageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
  }

  export type SettingWastageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingEntryCreateInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
  }

  export type BuffingEntryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuffingEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingItemsCreateInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutBuffing_itemsInput
    touch: AddTouchCreateNestedOneWithoutBuffing_itemsInput
    stock?: StockCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageCreateNestedManyWithoutBuffing_itemsInput
    buffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingItemsInput
  }

  export type BuffingItemsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
    stock?: StockUncheckedCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput
    stock?: StockUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput
    buffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
    stock?: StockUncheckedUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type BuffingItemsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
  }

  export type BuffingItemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuffingItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceCreateInput = {
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
    BuffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingTotalBalanceInput
  }

  export type BuffingTotalBalanceUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
    buffing_entry_id: number
  }

  export type BuffingTotalBalanceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
    BuffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingTotalBalanceNestedInput
  }

  export type BuffingTotalBalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceCreateManyInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
    buffing_entry_id: number
  }

  export type BuffingTotalBalanceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperCreateInput = {
    buffingId: AddBuffingCreateNestedOneWithoutBuffingMapperInput
    lotId: LotInfoCreateNestedOneWithoutBuffingMapperInput
    settingItemId?: SettingItemsCreateNestedOneWithoutLotBuffingMapperInput
    filingItemId?: FilingItemsCreateNestedOneWithoutLotBuffingMapperInput
    buffingEntry: BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperUpdateInput = {
    buffingId?: AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput
    settingItemId?: SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    filingItemId?: FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    buffingEntry?: BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperCreateManyInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperUpdateManyMutationInput = {

  }

  export type LotBuffingMapperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingWastageCreateInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffingPersonId?: AddBuffingCreateNestedOneWithoutBuffingWastagesInput
    buffingLotId?: LotInfoCreateNestedOneWithoutBuffingWastagesInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id?: number | null
    buffing_lot_id?: number | null
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffingPersonId?: AddBuffingUpdateOneWithoutBuffingWastagesNestedInput
    buffingLotId?: LotInfoUpdateOneWithoutBuffingWastagesNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id?: number | null
    buffing_lot_id?: number | null
  }

  export type BuffingWastageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
  }

  export type BuffingWastageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockCreateInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockCreateManyInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CustomerTransactionListRelationFilter = {
    every?: CustomerTransactionWhereInput
    some?: CustomerTransactionWhereInput
    none?: CustomerTransactionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddCustomerOrderByRelevanceInput = {
    fields: AddCustomerOrderByRelevanceFieldEnum | AddCustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CastingEntryListRelationFilter = {
    every?: CastingEntryWhereInput
    some?: CastingEntryWhereInput
    none?: CastingEntryWhereInput
  }

  export type CastingItemsListRelationFilter = {
    every?: CastingItemsWhereInput
    some?: CastingItemsWhereInput
    none?: CastingItemsWhereInput
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type CastingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CastingItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddCastingOrderByRelevanceInput = {
    fields: AddCastingOrderByRelevanceFieldEnum | AddCastingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddCastingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCastingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddCastingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCastingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddCastingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FilingWastageListRelationFilter = {
    every?: FilingWastageWhereInput
    some?: FilingWastageWhereInput
    none?: FilingWastageWhereInput
  }

  export type FilingEntryListRelationFilter = {
    every?: FilingEntryWhereInput
    some?: FilingEntryWhereInput
    none?: FilingEntryWhereInput
  }

  export type LotInfoListRelationFilter = {
    every?: LotInfoWhereInput
    some?: LotInfoWhereInput
    none?: LotInfoWhereInput
  }

  export type LotFilingMapperListRelationFilter = {
    every?: LotFilingMapperWhereInput
    some?: LotFilingMapperWhereInput
    none?: LotFilingMapperWhereInput
  }

  export type FilingWastageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotFilingMapperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddFilingOrderByRelevanceInput = {
    fields: AddFilingOrderByRelevanceFieldEnum | AddFilingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddFilingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddFilingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddFilingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddFilingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddFilingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingEntryListRelationFilter = {
    every?: SettingEntryWhereInput
    some?: SettingEntryWhereInput
    none?: SettingEntryWhereInput
  }

  export type LotSettingMapperListRelationFilter = {
    every?: LotSettingMapperWhereInput
    some?: LotSettingMapperWhereInput
    none?: LotSettingMapperWhereInput
  }

  export type SettingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotSettingMapperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddSettingOrderByRelevanceInput = {
    fields: AddSettingOrderByRelevanceFieldEnum | AddSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddSettingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddSettingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuffingEntryListRelationFilter = {
    every?: BuffingEntryWhereInput
    some?: BuffingEntryWhereInput
    none?: BuffingEntryWhereInput
  }

  export type LotBuffingMapperListRelationFilter = {
    every?: LotBuffingMapperWhereInput
    some?: LotBuffingMapperWhereInput
    none?: LotBuffingMapperWhereInput
  }

  export type BuffingWastageListRelationFilter = {
    every?: BuffingWastageWhereInput
    some?: BuffingWastageWhereInput
    none?: BuffingWastageWhereInput
  }

  export type BuffingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotBuffingMapperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuffingWastageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddBuffingOrderByRelevanceInput = {
    fields: AddBuffingOrderByRelevanceFieldEnum | AddBuffingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddBuffingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddBuffingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddBuffingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddBuffingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    email?: SortOrder
  }

  export type AddBuffingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddSupplierItemOrderByRelevanceInput = {
    fields: AddSupplierItemOrderByRelevanceFieldEnum | AddSupplierItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddSupplierItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
  }

  export type AddSupplierItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddSupplierItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
  }

  export type AddSupplierItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
  }

  export type AddSupplierItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumITEMTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.ITEMTYPE | EnumITEMTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.ITEMTYPE[]
    notIn?: $Enums.ITEMTYPE[]
    not?: NestedEnumITEMTYPEFilter<$PrismaModel> | $Enums.ITEMTYPE
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AddPurchaseStockOrderByRelevanceInput = {
    fields: AddPurchaseStockOrderByRelevanceFieldEnum | AddPurchaseStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddPurchaseStockCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    item?: SortOrder
    goldWeight?: SortOrder
    goldTouch?: SortOrder
    goldPurity?: SortOrder
    goldRate?: SortOrder
    goldtotalValue?: SortOrder
    silverWeight?: SortOrder
    silverTouch?: SortOrder
    silverPurity?: SortOrder
    silverRate?: SortOrder
    silvertotalValue?: SortOrder
  }

  export type AddPurchaseStockAvgOrderByAggregateInput = {
    id?: SortOrder
    goldWeight?: SortOrder
    goldTouch?: SortOrder
    goldPurity?: SortOrder
    goldRate?: SortOrder
    goldtotalValue?: SortOrder
    silverWeight?: SortOrder
    silverTouch?: SortOrder
    silverPurity?: SortOrder
    silverRate?: SortOrder
    silvertotalValue?: SortOrder
  }

  export type AddPurchaseStockMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    item?: SortOrder
    goldWeight?: SortOrder
    goldTouch?: SortOrder
    goldPurity?: SortOrder
    goldRate?: SortOrder
    goldtotalValue?: SortOrder
    silverWeight?: SortOrder
    silverTouch?: SortOrder
    silverPurity?: SortOrder
    silverRate?: SortOrder
    silvertotalValue?: SortOrder
  }

  export type AddPurchaseStockMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    item?: SortOrder
    goldWeight?: SortOrder
    goldTouch?: SortOrder
    goldPurity?: SortOrder
    goldRate?: SortOrder
    goldtotalValue?: SortOrder
    silverWeight?: SortOrder
    silverTouch?: SortOrder
    silverPurity?: SortOrder
    silverRate?: SortOrder
    silvertotalValue?: SortOrder
  }

  export type AddPurchaseStockSumOrderByAggregateInput = {
    id?: SortOrder
    goldWeight?: SortOrder
    goldTouch?: SortOrder
    goldPurity?: SortOrder
    goldRate?: SortOrder
    goldtotalValue?: SortOrder
    silverWeight?: SortOrder
    silverTouch?: SortOrder
    silverPurity?: SortOrder
    silverRate?: SortOrder
    silvertotalValue?: SortOrder
  }

  export type EnumITEMTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITEMTYPE | EnumITEMTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.ITEMTYPE[]
    notIn?: $Enums.ITEMTYPE[]
    not?: NestedEnumITEMTYPEWithAggregatesFilter<$PrismaModel> | $Enums.ITEMTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITEMTYPEFilter<$PrismaModel>
    _max?: NestedEnumITEMTYPEFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AddCustomerScalarRelationFilter = {
    is?: AddCustomerWhereInput
    isNot?: AddCustomerWhereInput
  }

  export type CustomerTransactionOrderByRelevanceInput = {
    fields: CustomerTransactionOrderByRelevanceFieldEnum | CustomerTransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    value?: SortOrder
    type?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    value?: SortOrder
    type?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    value?: SortOrder
    type?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    customerId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FilingItemsListRelationFilter = {
    every?: FilingItemsWhereInput
    some?: FilingItemsWhereInput
    none?: FilingItemsWhereInput
  }

  export type SettingItemsListRelationFilter = {
    every?: SettingItemsWhereInput
    some?: SettingItemsWhereInput
    none?: SettingItemsWhereInput
  }

  export type BuffingItemsListRelationFilter = {
    every?: BuffingItemsWhereInput
    some?: BuffingItemsWhereInput
    none?: BuffingItemsWhereInput
  }

  export type FilingItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuffingItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddItemOrderByRelevanceInput = {
    fields: AddItemOrderByRelevanceFieldEnum | AddItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type AddItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type AddItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type AddItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddTouchCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    touch?: SortOrder
  }

  export type AddTouchAvgOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type AddTouchMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    touch?: SortOrder
  }

  export type AddTouchMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    touch?: SortOrder
  }

  export type AddTouchSumOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type AddTouchScalarRelationFilter = {
    is?: AddTouchWhereInput
    isNot?: AddTouchWhereInput
  }

  export type AddCastingScalarRelationFilter = {
    is?: AddCastingWhereInput
    isNot?: AddCastingWhereInput
  }

  export type CastiingTotalBalanceListRelationFilter = {
    every?: CastiingTotalBalanceWhereInput
    some?: CastiingTotalBalanceWhereInput
    none?: CastiingTotalBalanceWhereInput
  }

  export type CastiingTotalBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CastingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingEntrySumOrderByAggregateInput = {
    id?: SortOrder
    given_gold?: SortOrder
    touch_id?: SortOrder
    purity?: SortOrder
    final_touch?: SortOrder
    pure_value?: SortOrder
    copper?: SortOrder
    final_weight?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type EnumCASTINGENTRYTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.CASTINGENTRYTYPE[]
    notIn?: $Enums.CASTINGENTRYTYPE[]
    not?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE
  }

  export type AddItemScalarRelationFilter = {
    is?: AddItemWhereInput
    isNot?: AddItemWhereInput
  }

  export type CastingEntryScalarRelationFilter = {
    is?: CastingEntryWhereInput
    isNot?: CastingEntryWhereInput
  }

  export type CastingItemsOrderByRelevanceInput = {
    fields: CastingItemsOrderByRelevanceFieldEnum | CastingItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CastingItemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingItemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CastingItemsSumOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    casting_entry_id?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type EnumCASTINGENTRYTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.CASTINGENTRYTYPE[]
    notIn?: $Enums.CASTINGENTRYTYPE[]
    not?: NestedEnumCASTINGENTRYTYPEWithAggregatesFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel>
    _max?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel>
  }

  export type CastiingTotalBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
  }

  export type CastiingTotalBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
  }

  export type CastiingTotalBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
  }

  export type CastiingTotalBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
  }

  export type CastiingTotalBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    total_item_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    total_wastage?: SortOrder
    item_entry?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AddFilingNullableScalarRelationFilter = {
    is?: AddFilingWhereInput | null
    isNot?: AddFilingWhereInput | null
  }

  export type AddSettingNullableScalarRelationFilter = {
    is?: AddSettingWhereInput | null
    isNot?: AddSettingWhereInput | null
  }

  export type AddBuffingNullableScalarRelationFilter = {
    is?: AddBuffingWhereInput | null
    isNot?: AddBuffingWhereInput | null
  }

  export type LotInfoCountOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrder
    setting_customer_id?: SortOrder
    buffing_customer_id?: SortOrder
    IsActive?: SortOrder
  }

  export type LotInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrder
    setting_customer_id?: SortOrder
    buffing_customer_id?: SortOrder
  }

  export type LotInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrder
    setting_customer_id?: SortOrder
    buffing_customer_id?: SortOrder
    IsActive?: SortOrder
  }

  export type LotInfoMinOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrder
    setting_customer_id?: SortOrder
    buffing_customer_id?: SortOrder
    IsActive?: SortOrder
  }

  export type LotInfoSumOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    filing_customer_id?: SortOrder
    setting_customer_id?: SortOrder
    buffing_customer_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AddFilingScalarRelationFilter = {
    is?: AddFilingWhereInput
    isNot?: AddFilingWhereInput
  }

  export type CastingItemsScalarRelationFilter = {
    is?: CastingItemsWhereInput
    isNot?: CastingItemsWhereInput
  }

  export type FilingTotalBalanceListRelationFilter = {
    every?: FilingTotalBalanceWhereInput
    some?: FilingTotalBalanceWhereInput
    none?: FilingTotalBalanceWhereInput
  }

  export type FilingTotalBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type FilingEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type FilingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type FilingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type FilingEntrySumOrderByAggregateInput = {
    id?: SortOrder
    filing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type LotInfoScalarRelationFilter = {
    is?: LotInfoWhereInput
    isNot?: LotInfoWhereInput
  }

  export type FilingEntryScalarRelationFilter = {
    is?: FilingEntryWhereInput
    isNot?: FilingEntryWhereInput
  }

  export type LotFilingMapperCountOrderByAggregateInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type LotFilingMapperAvgOrderByAggregateInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type LotFilingMapperMaxOrderByAggregateInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type LotFilingMapperMinOrderByAggregateInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type LotFilingMapperSumOrderByAggregateInput = {
    id?: SortOrder
    filing_id?: SortOrder
    lot_id?: SortOrder
    item_id?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type EnumSTONEOPTIONNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.STONEOPTION | EnumSTONEOPTIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.STONEOPTION[] | null
    notIn?: $Enums.STONEOPTION[] | null
    not?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel> | $Enums.STONEOPTION | null
  }

  export type LotFilingMapperNullableScalarRelationFilter = {
    is?: LotFilingMapperWhereInput | null
    isNot?: LotFilingMapperWhereInput | null
  }

  export type FilingItemsOrderByRelevanceInput = {
    fields: FilingItemsOrderByRelevanceFieldEnum | FilingItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FilingItemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_entry_id?: SortOrder
    type?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    stone_option?: SortOrder
    lot_filing_mapper_id?: SortOrder
  }

  export type FilingItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    filing_entry_id?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    lot_filing_mapper_id?: SortOrder
  }

  export type FilingItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_entry_id?: SortOrder
    type?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    stone_option?: SortOrder
    lot_filing_mapper_id?: SortOrder
  }

  export type FilingItemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    filing_entry_id?: SortOrder
    type?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    stone_option?: SortOrder
    lot_filing_mapper_id?: SortOrder
  }

  export type FilingItemsSumOrderByAggregateInput = {
    id?: SortOrder
    filing_entry_id?: SortOrder
    filing_item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    lot_filing_mapper_id?: SortOrder
  }

  export type EnumSTONEOPTIONNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STONEOPTION | EnumSTONEOPTIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.STONEOPTION[] | null
    notIn?: $Enums.STONEOPTION[] | null
    not?: NestedEnumSTONEOPTIONNullableWithAggregatesFilter<$PrismaModel> | $Enums.STONEOPTION | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel>
    _max?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel>
  }

  export type FilingTotalBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    after_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    wastage?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type FilingTotalBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    after_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type FilingTotalBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    after_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    wastage?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type FilingTotalBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    after_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    wastage?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type FilingTotalBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    after_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    filing_entry_id?: SortOrder
  }

  export type LotInfoNullableScalarRelationFilter = {
    is?: LotInfoWhereInput | null
    isNot?: LotInfoWhereInput | null
  }

  export type FilingWastageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrder
    filing_lot_id?: SortOrder
  }

  export type FilingWastageAvgOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrder
    filing_lot_id?: SortOrder
  }

  export type FilingWastageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrder
    filing_lot_id?: SortOrder
  }

  export type FilingWastageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrder
    filing_lot_id?: SortOrder
  }

  export type FilingWastageSumOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    filing_person_id?: SortOrder
    filing_lot_id?: SortOrder
  }

  export type AddSettingScalarRelationFilter = {
    is?: AddSettingWhereInput
    isNot?: AddSettingWhereInput
  }

  export type SettingTotalBalanceListRelationFilter = {
    every?: SettingTotalBalanceWhereInput
    some?: SettingTotalBalanceWhereInput
    none?: SettingTotalBalanceWhereInput
  }

  export type SettingWastageListRelationFilter = {
    every?: SettingWastageWhereInput
    some?: SettingWastageWhereInput
    none?: SettingWastageWhereInput
  }

  export type SettingTotalBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingWastageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type SettingEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type SettingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type SettingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type SettingEntrySumOrderByAggregateInput = {
    id?: SortOrder
    setting_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type EnumCASTINGENTRYTYPENullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel> | null
    in?: $Enums.CASTINGENTRYTYPE[] | null
    notIn?: $Enums.CASTINGENTRYTYPE[] | null
    not?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE | null
  }

  export type SettingEntryScalarRelationFilter = {
    is?: SettingEntryWhereInput
    isNot?: SettingEntryWhereInput
  }

  export type SettingItemsOrderByRelevanceInput = {
    fields: SettingItemsOrderByRelevanceFieldEnum | SettingItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingItemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingItemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingItemsSumOrderByAggregateInput = {
    id?: SortOrder
    setting_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type EnumCASTINGENTRYTYPENullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel> | null
    in?: $Enums.CASTINGENTRYTYPE[] | null
    notIn?: $Enums.CASTINGENTRYTYPE[] | null
    not?: NestedEnumCASTINGENTRYTYPENullableWithAggregatesFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel>
    _max?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel>
  }

  export type FilingItemsNullableScalarRelationFilter = {
    is?: FilingItemsWhereInput | null
    isNot?: FilingItemsWhereInput | null
  }

  export type LotSettingMapperCountOrderByAggregateInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type LotSettingMapperAvgOrderByAggregateInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type LotSettingMapperMaxOrderByAggregateInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type LotSettingMapperMinOrderByAggregateInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type LotSettingMapperSumOrderByAggregateInput = {
    id?: SortOrder
    setting_id?: SortOrder
    lot_id?: SortOrder
    filing_item_id?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingTotalBalanceOrderByRelevanceInput = {
    fields: SettingTotalBalanceOrderByRelevanceFieldEnum | SettingTotalBalanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingTotalBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingTotalBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingTotalBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingTotalBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingTotalBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    receipt_weight?: SortOrder
    stone_count?: SortOrder
    stone_weight?: SortOrder
    total_product_weight?: SortOrder
    current_balance_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingWastageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingWastageAvgOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingWastageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingWastageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type SettingWastageSumOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    setting_entry_id?: SortOrder
  }

  export type AddBuffingScalarRelationFilter = {
    is?: AddBuffingWhereInput
    isNot?: AddBuffingWhereInput
  }

  export type BuffingTotalBalanceListRelationFilter = {
    every?: BuffingTotalBalanceWhereInput
    some?: BuffingTotalBalanceWhereInput
    none?: BuffingTotalBalanceWhereInput
  }

  export type BuffingTotalBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuffingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type BuffingEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type BuffingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type BuffingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type BuffingEntrySumOrderByAggregateInput = {
    id?: SortOrder
    buffing_person_id?: SortOrder
    casting_item_id?: SortOrder
  }

  export type BuffingEntryScalarRelationFilter = {
    is?: BuffingEntryWhereInput
    isNot?: BuffingEntryWhereInput
  }

  export type BuffingItemsOrderByRelevanceInput = {
    fields: BuffingItemsOrderByRelevanceFieldEnum | BuffingItemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuffingItemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingItemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    scrap_remarks?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingItemsSumOrderByAggregateInput = {
    id?: SortOrder
    buffing_item_id?: SortOrder
    scrap_weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingTotalBalanceOrderByRelevanceInput = {
    fields: BuffingTotalBalanceOrderByRelevanceFieldEnum | BuffingTotalBalanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuffingTotalBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingTotalBalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    receipt_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingTotalBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingTotalBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    receipt_weight?: SortOrder
    remarks?: SortOrder
    wastage?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingTotalBalanceSumOrderByAggregateInput = {
    id?: SortOrder
    receipt_weight?: SortOrder
    total_scrap_weight?: SortOrder
    balance?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type SettingItemsNullableScalarRelationFilter = {
    is?: SettingItemsWhereInput | null
    isNot?: SettingItemsWhereInput | null
  }

  export type LotBuffingMapperCountOrderByAggregateInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrder
    filing_item_id?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type LotBuffingMapperAvgOrderByAggregateInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrder
    filing_item_id?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type LotBuffingMapperMaxOrderByAggregateInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrder
    filing_item_id?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type LotBuffingMapperMinOrderByAggregateInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrder
    filing_item_id?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type LotBuffingMapperSumOrderByAggregateInput = {
    id?: SortOrder
    buffing_id?: SortOrder
    lot_id?: SortOrder
    setting_item_id?: SortOrder
    filing_item_id?: SortOrder
    buffing_entry_id?: SortOrder
  }

  export type BuffingWastageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrder
    buffing_lot_id?: SortOrder
  }

  export type BuffingWastageAvgOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrder
    buffing_lot_id?: SortOrder
  }

  export type BuffingWastageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrder
    buffing_lot_id?: SortOrder
  }

  export type BuffingWastageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrder
    buffing_lot_id?: SortOrder
  }

  export type BuffingWastageSumOrderByAggregateInput = {
    id?: SortOrder
    total_receipt?: SortOrder
    total_wastage?: SortOrder
    balance?: SortOrder
    wastage_percentage?: SortOrder
    given_gold?: SortOrder
    add_wastage?: SortOrder
    overall_wastage?: SortOrder
    closing_balance?: SortOrder
    opening_balance?: SortOrder
    buffing_person_id?: SortOrder
    buffing_lot_id?: SortOrder
  }

  export type CastingItemsNullableScalarRelationFilter = {
    is?: CastingItemsWhereInput | null
    isNot?: CastingItemsWhereInput | null
  }

  export type BuffingItemsNullableScalarRelationFilter = {
    is?: BuffingItemsWhereInput | null
    isNot?: BuffingItemsWhereInput | null
  }

  export type StockOrderByRelevanceInput = {
    fields: StockOrderByRelevanceFieldEnum | StockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    casting_item_id?: SortOrder
    filing_item_id?: SortOrder
    setting_item_id?: SortOrder
    buffing_item_id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    id?: SortOrder
    casting_item_id?: SortOrder
    filing_item_id?: SortOrder
    setting_item_id?: SortOrder
    buffing_item_id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    casting_item_id?: SortOrder
    filing_item_id?: SortOrder
    setting_item_id?: SortOrder
    buffing_item_id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    casting_item_id?: SortOrder
    filing_item_id?: SortOrder
    setting_item_id?: SortOrder
    buffing_item_id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    remarks?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    id?: SortOrder
    casting_item_id?: SortOrder
    filing_item_id?: SortOrder
    setting_item_id?: SortOrder
    buffing_item_id?: SortOrder
    item_id?: SortOrder
    weight?: SortOrder
    touch_id?: SortOrder
    item_purity?: SortOrder
    casting_customer_id?: SortOrder
  }

  export type CustomerTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput> | CustomerTransactionCreateWithoutCustomerInput[] | CustomerTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerTransactionCreateOrConnectWithoutCustomerInput | CustomerTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerTransactionCreateManyCustomerInputEnvelope
    connect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
  }

  export type CustomerTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput> | CustomerTransactionCreateWithoutCustomerInput[] | CustomerTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerTransactionCreateOrConnectWithoutCustomerInput | CustomerTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerTransactionCreateManyCustomerInputEnvelope
    connect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CustomerTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput> | CustomerTransactionCreateWithoutCustomerInput[] | CustomerTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerTransactionCreateOrConnectWithoutCustomerInput | CustomerTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerTransactionUpsertWithWhereUniqueWithoutCustomerInput | CustomerTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerTransactionCreateManyCustomerInputEnvelope
    set?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    disconnect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    delete?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    connect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    update?: CustomerTransactionUpdateWithWhereUniqueWithoutCustomerInput | CustomerTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerTransactionUpdateManyWithWhereWithoutCustomerInput | CustomerTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerTransactionScalarWhereInput | CustomerTransactionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput> | CustomerTransactionCreateWithoutCustomerInput[] | CustomerTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerTransactionCreateOrConnectWithoutCustomerInput | CustomerTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerTransactionUpsertWithWhereUniqueWithoutCustomerInput | CustomerTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerTransactionCreateManyCustomerInputEnvelope
    set?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    disconnect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    delete?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    connect?: CustomerTransactionWhereUniqueInput | CustomerTransactionWhereUniqueInput[]
    update?: CustomerTransactionUpdateWithWhereUniqueWithoutCustomerInput | CustomerTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerTransactionUpdateManyWithWhereWithoutCustomerInput | CustomerTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerTransactionScalarWhereInput | CustomerTransactionScalarWhereInput[]
  }

  export type CastingEntryCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput> | CastingEntryCreateWithoutCasting_customerInput[] | CastingEntryUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCasting_customerInput | CastingEntryCreateOrConnectWithoutCasting_customerInput[]
    createMany?: CastingEntryCreateManyCasting_customerInputEnvelope
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
  }

  export type CastingItemsCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput> | CastingItemsCreateWithoutCasting_customerInput[] | CastingItemsUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCasting_customerInput | CastingItemsCreateOrConnectWithoutCasting_customerInput[]
    createMany?: CastingItemsCreateManyCasting_customerInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput> | StockCreateWithoutCasting_customerInput[] | StockUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCasting_customerInput | StockCreateOrConnectWithoutCasting_customerInput[]
    createMany?: StockCreateManyCasting_customerInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type CastingEntryUncheckedCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput> | CastingEntryCreateWithoutCasting_customerInput[] | CastingEntryUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCasting_customerInput | CastingEntryCreateOrConnectWithoutCasting_customerInput[]
    createMany?: CastingEntryCreateManyCasting_customerInputEnvelope
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
  }

  export type CastingItemsUncheckedCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput> | CastingItemsCreateWithoutCasting_customerInput[] | CastingItemsUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCasting_customerInput | CastingItemsCreateOrConnectWithoutCasting_customerInput[]
    createMany?: CastingItemsCreateManyCasting_customerInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutCasting_customerInput = {
    create?: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput> | StockCreateWithoutCasting_customerInput[] | StockUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCasting_customerInput | StockCreateOrConnectWithoutCasting_customerInput[]
    createMany?: StockCreateManyCasting_customerInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type CastingEntryUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput> | CastingEntryCreateWithoutCasting_customerInput[] | CastingEntryUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCasting_customerInput | CastingEntryCreateOrConnectWithoutCasting_customerInput[]
    upsert?: CastingEntryUpsertWithWhereUniqueWithoutCasting_customerInput | CastingEntryUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: CastingEntryCreateManyCasting_customerInputEnvelope
    set?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    disconnect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    delete?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    update?: CastingEntryUpdateWithWhereUniqueWithoutCasting_customerInput | CastingEntryUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: CastingEntryUpdateManyWithWhereWithoutCasting_customerInput | CastingEntryUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
  }

  export type CastingItemsUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput> | CastingItemsCreateWithoutCasting_customerInput[] | CastingItemsUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCasting_customerInput | CastingItemsCreateOrConnectWithoutCasting_customerInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutCasting_customerInput | CastingItemsUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: CastingItemsCreateManyCasting_customerInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutCasting_customerInput | CastingItemsUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutCasting_customerInput | CastingItemsUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type StockUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput> | StockCreateWithoutCasting_customerInput[] | StockUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCasting_customerInput | StockCreateOrConnectWithoutCasting_customerInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCasting_customerInput | StockUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: StockCreateManyCasting_customerInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCasting_customerInput | StockUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCasting_customerInput | StockUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type CastingEntryUncheckedUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput> | CastingEntryCreateWithoutCasting_customerInput[] | CastingEntryUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCasting_customerInput | CastingEntryCreateOrConnectWithoutCasting_customerInput[]
    upsert?: CastingEntryUpsertWithWhereUniqueWithoutCasting_customerInput | CastingEntryUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: CastingEntryCreateManyCasting_customerInputEnvelope
    set?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    disconnect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    delete?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    update?: CastingEntryUpdateWithWhereUniqueWithoutCasting_customerInput | CastingEntryUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: CastingEntryUpdateManyWithWhereWithoutCasting_customerInput | CastingEntryUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
  }

  export type CastingItemsUncheckedUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput> | CastingItemsCreateWithoutCasting_customerInput[] | CastingItemsUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCasting_customerInput | CastingItemsCreateOrConnectWithoutCasting_customerInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutCasting_customerInput | CastingItemsUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: CastingItemsCreateManyCasting_customerInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutCasting_customerInput | CastingItemsUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutCasting_customerInput | CastingItemsUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutCasting_customerNestedInput = {
    create?: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput> | StockCreateWithoutCasting_customerInput[] | StockUncheckedCreateWithoutCasting_customerInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCasting_customerInput | StockCreateOrConnectWithoutCasting_customerInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCasting_customerInput | StockUpsertWithWhereUniqueWithoutCasting_customerInput[]
    createMany?: StockCreateManyCasting_customerInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCasting_customerInput | StockUpdateWithWhereUniqueWithoutCasting_customerInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCasting_customerInput | StockUpdateManyWithWhereWithoutCasting_customerInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type FilingWastageCreateNestedManyWithoutFilingPersonIdInput = {
    create?: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput> | FilingWastageCreateWithoutFilingPersonIdInput[] | FilingWastageUncheckedCreateWithoutFilingPersonIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingPersonIdInput | FilingWastageCreateOrConnectWithoutFilingPersonIdInput[]
    createMany?: FilingWastageCreateManyFilingPersonIdInputEnvelope
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type FilingEntryCreateNestedManyWithoutFiling_personInput = {
    create?: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput> | FilingEntryCreateWithoutFiling_personInput[] | FilingEntryUncheckedCreateWithoutFiling_personInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFiling_personInput | FilingEntryCreateOrConnectWithoutFiling_personInput[]
    createMany?: FilingEntryCreateManyFiling_personInputEnvelope
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
  }

  export type LotInfoCreateNestedManyWithoutFilingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput> | LotInfoCreateWithoutFilingCustomerIdInput[] | LotInfoUncheckedCreateWithoutFilingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingCustomerIdInput | LotInfoCreateOrConnectWithoutFilingCustomerIdInput[]
    createMany?: LotInfoCreateManyFilingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type LotFilingMapperCreateNestedManyWithoutFilingIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput> | LotFilingMapperCreateWithoutFilingIdInput[] | LotFilingMapperUncheckedCreateWithoutFilingIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingIdInput | LotFilingMapperCreateOrConnectWithoutFilingIdInput[]
    createMany?: LotFilingMapperCreateManyFilingIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type FilingWastageUncheckedCreateNestedManyWithoutFilingPersonIdInput = {
    create?: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput> | FilingWastageCreateWithoutFilingPersonIdInput[] | FilingWastageUncheckedCreateWithoutFilingPersonIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingPersonIdInput | FilingWastageCreateOrConnectWithoutFilingPersonIdInput[]
    createMany?: FilingWastageCreateManyFilingPersonIdInputEnvelope
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type FilingEntryUncheckedCreateNestedManyWithoutFiling_personInput = {
    create?: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput> | FilingEntryCreateWithoutFiling_personInput[] | FilingEntryUncheckedCreateWithoutFiling_personInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFiling_personInput | FilingEntryCreateOrConnectWithoutFiling_personInput[]
    createMany?: FilingEntryCreateManyFiling_personInputEnvelope
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
  }

  export type LotInfoUncheckedCreateNestedManyWithoutFilingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput> | LotInfoCreateWithoutFilingCustomerIdInput[] | LotInfoUncheckedCreateWithoutFilingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingCustomerIdInput | LotInfoCreateOrConnectWithoutFilingCustomerIdInput[]
    createMany?: LotInfoCreateManyFilingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type LotFilingMapperUncheckedCreateNestedManyWithoutFilingIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput> | LotFilingMapperCreateWithoutFilingIdInput[] | LotFilingMapperUncheckedCreateWithoutFilingIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingIdInput | LotFilingMapperCreateOrConnectWithoutFilingIdInput[]
    createMany?: LotFilingMapperCreateManyFilingIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type FilingWastageUpdateManyWithoutFilingPersonIdNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput> | FilingWastageCreateWithoutFilingPersonIdInput[] | FilingWastageUncheckedCreateWithoutFilingPersonIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingPersonIdInput | FilingWastageCreateOrConnectWithoutFilingPersonIdInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFilingPersonIdInput | FilingWastageUpsertWithWhereUniqueWithoutFilingPersonIdInput[]
    createMany?: FilingWastageCreateManyFilingPersonIdInputEnvelope
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFilingPersonIdInput | FilingWastageUpdateWithWhereUniqueWithoutFilingPersonIdInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFilingPersonIdInput | FilingWastageUpdateManyWithWhereWithoutFilingPersonIdInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type FilingEntryUpdateManyWithoutFiling_personNestedInput = {
    create?: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput> | FilingEntryCreateWithoutFiling_personInput[] | FilingEntryUncheckedCreateWithoutFiling_personInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFiling_personInput | FilingEntryCreateOrConnectWithoutFiling_personInput[]
    upsert?: FilingEntryUpsertWithWhereUniqueWithoutFiling_personInput | FilingEntryUpsertWithWhereUniqueWithoutFiling_personInput[]
    createMany?: FilingEntryCreateManyFiling_personInputEnvelope
    set?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    disconnect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    delete?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    update?: FilingEntryUpdateWithWhereUniqueWithoutFiling_personInput | FilingEntryUpdateWithWhereUniqueWithoutFiling_personInput[]
    updateMany?: FilingEntryUpdateManyWithWhereWithoutFiling_personInput | FilingEntryUpdateManyWithWhereWithoutFiling_personInput[]
    deleteMany?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
  }

  export type LotInfoUpdateManyWithoutFilingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput> | LotInfoCreateWithoutFilingCustomerIdInput[] | LotInfoUncheckedCreateWithoutFilingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingCustomerIdInput | LotInfoCreateOrConnectWithoutFilingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutFilingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutFilingCustomerIdInput[]
    createMany?: LotInfoCreateManyFilingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutFilingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutFilingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutFilingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutFilingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type LotFilingMapperUpdateManyWithoutFilingIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput> | LotFilingMapperCreateWithoutFilingIdInput[] | LotFilingMapperUncheckedCreateWithoutFilingIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingIdInput | LotFilingMapperCreateOrConnectWithoutFilingIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutFilingIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutFilingIdInput[]
    createMany?: LotFilingMapperCreateManyFilingIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutFilingIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutFilingIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutFilingIdInput | LotFilingMapperUpdateManyWithWhereWithoutFilingIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type FilingWastageUncheckedUpdateManyWithoutFilingPersonIdNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput> | FilingWastageCreateWithoutFilingPersonIdInput[] | FilingWastageUncheckedCreateWithoutFilingPersonIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingPersonIdInput | FilingWastageCreateOrConnectWithoutFilingPersonIdInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFilingPersonIdInput | FilingWastageUpsertWithWhereUniqueWithoutFilingPersonIdInput[]
    createMany?: FilingWastageCreateManyFilingPersonIdInputEnvelope
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFilingPersonIdInput | FilingWastageUpdateWithWhereUniqueWithoutFilingPersonIdInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFilingPersonIdInput | FilingWastageUpdateManyWithWhereWithoutFilingPersonIdInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type FilingEntryUncheckedUpdateManyWithoutFiling_personNestedInput = {
    create?: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput> | FilingEntryCreateWithoutFiling_personInput[] | FilingEntryUncheckedCreateWithoutFiling_personInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFiling_personInput | FilingEntryCreateOrConnectWithoutFiling_personInput[]
    upsert?: FilingEntryUpsertWithWhereUniqueWithoutFiling_personInput | FilingEntryUpsertWithWhereUniqueWithoutFiling_personInput[]
    createMany?: FilingEntryCreateManyFiling_personInputEnvelope
    set?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    disconnect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    delete?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    update?: FilingEntryUpdateWithWhereUniqueWithoutFiling_personInput | FilingEntryUpdateWithWhereUniqueWithoutFiling_personInput[]
    updateMany?: FilingEntryUpdateManyWithWhereWithoutFiling_personInput | FilingEntryUpdateManyWithWhereWithoutFiling_personInput[]
    deleteMany?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
  }

  export type LotInfoUncheckedUpdateManyWithoutFilingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput> | LotInfoCreateWithoutFilingCustomerIdInput[] | LotInfoUncheckedCreateWithoutFilingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingCustomerIdInput | LotInfoCreateOrConnectWithoutFilingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutFilingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutFilingCustomerIdInput[]
    createMany?: LotInfoCreateManyFilingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutFilingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutFilingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutFilingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutFilingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutFilingIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput> | LotFilingMapperCreateWithoutFilingIdInput[] | LotFilingMapperUncheckedCreateWithoutFilingIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingIdInput | LotFilingMapperCreateOrConnectWithoutFilingIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutFilingIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutFilingIdInput[]
    createMany?: LotFilingMapperCreateManyFilingIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutFilingIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutFilingIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutFilingIdInput | LotFilingMapperUpdateManyWithWhereWithoutFilingIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type SettingEntryCreateNestedManyWithoutSetting_personInput = {
    create?: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput> | SettingEntryCreateWithoutSetting_personInput[] | SettingEntryUncheckedCreateWithoutSetting_personInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSetting_personInput | SettingEntryCreateOrConnectWithoutSetting_personInput[]
    createMany?: SettingEntryCreateManySetting_personInputEnvelope
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type LotSettingMapperCreateNestedManyWithoutSettingIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput> | LotSettingMapperCreateWithoutSettingIdInput[] | LotSettingMapperUncheckedCreateWithoutSettingIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingIdInput | LotSettingMapperCreateOrConnectWithoutSettingIdInput[]
    createMany?: LotSettingMapperCreateManySettingIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotInfoCreateNestedManyWithoutSettingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput> | LotInfoCreateWithoutSettingCustomerIdInput[] | LotInfoUncheckedCreateWithoutSettingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingCustomerIdInput | LotInfoCreateOrConnectWithoutSettingCustomerIdInput[]
    createMany?: LotInfoCreateManySettingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type SettingEntryUncheckedCreateNestedManyWithoutSetting_personInput = {
    create?: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput> | SettingEntryCreateWithoutSetting_personInput[] | SettingEntryUncheckedCreateWithoutSetting_personInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSetting_personInput | SettingEntryCreateOrConnectWithoutSetting_personInput[]
    createMany?: SettingEntryCreateManySetting_personInputEnvelope
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type LotSettingMapperUncheckedCreateNestedManyWithoutSettingIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput> | LotSettingMapperCreateWithoutSettingIdInput[] | LotSettingMapperUncheckedCreateWithoutSettingIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingIdInput | LotSettingMapperCreateOrConnectWithoutSettingIdInput[]
    createMany?: LotSettingMapperCreateManySettingIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotInfoUncheckedCreateNestedManyWithoutSettingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput> | LotInfoCreateWithoutSettingCustomerIdInput[] | LotInfoUncheckedCreateWithoutSettingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingCustomerIdInput | LotInfoCreateOrConnectWithoutSettingCustomerIdInput[]
    createMany?: LotInfoCreateManySettingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type SettingEntryUpdateManyWithoutSetting_personNestedInput = {
    create?: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput> | SettingEntryCreateWithoutSetting_personInput[] | SettingEntryUncheckedCreateWithoutSetting_personInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSetting_personInput | SettingEntryCreateOrConnectWithoutSetting_personInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutSetting_personInput | SettingEntryUpsertWithWhereUniqueWithoutSetting_personInput[]
    createMany?: SettingEntryCreateManySetting_personInputEnvelope
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutSetting_personInput | SettingEntryUpdateWithWhereUniqueWithoutSetting_personInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutSetting_personInput | SettingEntryUpdateManyWithWhereWithoutSetting_personInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type LotSettingMapperUpdateManyWithoutSettingIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput> | LotSettingMapperCreateWithoutSettingIdInput[] | LotSettingMapperUncheckedCreateWithoutSettingIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingIdInput | LotSettingMapperCreateOrConnectWithoutSettingIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutSettingIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutSettingIdInput[]
    createMany?: LotSettingMapperCreateManySettingIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutSettingIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutSettingIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutSettingIdInput | LotSettingMapperUpdateManyWithWhereWithoutSettingIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotInfoUpdateManyWithoutSettingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput> | LotInfoCreateWithoutSettingCustomerIdInput[] | LotInfoUncheckedCreateWithoutSettingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingCustomerIdInput | LotInfoCreateOrConnectWithoutSettingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutSettingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutSettingCustomerIdInput[]
    createMany?: LotInfoCreateManySettingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutSettingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutSettingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutSettingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutSettingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type SettingEntryUncheckedUpdateManyWithoutSetting_personNestedInput = {
    create?: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput> | SettingEntryCreateWithoutSetting_personInput[] | SettingEntryUncheckedCreateWithoutSetting_personInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSetting_personInput | SettingEntryCreateOrConnectWithoutSetting_personInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutSetting_personInput | SettingEntryUpsertWithWhereUniqueWithoutSetting_personInput[]
    createMany?: SettingEntryCreateManySetting_personInputEnvelope
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutSetting_personInput | SettingEntryUpdateWithWhereUniqueWithoutSetting_personInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutSetting_personInput | SettingEntryUpdateManyWithWhereWithoutSetting_personInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutSettingIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput> | LotSettingMapperCreateWithoutSettingIdInput[] | LotSettingMapperUncheckedCreateWithoutSettingIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingIdInput | LotSettingMapperCreateOrConnectWithoutSettingIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutSettingIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutSettingIdInput[]
    createMany?: LotSettingMapperCreateManySettingIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutSettingIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutSettingIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutSettingIdInput | LotSettingMapperUpdateManyWithWhereWithoutSettingIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotInfoUncheckedUpdateManyWithoutSettingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput> | LotInfoCreateWithoutSettingCustomerIdInput[] | LotInfoUncheckedCreateWithoutSettingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingCustomerIdInput | LotInfoCreateOrConnectWithoutSettingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutSettingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutSettingCustomerIdInput[]
    createMany?: LotInfoCreateManySettingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutSettingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutSettingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutSettingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutSettingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type BuffingEntryCreateNestedManyWithoutBuffing_personInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput> | BuffingEntryCreateWithoutBuffing_personInput[] | BuffingEntryUncheckedCreateWithoutBuffing_personInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffing_personInput | BuffingEntryCreateOrConnectWithoutBuffing_personInput[]
    createMany?: BuffingEntryCreateManyBuffing_personInputEnvelope
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type LotBuffingMapperCreateNestedManyWithoutBuffingIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput> | LotBuffingMapperCreateWithoutBuffingIdInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingIdInput | LotBuffingMapperCreateOrConnectWithoutBuffingIdInput[]
    createMany?: LotBuffingMapperCreateManyBuffingIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type LotInfoCreateNestedManyWithoutBuffingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput> | LotInfoCreateWithoutBuffingCustomerIdInput[] | LotInfoUncheckedCreateWithoutBuffingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingCustomerIdInput | LotInfoCreateOrConnectWithoutBuffingCustomerIdInput[]
    createMany?: LotInfoCreateManyBuffingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type BuffingWastageCreateNestedManyWithoutBuffingPersonIdInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput> | BuffingWastageCreateWithoutBuffingPersonIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput | BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput[]
    createMany?: BuffingWastageCreateManyBuffingPersonIdInputEnvelope
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type BuffingEntryUncheckedCreateNestedManyWithoutBuffing_personInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput> | BuffingEntryCreateWithoutBuffing_personInput[] | BuffingEntryUncheckedCreateWithoutBuffing_personInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffing_personInput | BuffingEntryCreateOrConnectWithoutBuffing_personInput[]
    createMany?: BuffingEntryCreateManyBuffing_personInputEnvelope
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput> | LotBuffingMapperCreateWithoutBuffingIdInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingIdInput | LotBuffingMapperCreateOrConnectWithoutBuffingIdInput[]
    createMany?: LotBuffingMapperCreateManyBuffingIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type LotInfoUncheckedCreateNestedManyWithoutBuffingCustomerIdInput = {
    create?: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput> | LotInfoCreateWithoutBuffingCustomerIdInput[] | LotInfoUncheckedCreateWithoutBuffingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingCustomerIdInput | LotInfoCreateOrConnectWithoutBuffingCustomerIdInput[]
    createMany?: LotInfoCreateManyBuffingCustomerIdInputEnvelope
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
  }

  export type BuffingWastageUncheckedCreateNestedManyWithoutBuffingPersonIdInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput> | BuffingWastageCreateWithoutBuffingPersonIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput | BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput[]
    createMany?: BuffingWastageCreateManyBuffingPersonIdInputEnvelope
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type BuffingEntryUpdateManyWithoutBuffing_personNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput> | BuffingEntryCreateWithoutBuffing_personInput[] | BuffingEntryUncheckedCreateWithoutBuffing_personInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffing_personInput | BuffingEntryCreateOrConnectWithoutBuffing_personInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutBuffing_personInput | BuffingEntryUpsertWithWhereUniqueWithoutBuffing_personInput[]
    createMany?: BuffingEntryCreateManyBuffing_personInputEnvelope
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutBuffing_personInput | BuffingEntryUpdateWithWhereUniqueWithoutBuffing_personInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutBuffing_personInput | BuffingEntryUpdateManyWithWhereWithoutBuffing_personInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type LotBuffingMapperUpdateManyWithoutBuffingIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput> | LotBuffingMapperCreateWithoutBuffingIdInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingIdInput | LotBuffingMapperCreateOrConnectWithoutBuffingIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingIdInput[]
    createMany?: LotBuffingMapperCreateManyBuffingIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutBuffingIdInput | LotBuffingMapperUpdateManyWithWhereWithoutBuffingIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type LotInfoUpdateManyWithoutBuffingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput> | LotInfoCreateWithoutBuffingCustomerIdInput[] | LotInfoUncheckedCreateWithoutBuffingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingCustomerIdInput | LotInfoCreateOrConnectWithoutBuffingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutBuffingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutBuffingCustomerIdInput[]
    createMany?: LotInfoCreateManyBuffingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutBuffingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutBuffingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutBuffingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutBuffingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type BuffingWastageUpdateManyWithoutBuffingPersonIdNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput> | BuffingWastageCreateWithoutBuffingPersonIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput | BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffingPersonIdInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffingPersonIdInput[]
    createMany?: BuffingWastageCreateManyBuffingPersonIdInputEnvelope
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffingPersonIdInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffingPersonIdInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffingPersonIdInput | BuffingWastageUpdateManyWithWhereWithoutBuffingPersonIdInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type BuffingEntryUncheckedUpdateManyWithoutBuffing_personNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput> | BuffingEntryCreateWithoutBuffing_personInput[] | BuffingEntryUncheckedCreateWithoutBuffing_personInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffing_personInput | BuffingEntryCreateOrConnectWithoutBuffing_personInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutBuffing_personInput | BuffingEntryUpsertWithWhereUniqueWithoutBuffing_personInput[]
    createMany?: BuffingEntryCreateManyBuffing_personInputEnvelope
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutBuffing_personInput | BuffingEntryUpdateWithWhereUniqueWithoutBuffing_personInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutBuffing_personInput | BuffingEntryUpdateManyWithWhereWithoutBuffing_personInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput> | LotBuffingMapperCreateWithoutBuffingIdInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingIdInput | LotBuffingMapperCreateOrConnectWithoutBuffingIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingIdInput[]
    createMany?: LotBuffingMapperCreateManyBuffingIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutBuffingIdInput | LotBuffingMapperUpdateManyWithWhereWithoutBuffingIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdNestedInput = {
    create?: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput> | LotInfoCreateWithoutBuffingCustomerIdInput[] | LotInfoUncheckedCreateWithoutBuffingCustomerIdInput[]
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingCustomerIdInput | LotInfoCreateOrConnectWithoutBuffingCustomerIdInput[]
    upsert?: LotInfoUpsertWithWhereUniqueWithoutBuffingCustomerIdInput | LotInfoUpsertWithWhereUniqueWithoutBuffingCustomerIdInput[]
    createMany?: LotInfoCreateManyBuffingCustomerIdInputEnvelope
    set?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    disconnect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    delete?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    connect?: LotInfoWhereUniqueInput | LotInfoWhereUniqueInput[]
    update?: LotInfoUpdateWithWhereUniqueWithoutBuffingCustomerIdInput | LotInfoUpdateWithWhereUniqueWithoutBuffingCustomerIdInput[]
    updateMany?: LotInfoUpdateManyWithWhereWithoutBuffingCustomerIdInput | LotInfoUpdateManyWithWhereWithoutBuffingCustomerIdInput[]
    deleteMany?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput> | BuffingWastageCreateWithoutBuffingPersonIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput | BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffingPersonIdInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffingPersonIdInput[]
    createMany?: BuffingWastageCreateManyBuffingPersonIdInputEnvelope
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffingPersonIdInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffingPersonIdInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffingPersonIdInput | BuffingWastageUpdateManyWithWhereWithoutBuffingPersonIdInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type EnumITEMTYPEFieldUpdateOperationsInput = {
    set?: $Enums.ITEMTYPE
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddCustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AddCustomerCreateWithoutTransactionsInput, AddCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AddCustomerCreateOrConnectWithoutTransactionsInput
    connect?: AddCustomerWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddCustomerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AddCustomerCreateWithoutTransactionsInput, AddCustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AddCustomerCreateOrConnectWithoutTransactionsInput
    upsert?: AddCustomerUpsertWithoutTransactionsInput
    connect?: AddCustomerWhereUniqueInput
    update?: XOR<XOR<AddCustomerUpdateToOneWithWhereWithoutTransactionsInput, AddCustomerUpdateWithoutTransactionsInput>, AddCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CastingItemsCreateNestedManyWithoutItemInput = {
    create?: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput> | CastingItemsCreateWithoutItemInput[] | CastingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutItemInput | CastingItemsCreateOrConnectWithoutItemInput[]
    createMany?: CastingItemsCreateManyItemInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutItemInput = {
    create?: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput> | StockCreateWithoutItemInput[] | StockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutItemInput | StockCreateOrConnectWithoutItemInput[]
    createMany?: StockCreateManyItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type FilingItemsCreateNestedManyWithoutFilingitemInput = {
    create?: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput> | FilingItemsCreateWithoutFilingitemInput[] | FilingItemsUncheckedCreateWithoutFilingitemInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFilingitemInput | FilingItemsCreateOrConnectWithoutFilingitemInput[]
    createMany?: FilingItemsCreateManyFilingitemInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsCreateNestedManyWithoutItemInput = {
    create?: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput> | SettingItemsCreateWithoutItemInput[] | SettingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutItemInput | SettingItemsCreateOrConnectWithoutItemInput[]
    createMany?: SettingItemsCreateManyItemInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingItemsCreateNestedManyWithoutItemInput = {
    create?: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput> | BuffingItemsCreateWithoutItemInput[] | BuffingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutItemInput | BuffingItemsCreateOrConnectWithoutItemInput[]
    createMany?: BuffingItemsCreateManyItemInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type CastingItemsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput> | CastingItemsCreateWithoutItemInput[] | CastingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutItemInput | CastingItemsCreateOrConnectWithoutItemInput[]
    createMany?: CastingItemsCreateManyItemInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput> | StockCreateWithoutItemInput[] | StockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutItemInput | StockCreateOrConnectWithoutItemInput[]
    createMany?: StockCreateManyItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput = {
    create?: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput> | FilingItemsCreateWithoutFilingitemInput[] | FilingItemsUncheckedCreateWithoutFilingitemInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFilingitemInput | FilingItemsCreateOrConnectWithoutFilingitemInput[]
    createMany?: FilingItemsCreateManyFilingitemInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput> | SettingItemsCreateWithoutItemInput[] | SettingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutItemInput | SettingItemsCreateOrConnectWithoutItemInput[]
    createMany?: SettingItemsCreateManyItemInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingItemsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput> | BuffingItemsCreateWithoutItemInput[] | BuffingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutItemInput | BuffingItemsCreateOrConnectWithoutItemInput[]
    createMany?: BuffingItemsCreateManyItemInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type CastingItemsUpdateManyWithoutItemNestedInput = {
    create?: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput> | CastingItemsCreateWithoutItemInput[] | CastingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutItemInput | CastingItemsCreateOrConnectWithoutItemInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutItemInput | CastingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CastingItemsCreateManyItemInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutItemInput | CastingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutItemInput | CastingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type StockUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput> | StockCreateWithoutItemInput[] | StockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutItemInput | StockCreateOrConnectWithoutItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutItemInput | StockUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockCreateManyItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutItemInput | StockUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutItemInput | StockUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type FilingItemsUpdateManyWithoutFilingitemNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput> | FilingItemsCreateWithoutFilingitemInput[] | FilingItemsUncheckedCreateWithoutFilingitemInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFilingitemInput | FilingItemsCreateOrConnectWithoutFilingitemInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFilingitemInput | FilingItemsUpsertWithWhereUniqueWithoutFilingitemInput[]
    createMany?: FilingItemsCreateManyFilingitemInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFilingitemInput | FilingItemsUpdateWithWhereUniqueWithoutFilingitemInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFilingitemInput | FilingItemsUpdateManyWithWhereWithoutFilingitemInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUpdateManyWithoutItemNestedInput = {
    create?: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput> | SettingItemsCreateWithoutItemInput[] | SettingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutItemInput | SettingItemsCreateOrConnectWithoutItemInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutItemInput | SettingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SettingItemsCreateManyItemInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutItemInput | SettingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutItemInput | SettingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingItemsUpdateManyWithoutItemNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput> | BuffingItemsCreateWithoutItemInput[] | BuffingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutItemInput | BuffingItemsCreateOrConnectWithoutItemInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutItemInput | BuffingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BuffingItemsCreateManyItemInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutItemInput | BuffingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutItemInput | BuffingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type CastingItemsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput> | CastingItemsCreateWithoutItemInput[] | CastingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutItemInput | CastingItemsCreateOrConnectWithoutItemInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutItemInput | CastingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CastingItemsCreateManyItemInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutItemInput | CastingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutItemInput | CastingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput> | StockCreateWithoutItemInput[] | StockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutItemInput | StockCreateOrConnectWithoutItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutItemInput | StockUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockCreateManyItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutItemInput | StockUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutItemInput | StockUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput> | FilingItemsCreateWithoutFilingitemInput[] | FilingItemsUncheckedCreateWithoutFilingitemInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFilingitemInput | FilingItemsCreateOrConnectWithoutFilingitemInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFilingitemInput | FilingItemsUpsertWithWhereUniqueWithoutFilingitemInput[]
    createMany?: FilingItemsCreateManyFilingitemInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFilingitemInput | FilingItemsUpdateWithWhereUniqueWithoutFilingitemInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFilingitemInput | FilingItemsUpdateManyWithWhereWithoutFilingitemInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput> | SettingItemsCreateWithoutItemInput[] | SettingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutItemInput | SettingItemsCreateOrConnectWithoutItemInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutItemInput | SettingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SettingItemsCreateManyItemInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutItemInput | SettingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutItemInput | SettingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingItemsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput> | BuffingItemsCreateWithoutItemInput[] | BuffingItemsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutItemInput | BuffingItemsCreateOrConnectWithoutItemInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutItemInput | BuffingItemsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BuffingItemsCreateManyItemInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutItemInput | BuffingItemsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutItemInput | BuffingItemsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type CastingEntryCreateNestedManyWithoutTouchInput = {
    create?: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput> | CastingEntryCreateWithoutTouchInput[] | CastingEntryUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutTouchInput | CastingEntryCreateOrConnectWithoutTouchInput[]
    createMany?: CastingEntryCreateManyTouchInputEnvelope
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
  }

  export type CastingItemsCreateNestedManyWithoutTouchInput = {
    create?: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput> | CastingItemsCreateWithoutTouchInput[] | CastingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutTouchInput | CastingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: CastingItemsCreateManyTouchInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type FilingItemsCreateNestedManyWithoutTouchInput = {
    create?: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput> | FilingItemsCreateWithoutTouchInput[] | FilingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutTouchInput | FilingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: FilingItemsCreateManyTouchInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsCreateNestedManyWithoutTouchInput = {
    create?: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput> | SettingItemsCreateWithoutTouchInput[] | SettingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutTouchInput | SettingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: SettingItemsCreateManyTouchInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingItemsCreateNestedManyWithoutTouchInput = {
    create?: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput> | BuffingItemsCreateWithoutTouchInput[] | BuffingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutTouchInput | BuffingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: BuffingItemsCreateManyTouchInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutTouchInput = {
    create?: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput> | StockCreateWithoutTouchInput[] | StockUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTouchInput | StockCreateOrConnectWithoutTouchInput[]
    createMany?: StockCreateManyTouchInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type CastingEntryUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput> | CastingEntryCreateWithoutTouchInput[] | CastingEntryUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutTouchInput | CastingEntryCreateOrConnectWithoutTouchInput[]
    createMany?: CastingEntryCreateManyTouchInputEnvelope
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
  }

  export type CastingItemsUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput> | CastingItemsCreateWithoutTouchInput[] | CastingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutTouchInput | CastingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: CastingItemsCreateManyTouchInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput> | FilingItemsCreateWithoutTouchInput[] | FilingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutTouchInput | FilingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: FilingItemsCreateManyTouchInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput> | SettingItemsCreateWithoutTouchInput[] | SettingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutTouchInput | SettingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: SettingItemsCreateManyTouchInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingItemsUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput> | BuffingItemsCreateWithoutTouchInput[] | BuffingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutTouchInput | BuffingItemsCreateOrConnectWithoutTouchInput[]
    createMany?: BuffingItemsCreateManyTouchInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutTouchInput = {
    create?: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput> | StockCreateWithoutTouchInput[] | StockUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTouchInput | StockCreateOrConnectWithoutTouchInput[]
    createMany?: StockCreateManyTouchInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type CastingEntryUpdateManyWithoutTouchNestedInput = {
    create?: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput> | CastingEntryCreateWithoutTouchInput[] | CastingEntryUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutTouchInput | CastingEntryCreateOrConnectWithoutTouchInput[]
    upsert?: CastingEntryUpsertWithWhereUniqueWithoutTouchInput | CastingEntryUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: CastingEntryCreateManyTouchInputEnvelope
    set?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    disconnect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    delete?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    update?: CastingEntryUpdateWithWhereUniqueWithoutTouchInput | CastingEntryUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: CastingEntryUpdateManyWithWhereWithoutTouchInput | CastingEntryUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
  }

  export type CastingItemsUpdateManyWithoutTouchNestedInput = {
    create?: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput> | CastingItemsCreateWithoutTouchInput[] | CastingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutTouchInput | CastingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutTouchInput | CastingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: CastingItemsCreateManyTouchInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutTouchInput | CastingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutTouchInput | CastingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type FilingItemsUpdateManyWithoutTouchNestedInput = {
    create?: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput> | FilingItemsCreateWithoutTouchInput[] | FilingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutTouchInput | FilingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutTouchInput | FilingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: FilingItemsCreateManyTouchInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutTouchInput | FilingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutTouchInput | FilingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUpdateManyWithoutTouchNestedInput = {
    create?: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput> | SettingItemsCreateWithoutTouchInput[] | SettingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutTouchInput | SettingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutTouchInput | SettingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: SettingItemsCreateManyTouchInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutTouchInput | SettingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutTouchInput | SettingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingItemsUpdateManyWithoutTouchNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput> | BuffingItemsCreateWithoutTouchInput[] | BuffingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutTouchInput | BuffingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutTouchInput | BuffingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: BuffingItemsCreateManyTouchInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutTouchInput | BuffingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutTouchInput | BuffingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type StockUpdateManyWithoutTouchNestedInput = {
    create?: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput> | StockCreateWithoutTouchInput[] | StockUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTouchInput | StockCreateOrConnectWithoutTouchInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutTouchInput | StockUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: StockCreateManyTouchInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutTouchInput | StockUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: StockUpdateManyWithWhereWithoutTouchInput | StockUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type CastingEntryUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput> | CastingEntryCreateWithoutTouchInput[] | CastingEntryUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingEntryCreateOrConnectWithoutTouchInput | CastingEntryCreateOrConnectWithoutTouchInput[]
    upsert?: CastingEntryUpsertWithWhereUniqueWithoutTouchInput | CastingEntryUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: CastingEntryCreateManyTouchInputEnvelope
    set?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    disconnect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    delete?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    connect?: CastingEntryWhereUniqueInput | CastingEntryWhereUniqueInput[]
    update?: CastingEntryUpdateWithWhereUniqueWithoutTouchInput | CastingEntryUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: CastingEntryUpdateManyWithWhereWithoutTouchInput | CastingEntryUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
  }

  export type CastingItemsUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput> | CastingItemsCreateWithoutTouchInput[] | CastingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutTouchInput | CastingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutTouchInput | CastingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: CastingItemsCreateManyTouchInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutTouchInput | CastingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutTouchInput | CastingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput> | FilingItemsCreateWithoutTouchInput[] | FilingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutTouchInput | FilingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutTouchInput | FilingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: FilingItemsCreateManyTouchInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutTouchInput | FilingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutTouchInput | FilingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput> | SettingItemsCreateWithoutTouchInput[] | SettingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutTouchInput | SettingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutTouchInput | SettingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: SettingItemsCreateManyTouchInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutTouchInput | SettingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutTouchInput | SettingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput> | BuffingItemsCreateWithoutTouchInput[] | BuffingItemsUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutTouchInput | BuffingItemsCreateOrConnectWithoutTouchInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutTouchInput | BuffingItemsUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: BuffingItemsCreateManyTouchInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutTouchInput | BuffingItemsUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutTouchInput | BuffingItemsUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutTouchNestedInput = {
    create?: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput> | StockCreateWithoutTouchInput[] | StockUncheckedCreateWithoutTouchInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTouchInput | StockCreateOrConnectWithoutTouchInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutTouchInput | StockUpsertWithWhereUniqueWithoutTouchInput[]
    createMany?: StockCreateManyTouchInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutTouchInput | StockUpdateWithWhereUniqueWithoutTouchInput[]
    updateMany?: StockUpdateManyWithWhereWithoutTouchInput | StockUpdateManyWithWhereWithoutTouchInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type AddTouchCreateNestedOneWithoutCasting_entryInput = {
    create?: XOR<AddTouchCreateWithoutCasting_entryInput, AddTouchUncheckedCreateWithoutCasting_entryInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutCasting_entryInput
    connect?: AddTouchWhereUniqueInput
  }

  export type AddCastingCreateNestedOneWithoutEntriesInput = {
    create?: XOR<AddCastingCreateWithoutEntriesInput, AddCastingUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutEntriesInput
    connect?: AddCastingWhereUniqueInput
  }

  export type CastingItemsCreateNestedManyWithoutCastingEntryInput = {
    create?: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput> | CastingItemsCreateWithoutCastingEntryInput[] | CastingItemsUncheckedCreateWithoutCastingEntryInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCastingEntryInput | CastingItemsCreateOrConnectWithoutCastingEntryInput[]
    createMany?: CastingItemsCreateManyCastingEntryInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type CastiingTotalBalanceCreateNestedManyWithoutItem_entry_idInput = {
    create?: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput> | CastiingTotalBalanceCreateWithoutItem_entry_idInput[] | CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput[]
    connectOrCreate?: CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput | CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput[]
    createMany?: CastiingTotalBalanceCreateManyItem_entry_idInputEnvelope
    connect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
  }

  export type CastingItemsUncheckedCreateNestedManyWithoutCastingEntryInput = {
    create?: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput> | CastingItemsCreateWithoutCastingEntryInput[] | CastingItemsUncheckedCreateWithoutCastingEntryInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCastingEntryInput | CastingItemsCreateOrConnectWithoutCastingEntryInput[]
    createMany?: CastingItemsCreateManyCastingEntryInputEnvelope
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
  }

  export type CastiingTotalBalanceUncheckedCreateNestedManyWithoutItem_entry_idInput = {
    create?: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput> | CastiingTotalBalanceCreateWithoutItem_entry_idInput[] | CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput[]
    connectOrCreate?: CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput | CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput[]
    createMany?: CastiingTotalBalanceCreateManyItem_entry_idInputEnvelope
    connect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
  }

  export type AddTouchUpdateOneRequiredWithoutCasting_entryNestedInput = {
    create?: XOR<AddTouchCreateWithoutCasting_entryInput, AddTouchUncheckedCreateWithoutCasting_entryInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutCasting_entryInput
    upsert?: AddTouchUpsertWithoutCasting_entryInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutCasting_entryInput, AddTouchUpdateWithoutCasting_entryInput>, AddTouchUncheckedUpdateWithoutCasting_entryInput>
  }

  export type AddCastingUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<AddCastingCreateWithoutEntriesInput, AddCastingUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutEntriesInput
    upsert?: AddCastingUpsertWithoutEntriesInput
    connect?: AddCastingWhereUniqueInput
    update?: XOR<XOR<AddCastingUpdateToOneWithWhereWithoutEntriesInput, AddCastingUpdateWithoutEntriesInput>, AddCastingUncheckedUpdateWithoutEntriesInput>
  }

  export type CastingItemsUpdateManyWithoutCastingEntryNestedInput = {
    create?: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput> | CastingItemsCreateWithoutCastingEntryInput[] | CastingItemsUncheckedCreateWithoutCastingEntryInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCastingEntryInput | CastingItemsCreateOrConnectWithoutCastingEntryInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutCastingEntryInput | CastingItemsUpsertWithWhereUniqueWithoutCastingEntryInput[]
    createMany?: CastingItemsCreateManyCastingEntryInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutCastingEntryInput | CastingItemsUpdateWithWhereUniqueWithoutCastingEntryInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutCastingEntryInput | CastingItemsUpdateManyWithWhereWithoutCastingEntryInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type CastiingTotalBalanceUpdateManyWithoutItem_entry_idNestedInput = {
    create?: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput> | CastiingTotalBalanceCreateWithoutItem_entry_idInput[] | CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput[]
    connectOrCreate?: CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput | CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput[]
    upsert?: CastiingTotalBalanceUpsertWithWhereUniqueWithoutItem_entry_idInput | CastiingTotalBalanceUpsertWithWhereUniqueWithoutItem_entry_idInput[]
    createMany?: CastiingTotalBalanceCreateManyItem_entry_idInputEnvelope
    set?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    disconnect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    delete?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    connect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    update?: CastiingTotalBalanceUpdateWithWhereUniqueWithoutItem_entry_idInput | CastiingTotalBalanceUpdateWithWhereUniqueWithoutItem_entry_idInput[]
    updateMany?: CastiingTotalBalanceUpdateManyWithWhereWithoutItem_entry_idInput | CastiingTotalBalanceUpdateManyWithWhereWithoutItem_entry_idInput[]
    deleteMany?: CastiingTotalBalanceScalarWhereInput | CastiingTotalBalanceScalarWhereInput[]
  }

  export type CastingItemsUncheckedUpdateManyWithoutCastingEntryNestedInput = {
    create?: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput> | CastingItemsCreateWithoutCastingEntryInput[] | CastingItemsUncheckedCreateWithoutCastingEntryInput[]
    connectOrCreate?: CastingItemsCreateOrConnectWithoutCastingEntryInput | CastingItemsCreateOrConnectWithoutCastingEntryInput[]
    upsert?: CastingItemsUpsertWithWhereUniqueWithoutCastingEntryInput | CastingItemsUpsertWithWhereUniqueWithoutCastingEntryInput[]
    createMany?: CastingItemsCreateManyCastingEntryInputEnvelope
    set?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    disconnect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    delete?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    connect?: CastingItemsWhereUniqueInput | CastingItemsWhereUniqueInput[]
    update?: CastingItemsUpdateWithWhereUniqueWithoutCastingEntryInput | CastingItemsUpdateWithWhereUniqueWithoutCastingEntryInput[]
    updateMany?: CastingItemsUpdateManyWithWhereWithoutCastingEntryInput | CastingItemsUpdateManyWithWhereWithoutCastingEntryInput[]
    deleteMany?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
  }

  export type CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idNestedInput = {
    create?: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput> | CastiingTotalBalanceCreateWithoutItem_entry_idInput[] | CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput[]
    connectOrCreate?: CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput | CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput[]
    upsert?: CastiingTotalBalanceUpsertWithWhereUniqueWithoutItem_entry_idInput | CastiingTotalBalanceUpsertWithWhereUniqueWithoutItem_entry_idInput[]
    createMany?: CastiingTotalBalanceCreateManyItem_entry_idInputEnvelope
    set?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    disconnect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    delete?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    connect?: CastiingTotalBalanceWhereUniqueInput | CastiingTotalBalanceWhereUniqueInput[]
    update?: CastiingTotalBalanceUpdateWithWhereUniqueWithoutItem_entry_idInput | CastiingTotalBalanceUpdateWithWhereUniqueWithoutItem_entry_idInput[]
    updateMany?: CastiingTotalBalanceUpdateManyWithWhereWithoutItem_entry_idInput | CastiingTotalBalanceUpdateManyWithWhereWithoutItem_entry_idInput[]
    deleteMany?: CastiingTotalBalanceScalarWhereInput | CastiingTotalBalanceScalarWhereInput[]
  }

  export type AddTouchCreateNestedOneWithoutCasting_itemsInput = {
    create?: XOR<AddTouchCreateWithoutCasting_itemsInput, AddTouchUncheckedCreateWithoutCasting_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutCasting_itemsInput
    connect?: AddTouchWhereUniqueInput
  }

  export type AddItemCreateNestedOneWithoutCasting_itemsInput = {
    create?: XOR<AddItemCreateWithoutCasting_itemsInput, AddItemUncheckedCreateWithoutCasting_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutCasting_itemsInput
    connect?: AddItemWhereUniqueInput
  }

  export type CastingEntryCreateNestedOneWithoutItemsInput = {
    create?: XOR<CastingEntryCreateWithoutItemsInput, CastingEntryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CastingEntryCreateOrConnectWithoutItemsInput
    connect?: CastingEntryWhereUniqueInput
  }

  export type FilingEntryCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput> | FilingEntryCreateWithoutCastingItemInput[] | FilingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutCastingItemInput | FilingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: FilingEntryCreateManyCastingItemInputEnvelope
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
  }

  export type SettingEntryCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput> | SettingEntryCreateWithoutCastingItemInput[] | SettingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutCastingItemInput | SettingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: SettingEntryCreateManyCastingItemInputEnvelope
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type BuffingEntryCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput> | BuffingEntryCreateWithoutCastingItemInput[] | BuffingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutCastingItemInput | BuffingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: BuffingEntryCreateManyCastingItemInputEnvelope
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput> | StockCreateWithoutCastingItemInput[] | StockUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCastingItemInput | StockCreateOrConnectWithoutCastingItemInput[]
    createMany?: StockCreateManyCastingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type LotFilingMapperCreateNestedManyWithoutItemIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput> | LotFilingMapperCreateWithoutItemIdInput[] | LotFilingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutItemIdInput | LotFilingMapperCreateOrConnectWithoutItemIdInput[]
    createMany?: LotFilingMapperCreateManyItemIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type AddCastingCreateNestedOneWithoutCastingitemsInput = {
    create?: XOR<AddCastingCreateWithoutCastingitemsInput, AddCastingUncheckedCreateWithoutCastingitemsInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutCastingitemsInput
    connect?: AddCastingWhereUniqueInput
  }

  export type FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput> | FilingEntryCreateWithoutCastingItemInput[] | FilingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutCastingItemInput | FilingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: FilingEntryCreateManyCastingItemInputEnvelope
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
  }

  export type SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput> | SettingEntryCreateWithoutCastingItemInput[] | SettingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutCastingItemInput | SettingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: SettingEntryCreateManyCastingItemInputEnvelope
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput> | BuffingEntryCreateWithoutCastingItemInput[] | BuffingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutCastingItemInput | BuffingEntryCreateOrConnectWithoutCastingItemInput[]
    createMany?: BuffingEntryCreateManyCastingItemInputEnvelope
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutCastingItemInput = {
    create?: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput> | StockCreateWithoutCastingItemInput[] | StockUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCastingItemInput | StockCreateOrConnectWithoutCastingItemInput[]
    createMany?: StockCreateManyCastingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput> | LotFilingMapperCreateWithoutItemIdInput[] | LotFilingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutItemIdInput | LotFilingMapperCreateOrConnectWithoutItemIdInput[]
    createMany?: LotFilingMapperCreateManyItemIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type EnumCASTINGENTRYTYPEFieldUpdateOperationsInput = {
    set?: $Enums.CASTINGENTRYTYPE
  }

  export type AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput = {
    create?: XOR<AddTouchCreateWithoutCasting_itemsInput, AddTouchUncheckedCreateWithoutCasting_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutCasting_itemsInput
    upsert?: AddTouchUpsertWithoutCasting_itemsInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutCasting_itemsInput, AddTouchUpdateWithoutCasting_itemsInput>, AddTouchUncheckedUpdateWithoutCasting_itemsInput>
  }

  export type AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput = {
    create?: XOR<AddItemCreateWithoutCasting_itemsInput, AddItemUncheckedCreateWithoutCasting_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutCasting_itemsInput
    upsert?: AddItemUpsertWithoutCasting_itemsInput
    connect?: AddItemWhereUniqueInput
    update?: XOR<XOR<AddItemUpdateToOneWithWhereWithoutCasting_itemsInput, AddItemUpdateWithoutCasting_itemsInput>, AddItemUncheckedUpdateWithoutCasting_itemsInput>
  }

  export type CastingEntryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CastingEntryCreateWithoutItemsInput, CastingEntryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CastingEntryCreateOrConnectWithoutItemsInput
    upsert?: CastingEntryUpsertWithoutItemsInput
    connect?: CastingEntryWhereUniqueInput
    update?: XOR<XOR<CastingEntryUpdateToOneWithWhereWithoutItemsInput, CastingEntryUpdateWithoutItemsInput>, CastingEntryUncheckedUpdateWithoutItemsInput>
  }

  export type FilingEntryUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput> | FilingEntryCreateWithoutCastingItemInput[] | FilingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutCastingItemInput | FilingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: FilingEntryUpsertWithWhereUniqueWithoutCastingItemInput | FilingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: FilingEntryCreateManyCastingItemInputEnvelope
    set?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    disconnect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    delete?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    update?: FilingEntryUpdateWithWhereUniqueWithoutCastingItemInput | FilingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: FilingEntryUpdateManyWithWhereWithoutCastingItemInput | FilingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
  }

  export type SettingEntryUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput> | SettingEntryCreateWithoutCastingItemInput[] | SettingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutCastingItemInput | SettingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutCastingItemInput | SettingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: SettingEntryCreateManyCastingItemInputEnvelope
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutCastingItemInput | SettingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutCastingItemInput | SettingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type BuffingEntryUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput> | BuffingEntryCreateWithoutCastingItemInput[] | BuffingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutCastingItemInput | BuffingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutCastingItemInput | BuffingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: BuffingEntryCreateManyCastingItemInputEnvelope
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutCastingItemInput | BuffingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutCastingItemInput | BuffingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type StockUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput> | StockCreateWithoutCastingItemInput[] | StockUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCastingItemInput | StockCreateOrConnectWithoutCastingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCastingItemInput | StockUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: StockCreateManyCastingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCastingItemInput | StockUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCastingItemInput | StockUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type LotFilingMapperUpdateManyWithoutItemIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput> | LotFilingMapperCreateWithoutItemIdInput[] | LotFilingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutItemIdInput | LotFilingMapperCreateOrConnectWithoutItemIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutItemIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutItemIdInput[]
    createMany?: LotFilingMapperCreateManyItemIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutItemIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutItemIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutItemIdInput | LotFilingMapperUpdateManyWithWhereWithoutItemIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput = {
    create?: XOR<AddCastingCreateWithoutCastingitemsInput, AddCastingUncheckedCreateWithoutCastingitemsInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutCastingitemsInput
    upsert?: AddCastingUpsertWithoutCastingitemsInput
    connect?: AddCastingWhereUniqueInput
    update?: XOR<XOR<AddCastingUpdateToOneWithWhereWithoutCastingitemsInput, AddCastingUpdateWithoutCastingitemsInput>, AddCastingUncheckedUpdateWithoutCastingitemsInput>
  }

  export type FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput> | FilingEntryCreateWithoutCastingItemInput[] | FilingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: FilingEntryCreateOrConnectWithoutCastingItemInput | FilingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: FilingEntryUpsertWithWhereUniqueWithoutCastingItemInput | FilingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: FilingEntryCreateManyCastingItemInputEnvelope
    set?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    disconnect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    delete?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    connect?: FilingEntryWhereUniqueInput | FilingEntryWhereUniqueInput[]
    update?: FilingEntryUpdateWithWhereUniqueWithoutCastingItemInput | FilingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: FilingEntryUpdateManyWithWhereWithoutCastingItemInput | FilingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
  }

  export type SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput> | SettingEntryCreateWithoutCastingItemInput[] | SettingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutCastingItemInput | SettingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutCastingItemInput | SettingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: SettingEntryCreateManyCastingItemInputEnvelope
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutCastingItemInput | SettingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutCastingItemInput | SettingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput> | BuffingEntryCreateWithoutCastingItemInput[] | BuffingEntryUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutCastingItemInput | BuffingEntryCreateOrConnectWithoutCastingItemInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutCastingItemInput | BuffingEntryUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: BuffingEntryCreateManyCastingItemInputEnvelope
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutCastingItemInput | BuffingEntryUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutCastingItemInput | BuffingEntryUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutCastingItemNestedInput = {
    create?: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput> | StockCreateWithoutCastingItemInput[] | StockUncheckedCreateWithoutCastingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutCastingItemInput | StockCreateOrConnectWithoutCastingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutCastingItemInput | StockUpsertWithWhereUniqueWithoutCastingItemInput[]
    createMany?: StockCreateManyCastingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutCastingItemInput | StockUpdateWithWhereUniqueWithoutCastingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutCastingItemInput | StockUpdateManyWithWhereWithoutCastingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput> | LotFilingMapperCreateWithoutItemIdInput[] | LotFilingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutItemIdInput | LotFilingMapperCreateOrConnectWithoutItemIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutItemIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutItemIdInput[]
    createMany?: LotFilingMapperCreateManyItemIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutItemIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutItemIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutItemIdInput | LotFilingMapperUpdateManyWithWhereWithoutItemIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type CastingEntryCreateNestedOneWithoutCastiingTotalBalanceInput = {
    create?: XOR<CastingEntryCreateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedCreateWithoutCastiingTotalBalanceInput>
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCastiingTotalBalanceInput
    connect?: CastingEntryWhereUniqueInput
  }

  export type CastingEntryUpdateOneRequiredWithoutCastiingTotalBalanceNestedInput = {
    create?: XOR<CastingEntryCreateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedCreateWithoutCastiingTotalBalanceInput>
    connectOrCreate?: CastingEntryCreateOrConnectWithoutCastiingTotalBalanceInput
    upsert?: CastingEntryUpsertWithoutCastiingTotalBalanceInput
    connect?: CastingEntryWhereUniqueInput
    update?: XOR<XOR<CastingEntryUpdateToOneWithWhereWithoutCastiingTotalBalanceInput, CastingEntryUpdateWithoutCastiingTotalBalanceInput>, CastingEntryUncheckedUpdateWithoutCastiingTotalBalanceInput>
  }

  export type AddFilingCreateNestedOneWithoutLotInfoInput = {
    create?: XOR<AddFilingCreateWithoutLotInfoInput, AddFilingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutLotInfoInput
    connect?: AddFilingWhereUniqueInput
  }

  export type AddSettingCreateNestedOneWithoutLotInfoInput = {
    create?: XOR<AddSettingCreateWithoutLotInfoInput, AddSettingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutLotInfoInput
    connect?: AddSettingWhereUniqueInput
  }

  export type AddBuffingCreateNestedOneWithoutLotInfoInput = {
    create?: XOR<AddBuffingCreateWithoutLotInfoInput, AddBuffingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutLotInfoInput
    connect?: AddBuffingWhereUniqueInput
  }

  export type LotFilingMapperCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput> | LotFilingMapperCreateWithoutLotIdInput[] | LotFilingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutLotIdInput | LotFilingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotFilingMapperCreateManyLotIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type LotSettingMapperCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput> | LotSettingMapperCreateWithoutLotIdInput[] | LotSettingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutLotIdInput | LotSettingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotSettingMapperCreateManyLotIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotBuffingMapperCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput> | LotBuffingMapperCreateWithoutLotIdInput[] | LotBuffingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutLotIdInput | LotBuffingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotBuffingMapperCreateManyLotIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type FilingWastageCreateNestedManyWithoutFilingLotIdInput = {
    create?: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput> | FilingWastageCreateWithoutFilingLotIdInput[] | FilingWastageUncheckedCreateWithoutFilingLotIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingLotIdInput | FilingWastageCreateOrConnectWithoutFilingLotIdInput[]
    createMany?: FilingWastageCreateManyFilingLotIdInputEnvelope
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type BuffingWastageCreateNestedManyWithoutBuffingLotIdInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput> | BuffingWastageCreateWithoutBuffingLotIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingLotIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingLotIdInput | BuffingWastageCreateOrConnectWithoutBuffingLotIdInput[]
    createMany?: BuffingWastageCreateManyBuffingLotIdInputEnvelope
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput> | LotFilingMapperCreateWithoutLotIdInput[] | LotFilingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutLotIdInput | LotFilingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotFilingMapperCreateManyLotIdInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput> | LotSettingMapperCreateWithoutLotIdInput[] | LotSettingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutLotIdInput | LotSettingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotSettingMapperCreateManyLotIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput> | LotBuffingMapperCreateWithoutLotIdInput[] | LotBuffingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutLotIdInput | LotBuffingMapperCreateOrConnectWithoutLotIdInput[]
    createMany?: LotBuffingMapperCreateManyLotIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput = {
    create?: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput> | FilingWastageCreateWithoutFilingLotIdInput[] | FilingWastageUncheckedCreateWithoutFilingLotIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingLotIdInput | FilingWastageCreateOrConnectWithoutFilingLotIdInput[]
    createMany?: FilingWastageCreateManyFilingLotIdInputEnvelope
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput> | BuffingWastageCreateWithoutBuffingLotIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingLotIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingLotIdInput | BuffingWastageCreateOrConnectWithoutBuffingLotIdInput[]
    createMany?: BuffingWastageCreateManyBuffingLotIdInputEnvelope
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AddFilingUpdateOneWithoutLotInfoNestedInput = {
    create?: XOR<AddFilingCreateWithoutLotInfoInput, AddFilingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutLotInfoInput
    upsert?: AddFilingUpsertWithoutLotInfoInput
    disconnect?: AddFilingWhereInput | boolean
    delete?: AddFilingWhereInput | boolean
    connect?: AddFilingWhereUniqueInput
    update?: XOR<XOR<AddFilingUpdateToOneWithWhereWithoutLotInfoInput, AddFilingUpdateWithoutLotInfoInput>, AddFilingUncheckedUpdateWithoutLotInfoInput>
  }

  export type AddSettingUpdateOneWithoutLotInfoNestedInput = {
    create?: XOR<AddSettingCreateWithoutLotInfoInput, AddSettingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutLotInfoInput
    upsert?: AddSettingUpsertWithoutLotInfoInput
    disconnect?: AddSettingWhereInput | boolean
    delete?: AddSettingWhereInput | boolean
    connect?: AddSettingWhereUniqueInput
    update?: XOR<XOR<AddSettingUpdateToOneWithWhereWithoutLotInfoInput, AddSettingUpdateWithoutLotInfoInput>, AddSettingUncheckedUpdateWithoutLotInfoInput>
  }

  export type AddBuffingUpdateOneWithoutLotInfoNestedInput = {
    create?: XOR<AddBuffingCreateWithoutLotInfoInput, AddBuffingUncheckedCreateWithoutLotInfoInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutLotInfoInput
    upsert?: AddBuffingUpsertWithoutLotInfoInput
    disconnect?: AddBuffingWhereInput | boolean
    delete?: AddBuffingWhereInput | boolean
    connect?: AddBuffingWhereUniqueInput
    update?: XOR<XOR<AddBuffingUpdateToOneWithWhereWithoutLotInfoInput, AddBuffingUpdateWithoutLotInfoInput>, AddBuffingUncheckedUpdateWithoutLotInfoInput>
  }

  export type LotFilingMapperUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput> | LotFilingMapperCreateWithoutLotIdInput[] | LotFilingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutLotIdInput | LotFilingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotFilingMapperCreateManyLotIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutLotIdInput | LotFilingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type LotSettingMapperUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput> | LotSettingMapperCreateWithoutLotIdInput[] | LotSettingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutLotIdInput | LotSettingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotSettingMapperCreateManyLotIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutLotIdInput | LotSettingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotBuffingMapperUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput> | LotBuffingMapperCreateWithoutLotIdInput[] | LotBuffingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutLotIdInput | LotBuffingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotBuffingMapperCreateManyLotIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutLotIdInput | LotBuffingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type FilingWastageUpdateManyWithoutFilingLotIdNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput> | FilingWastageCreateWithoutFilingLotIdInput[] | FilingWastageUncheckedCreateWithoutFilingLotIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingLotIdInput | FilingWastageCreateOrConnectWithoutFilingLotIdInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFilingLotIdInput | FilingWastageUpsertWithWhereUniqueWithoutFilingLotIdInput[]
    createMany?: FilingWastageCreateManyFilingLotIdInputEnvelope
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFilingLotIdInput | FilingWastageUpdateWithWhereUniqueWithoutFilingLotIdInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFilingLotIdInput | FilingWastageUpdateManyWithWhereWithoutFilingLotIdInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput> | BuffingWastageCreateWithoutBuffingLotIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingLotIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingLotIdInput | BuffingWastageCreateOrConnectWithoutBuffingLotIdInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffingLotIdInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffingLotIdInput[]
    createMany?: BuffingWastageCreateManyBuffingLotIdInputEnvelope
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffingLotIdInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffingLotIdInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffingLotIdInput | BuffingWastageUpdateManyWithWhereWithoutBuffingLotIdInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput> | LotFilingMapperCreateWithoutLotIdInput[] | LotFilingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutLotIdInput | LotFilingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotFilingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotFilingMapperCreateManyLotIdInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotFilingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutLotIdInput | LotFilingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput> | LotSettingMapperCreateWithoutLotIdInput[] | LotSettingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutLotIdInput | LotSettingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotSettingMapperCreateManyLotIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutLotIdInput | LotSettingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput> | LotBuffingMapperCreateWithoutLotIdInput[] | LotBuffingMapperUncheckedCreateWithoutLotIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutLotIdInput | LotBuffingMapperCreateOrConnectWithoutLotIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutLotIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutLotIdInput[]
    createMany?: LotBuffingMapperCreateManyLotIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutLotIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutLotIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutLotIdInput | LotBuffingMapperUpdateManyWithWhereWithoutLotIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput> | FilingWastageCreateWithoutFilingLotIdInput[] | FilingWastageUncheckedCreateWithoutFilingLotIdInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFilingLotIdInput | FilingWastageCreateOrConnectWithoutFilingLotIdInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFilingLotIdInput | FilingWastageUpsertWithWhereUniqueWithoutFilingLotIdInput[]
    createMany?: FilingWastageCreateManyFilingLotIdInputEnvelope
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFilingLotIdInput | FilingWastageUpdateWithWhereUniqueWithoutFilingLotIdInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFilingLotIdInput | FilingWastageUpdateManyWithWhereWithoutFilingLotIdInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput> | BuffingWastageCreateWithoutBuffingLotIdInput[] | BuffingWastageUncheckedCreateWithoutBuffingLotIdInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffingLotIdInput | BuffingWastageCreateOrConnectWithoutBuffingLotIdInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffingLotIdInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffingLotIdInput[]
    createMany?: BuffingWastageCreateManyBuffingLotIdInputEnvelope
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffingLotIdInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffingLotIdInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffingLotIdInput | BuffingWastageUpdateManyWithWhereWithoutBuffingLotIdInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type AddFilingCreateNestedOneWithoutFilingsInput = {
    create?: XOR<AddFilingCreateWithoutFilingsInput, AddFilingUncheckedCreateWithoutFilingsInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutFilingsInput
    connect?: AddFilingWhereUniqueInput
  }

  export type CastingItemsCreateNestedOneWithoutFilingEntryInput = {
    create?: XOR<CastingItemsCreateWithoutFilingEntryInput, CastingItemsUncheckedCreateWithoutFilingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutFilingEntryInput
    connect?: CastingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedManyWithoutFiling_entryInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput> | FilingItemsCreateWithoutFiling_entryInput[] | FilingItemsUncheckedCreateWithoutFiling_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_entryInput | FilingItemsCreateOrConnectWithoutFiling_entryInput[]
    createMany?: FilingItemsCreateManyFiling_entryInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput = {
    create?: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput> | FilingTotalBalanceCreateWithoutFilingEntryIdInput[] | FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput[]
    connectOrCreate?: FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput | FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput[]
    createMany?: FilingTotalBalanceCreateManyFilingEntryIdInputEnvelope
    connect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
  }

  export type LotFilingMapperCreateNestedManyWithoutFilingEntryInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput> | LotFilingMapperCreateWithoutFilingEntryInput[] | LotFilingMapperUncheckedCreateWithoutFilingEntryInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingEntryInput | LotFilingMapperCreateOrConnectWithoutFilingEntryInput[]
    createMany?: LotFilingMapperCreateManyFilingEntryInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput> | FilingItemsCreateWithoutFiling_entryInput[] | FilingItemsUncheckedCreateWithoutFiling_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_entryInput | FilingItemsCreateOrConnectWithoutFiling_entryInput[]
    createMany?: FilingItemsCreateManyFiling_entryInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput = {
    create?: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput> | FilingTotalBalanceCreateWithoutFilingEntryIdInput[] | FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput[]
    connectOrCreate?: FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput | FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput[]
    createMany?: FilingTotalBalanceCreateManyFilingEntryIdInputEnvelope
    connect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
  }

  export type LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput> | LotFilingMapperCreateWithoutFilingEntryInput[] | LotFilingMapperUncheckedCreateWithoutFilingEntryInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingEntryInput | LotFilingMapperCreateOrConnectWithoutFilingEntryInput[]
    createMany?: LotFilingMapperCreateManyFilingEntryInputEnvelope
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
  }

  export type AddFilingUpdateOneRequiredWithoutFilingsNestedInput = {
    create?: XOR<AddFilingCreateWithoutFilingsInput, AddFilingUncheckedCreateWithoutFilingsInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutFilingsInput
    upsert?: AddFilingUpsertWithoutFilingsInput
    connect?: AddFilingWhereUniqueInput
    update?: XOR<XOR<AddFilingUpdateToOneWithWhereWithoutFilingsInput, AddFilingUpdateWithoutFilingsInput>, AddFilingUncheckedUpdateWithoutFilingsInput>
  }

  export type CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput = {
    create?: XOR<CastingItemsCreateWithoutFilingEntryInput, CastingItemsUncheckedCreateWithoutFilingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutFilingEntryInput
    upsert?: CastingItemsUpsertWithoutFilingEntryInput
    connect?: CastingItemsWhereUniqueInput
    update?: XOR<XOR<CastingItemsUpdateToOneWithWhereWithoutFilingEntryInput, CastingItemsUpdateWithoutFilingEntryInput>, CastingItemsUncheckedUpdateWithoutFilingEntryInput>
  }

  export type FilingItemsUpdateManyWithoutFiling_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput> | FilingItemsCreateWithoutFiling_entryInput[] | FilingItemsUncheckedCreateWithoutFiling_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_entryInput | FilingItemsCreateOrConnectWithoutFiling_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFiling_entryInput | FilingItemsUpsertWithWhereUniqueWithoutFiling_entryInput[]
    createMany?: FilingItemsCreateManyFiling_entryInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFiling_entryInput | FilingItemsUpdateWithWhereUniqueWithoutFiling_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFiling_entryInput | FilingItemsUpdateManyWithWhereWithoutFiling_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput = {
    create?: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput> | FilingTotalBalanceCreateWithoutFilingEntryIdInput[] | FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput[]
    connectOrCreate?: FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput | FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput[]
    upsert?: FilingTotalBalanceUpsertWithWhereUniqueWithoutFilingEntryIdInput | FilingTotalBalanceUpsertWithWhereUniqueWithoutFilingEntryIdInput[]
    createMany?: FilingTotalBalanceCreateManyFilingEntryIdInputEnvelope
    set?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    disconnect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    delete?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    connect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    update?: FilingTotalBalanceUpdateWithWhereUniqueWithoutFilingEntryIdInput | FilingTotalBalanceUpdateWithWhereUniqueWithoutFilingEntryIdInput[]
    updateMany?: FilingTotalBalanceUpdateManyWithWhereWithoutFilingEntryIdInput | FilingTotalBalanceUpdateManyWithWhereWithoutFilingEntryIdInput[]
    deleteMany?: FilingTotalBalanceScalarWhereInput | FilingTotalBalanceScalarWhereInput[]
  }

  export type LotFilingMapperUpdateManyWithoutFilingEntryNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput> | LotFilingMapperCreateWithoutFilingEntryInput[] | LotFilingMapperUncheckedCreateWithoutFilingEntryInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingEntryInput | LotFilingMapperCreateOrConnectWithoutFilingEntryInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutFilingEntryInput | LotFilingMapperUpsertWithWhereUniqueWithoutFilingEntryInput[]
    createMany?: LotFilingMapperCreateManyFilingEntryInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutFilingEntryInput | LotFilingMapperUpdateWithWhereUniqueWithoutFilingEntryInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutFilingEntryInput | LotFilingMapperUpdateManyWithWhereWithoutFilingEntryInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput> | FilingItemsCreateWithoutFiling_entryInput[] | FilingItemsUncheckedCreateWithoutFiling_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_entryInput | FilingItemsCreateOrConnectWithoutFiling_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFiling_entryInput | FilingItemsUpsertWithWhereUniqueWithoutFiling_entryInput[]
    createMany?: FilingItemsCreateManyFiling_entryInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFiling_entryInput | FilingItemsUpdateWithWhereUniqueWithoutFiling_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFiling_entryInput | FilingItemsUpdateManyWithWhereWithoutFiling_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput = {
    create?: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput> | FilingTotalBalanceCreateWithoutFilingEntryIdInput[] | FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput[]
    connectOrCreate?: FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput | FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput[]
    upsert?: FilingTotalBalanceUpsertWithWhereUniqueWithoutFilingEntryIdInput | FilingTotalBalanceUpsertWithWhereUniqueWithoutFilingEntryIdInput[]
    createMany?: FilingTotalBalanceCreateManyFilingEntryIdInputEnvelope
    set?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    disconnect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    delete?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    connect?: FilingTotalBalanceWhereUniqueInput | FilingTotalBalanceWhereUniqueInput[]
    update?: FilingTotalBalanceUpdateWithWhereUniqueWithoutFilingEntryIdInput | FilingTotalBalanceUpdateWithWhereUniqueWithoutFilingEntryIdInput[]
    updateMany?: FilingTotalBalanceUpdateManyWithWhereWithoutFilingEntryIdInput | FilingTotalBalanceUpdateManyWithWhereWithoutFilingEntryIdInput[]
    deleteMany?: FilingTotalBalanceScalarWhereInput | FilingTotalBalanceScalarWhereInput[]
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput> | LotFilingMapperCreateWithoutFilingEntryInput[] | LotFilingMapperUncheckedCreateWithoutFilingEntryInput[]
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFilingEntryInput | LotFilingMapperCreateOrConnectWithoutFilingEntryInput[]
    upsert?: LotFilingMapperUpsertWithWhereUniqueWithoutFilingEntryInput | LotFilingMapperUpsertWithWhereUniqueWithoutFilingEntryInput[]
    createMany?: LotFilingMapperCreateManyFilingEntryInputEnvelope
    set?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    disconnect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    delete?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    connect?: LotFilingMapperWhereUniqueInput | LotFilingMapperWhereUniqueInput[]
    update?: LotFilingMapperUpdateWithWhereUniqueWithoutFilingEntryInput | LotFilingMapperUpdateWithWhereUniqueWithoutFilingEntryInput[]
    updateMany?: LotFilingMapperUpdateManyWithWhereWithoutFilingEntryInput | LotFilingMapperUpdateManyWithWhereWithoutFilingEntryInput[]
    deleteMany?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
  }

  export type AddFilingCreateNestedOneWithoutLotFilingMapperInput = {
    create?: XOR<AddFilingCreateWithoutLotFilingMapperInput, AddFilingUncheckedCreateWithoutLotFilingMapperInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutLotFilingMapperInput
    connect?: AddFilingWhereUniqueInput
  }

  export type LotInfoCreateNestedOneWithoutFilingMapperInput = {
    create?: XOR<LotInfoCreateWithoutFilingMapperInput, LotInfoUncheckedCreateWithoutFilingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingMapperInput
    connect?: LotInfoWhereUniqueInput
  }

  export type CastingItemsCreateNestedOneWithoutFilingLotMapperInput = {
    create?: XOR<CastingItemsCreateWithoutFilingLotMapperInput, CastingItemsUncheckedCreateWithoutFilingLotMapperInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutFilingLotMapperInput
    connect?: CastingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput = {
    create?: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput> | FilingItemsCreateWithoutLotFilingMapperIdInput[] | FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput | FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput[]
    createMany?: FilingItemsCreateManyLotFilingMapperIdInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type FilingEntryCreateNestedOneWithoutLotFilingMapperInput = {
    create?: XOR<FilingEntryCreateWithoutLotFilingMapperInput, FilingEntryUncheckedCreateWithoutLotFilingMapperInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutLotFilingMapperInput
    connect?: FilingEntryWhereUniqueInput
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput = {
    create?: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput> | FilingItemsCreateWithoutLotFilingMapperIdInput[] | FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput | FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput[]
    createMany?: FilingItemsCreateManyLotFilingMapperIdInputEnvelope
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput = {
    create?: XOR<AddFilingCreateWithoutLotFilingMapperInput, AddFilingUncheckedCreateWithoutLotFilingMapperInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutLotFilingMapperInput
    upsert?: AddFilingUpsertWithoutLotFilingMapperInput
    connect?: AddFilingWhereUniqueInput
    update?: XOR<XOR<AddFilingUpdateToOneWithWhereWithoutLotFilingMapperInput, AddFilingUpdateWithoutLotFilingMapperInput>, AddFilingUncheckedUpdateWithoutLotFilingMapperInput>
  }

  export type LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput = {
    create?: XOR<LotInfoCreateWithoutFilingMapperInput, LotInfoUncheckedCreateWithoutFilingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingMapperInput
    upsert?: LotInfoUpsertWithoutFilingMapperInput
    connect?: LotInfoWhereUniqueInput
    update?: XOR<XOR<LotInfoUpdateToOneWithWhereWithoutFilingMapperInput, LotInfoUpdateWithoutFilingMapperInput>, LotInfoUncheckedUpdateWithoutFilingMapperInput>
  }

  export type CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput = {
    create?: XOR<CastingItemsCreateWithoutFilingLotMapperInput, CastingItemsUncheckedCreateWithoutFilingLotMapperInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutFilingLotMapperInput
    upsert?: CastingItemsUpsertWithoutFilingLotMapperInput
    connect?: CastingItemsWhereUniqueInput
    update?: XOR<XOR<CastingItemsUpdateToOneWithWhereWithoutFilingLotMapperInput, CastingItemsUpdateWithoutFilingLotMapperInput>, CastingItemsUncheckedUpdateWithoutFilingLotMapperInput>
  }

  export type FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput = {
    create?: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput> | FilingItemsCreateWithoutLotFilingMapperIdInput[] | FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput | FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutLotFilingMapperIdInput | FilingItemsUpsertWithWhereUniqueWithoutLotFilingMapperIdInput[]
    createMany?: FilingItemsCreateManyLotFilingMapperIdInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutLotFilingMapperIdInput | FilingItemsUpdateWithWhereUniqueWithoutLotFilingMapperIdInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutLotFilingMapperIdInput | FilingItemsUpdateManyWithWhereWithoutLotFilingMapperIdInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput = {
    create?: XOR<FilingEntryCreateWithoutLotFilingMapperInput, FilingEntryUncheckedCreateWithoutLotFilingMapperInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutLotFilingMapperInput
    upsert?: FilingEntryUpsertWithoutLotFilingMapperInput
    connect?: FilingEntryWhereUniqueInput
    update?: XOR<XOR<FilingEntryUpdateToOneWithWhereWithoutLotFilingMapperInput, FilingEntryUpdateWithoutLotFilingMapperInput>, FilingEntryUncheckedUpdateWithoutLotFilingMapperInput>
  }

  export type FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput = {
    create?: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput> | FilingItemsCreateWithoutLotFilingMapperIdInput[] | FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput | FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutLotFilingMapperIdInput | FilingItemsUpsertWithWhereUniqueWithoutLotFilingMapperIdInput[]
    createMany?: FilingItemsCreateManyLotFilingMapperIdInputEnvelope
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutLotFilingMapperIdInput | FilingItemsUpdateWithWhereUniqueWithoutLotFilingMapperIdInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutLotFilingMapperIdInput | FilingItemsUpdateManyWithWhereWithoutLotFilingMapperIdInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type FilingEntryCreateNestedOneWithoutFilingItemsInput = {
    create?: XOR<FilingEntryCreateWithoutFilingItemsInput, FilingEntryUncheckedCreateWithoutFilingItemsInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFilingItemsInput
    connect?: FilingEntryWhereUniqueInput
  }

  export type AddItemCreateNestedOneWithoutFiling_itemsInput = {
    create?: XOR<AddItemCreateWithoutFiling_itemsInput, AddItemUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutFiling_itemsInput
    connect?: AddItemWhereUniqueInput
  }

  export type AddTouchCreateNestedOneWithoutFiling_itemsInput = {
    create?: XOR<AddTouchCreateWithoutFiling_itemsInput, AddTouchUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutFiling_itemsInput
    connect?: AddTouchWhereUniqueInput
  }

  export type StockCreateNestedManyWithoutFilingItemInput = {
    create?: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput> | StockCreateWithoutFilingItemInput[] | StockUncheckedCreateWithoutFilingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutFilingItemInput | StockCreateOrConnectWithoutFilingItemInput[]
    createMany?: StockCreateManyFilingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type SettingEntryCreateNestedManyWithoutFilingItemsInput = {
    create?: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput> | SettingEntryCreateWithoutFilingItemsInput[] | SettingEntryUncheckedCreateWithoutFilingItemsInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutFilingItemsInput | SettingEntryCreateOrConnectWithoutFilingItemsInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type BuffingEntryCreateNestedManyWithoutFiling_itemsInput = {
    create?: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput> | BuffingEntryCreateWithoutFiling_itemsInput[] | BuffingEntryUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutFiling_itemsInput | BuffingEntryCreateOrConnectWithoutFiling_itemsInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type FilingWastageCreateNestedManyWithoutFiling_itemsInput = {
    create?: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput> | FilingWastageCreateWithoutFiling_itemsInput[] | FilingWastageUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFiling_itemsInput | FilingWastageCreateOrConnectWithoutFiling_itemsInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type LotSettingMapperCreateNestedManyWithoutItemIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput> | LotSettingMapperCreateWithoutItemIdInput[] | LotSettingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutItemIdInput | LotSettingMapperCreateOrConnectWithoutItemIdInput[]
    createMany?: LotSettingMapperCreateManyItemIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput> | LotBuffingMapperCreateWithoutFilingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput | LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput[]
    createMany?: LotBuffingMapperCreateManyFilingItemIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type LotFilingMapperCreateNestedOneWithoutFiling_itemsInput = {
    create?: XOR<LotFilingMapperCreateWithoutFiling_itemsInput, LotFilingMapperUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFiling_itemsInput
    connect?: LotFilingMapperWhereUniqueInput
  }

  export type StockUncheckedCreateNestedManyWithoutFilingItemInput = {
    create?: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput> | StockCreateWithoutFilingItemInput[] | StockUncheckedCreateWithoutFilingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutFilingItemInput | StockCreateOrConnectWithoutFilingItemInput[]
    createMany?: StockCreateManyFilingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput = {
    create?: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput> | SettingEntryCreateWithoutFilingItemsInput[] | SettingEntryUncheckedCreateWithoutFilingItemsInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutFilingItemsInput | SettingEntryCreateOrConnectWithoutFilingItemsInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
  }

  export type BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput = {
    create?: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput> | BuffingEntryCreateWithoutFiling_itemsInput[] | BuffingEntryUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutFiling_itemsInput | BuffingEntryCreateOrConnectWithoutFiling_itemsInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput = {
    create?: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput> | FilingWastageCreateWithoutFiling_itemsInput[] | FilingWastageUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFiling_itemsInput | FilingWastageCreateOrConnectWithoutFiling_itemsInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
  }

  export type LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput = {
    create?: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput> | LotSettingMapperCreateWithoutItemIdInput[] | LotSettingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutItemIdInput | LotSettingMapperCreateOrConnectWithoutItemIdInput[]
    createMany?: LotSettingMapperCreateManyItemIdInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput> | LotBuffingMapperCreateWithoutFilingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput | LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput[]
    createMany?: LotBuffingMapperCreateManyFilingItemIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type NullableEnumSTONEOPTIONFieldUpdateOperationsInput = {
    set?: $Enums.STONEOPTION | null
  }

  export type FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput = {
    create?: XOR<FilingEntryCreateWithoutFilingItemsInput, FilingEntryUncheckedCreateWithoutFilingItemsInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFilingItemsInput
    upsert?: FilingEntryUpsertWithoutFilingItemsInput
    connect?: FilingEntryWhereUniqueInput
    update?: XOR<XOR<FilingEntryUpdateToOneWithWhereWithoutFilingItemsInput, FilingEntryUpdateWithoutFilingItemsInput>, FilingEntryUncheckedUpdateWithoutFilingItemsInput>
  }

  export type AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput = {
    create?: XOR<AddItemCreateWithoutFiling_itemsInput, AddItemUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutFiling_itemsInput
    upsert?: AddItemUpsertWithoutFiling_itemsInput
    connect?: AddItemWhereUniqueInput
    update?: XOR<XOR<AddItemUpdateToOneWithWhereWithoutFiling_itemsInput, AddItemUpdateWithoutFiling_itemsInput>, AddItemUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput = {
    create?: XOR<AddTouchCreateWithoutFiling_itemsInput, AddTouchUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutFiling_itemsInput
    upsert?: AddTouchUpsertWithoutFiling_itemsInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutFiling_itemsInput, AddTouchUpdateWithoutFiling_itemsInput>, AddTouchUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type StockUpdateManyWithoutFilingItemNestedInput = {
    create?: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput> | StockCreateWithoutFilingItemInput[] | StockUncheckedCreateWithoutFilingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutFilingItemInput | StockCreateOrConnectWithoutFilingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutFilingItemInput | StockUpsertWithWhereUniqueWithoutFilingItemInput[]
    createMany?: StockCreateManyFilingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutFilingItemInput | StockUpdateWithWhereUniqueWithoutFilingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutFilingItemInput | StockUpdateManyWithWhereWithoutFilingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type SettingEntryUpdateManyWithoutFilingItemsNestedInput = {
    create?: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput> | SettingEntryCreateWithoutFilingItemsInput[] | SettingEntryUncheckedCreateWithoutFilingItemsInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutFilingItemsInput | SettingEntryCreateOrConnectWithoutFilingItemsInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutFilingItemsInput | SettingEntryUpsertWithWhereUniqueWithoutFilingItemsInput[]
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutFilingItemsInput | SettingEntryUpdateWithWhereUniqueWithoutFilingItemsInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutFilingItemsInput | SettingEntryUpdateManyWithWhereWithoutFilingItemsInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type BuffingEntryUpdateManyWithoutFiling_itemsNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput> | BuffingEntryCreateWithoutFiling_itemsInput[] | BuffingEntryUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutFiling_itemsInput | BuffingEntryCreateOrConnectWithoutFiling_itemsInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutFiling_itemsInput | BuffingEntryUpsertWithWhereUniqueWithoutFiling_itemsInput[]
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutFiling_itemsInput | BuffingEntryUpdateWithWhereUniqueWithoutFiling_itemsInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutFiling_itemsInput | BuffingEntryUpdateManyWithWhereWithoutFiling_itemsInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type FilingWastageUpdateManyWithoutFiling_itemsNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput> | FilingWastageCreateWithoutFiling_itemsInput[] | FilingWastageUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFiling_itemsInput | FilingWastageCreateOrConnectWithoutFiling_itemsInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFiling_itemsInput | FilingWastageUpsertWithWhereUniqueWithoutFiling_itemsInput[]
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFiling_itemsInput | FilingWastageUpdateWithWhereUniqueWithoutFiling_itemsInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFiling_itemsInput | FilingWastageUpdateManyWithWhereWithoutFiling_itemsInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type LotSettingMapperUpdateManyWithoutItemIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput> | LotSettingMapperCreateWithoutItemIdInput[] | LotSettingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutItemIdInput | LotSettingMapperCreateOrConnectWithoutItemIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutItemIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutItemIdInput[]
    createMany?: LotSettingMapperCreateManyItemIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutItemIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutItemIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutItemIdInput | LotSettingMapperUpdateManyWithWhereWithoutItemIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput> | LotBuffingMapperCreateWithoutFilingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput | LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutFilingItemIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutFilingItemIdInput[]
    createMany?: LotBuffingMapperCreateManyFilingItemIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutFilingItemIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutFilingItemIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutFilingItemIdInput | LotBuffingMapperUpdateManyWithWhereWithoutFilingItemIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput = {
    create?: XOR<LotFilingMapperCreateWithoutFiling_itemsInput, LotFilingMapperUncheckedCreateWithoutFiling_itemsInput>
    connectOrCreate?: LotFilingMapperCreateOrConnectWithoutFiling_itemsInput
    upsert?: LotFilingMapperUpsertWithoutFiling_itemsInput
    disconnect?: LotFilingMapperWhereInput | boolean
    delete?: LotFilingMapperWhereInput | boolean
    connect?: LotFilingMapperWhereUniqueInput
    update?: XOR<XOR<LotFilingMapperUpdateToOneWithWhereWithoutFiling_itemsInput, LotFilingMapperUpdateWithoutFiling_itemsInput>, LotFilingMapperUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type StockUncheckedUpdateManyWithoutFilingItemNestedInput = {
    create?: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput> | StockCreateWithoutFilingItemInput[] | StockUncheckedCreateWithoutFilingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutFilingItemInput | StockCreateOrConnectWithoutFilingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutFilingItemInput | StockUpsertWithWhereUniqueWithoutFilingItemInput[]
    createMany?: StockCreateManyFilingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutFilingItemInput | StockUpdateWithWhereUniqueWithoutFilingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutFilingItemInput | StockUpdateManyWithWhereWithoutFilingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput = {
    create?: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput> | SettingEntryCreateWithoutFilingItemsInput[] | SettingEntryUncheckedCreateWithoutFilingItemsInput[]
    connectOrCreate?: SettingEntryCreateOrConnectWithoutFilingItemsInput | SettingEntryCreateOrConnectWithoutFilingItemsInput[]
    upsert?: SettingEntryUpsertWithWhereUniqueWithoutFilingItemsInput | SettingEntryUpsertWithWhereUniqueWithoutFilingItemsInput[]
    set?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    disconnect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    delete?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    connect?: SettingEntryWhereUniqueInput | SettingEntryWhereUniqueInput[]
    update?: SettingEntryUpdateWithWhereUniqueWithoutFilingItemsInput | SettingEntryUpdateWithWhereUniqueWithoutFilingItemsInput[]
    updateMany?: SettingEntryUpdateManyWithWhereWithoutFilingItemsInput | SettingEntryUpdateManyWithWhereWithoutFilingItemsInput[]
    deleteMany?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
  }

  export type BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput> | BuffingEntryCreateWithoutFiling_itemsInput[] | BuffingEntryUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutFiling_itemsInput | BuffingEntryCreateOrConnectWithoutFiling_itemsInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutFiling_itemsInput | BuffingEntryUpsertWithWhereUniqueWithoutFiling_itemsInput[]
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutFiling_itemsInput | BuffingEntryUpdateWithWhereUniqueWithoutFiling_itemsInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutFiling_itemsInput | BuffingEntryUpdateManyWithWhereWithoutFiling_itemsInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput = {
    create?: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput> | FilingWastageCreateWithoutFiling_itemsInput[] | FilingWastageUncheckedCreateWithoutFiling_itemsInput[]
    connectOrCreate?: FilingWastageCreateOrConnectWithoutFiling_itemsInput | FilingWastageCreateOrConnectWithoutFiling_itemsInput[]
    upsert?: FilingWastageUpsertWithWhereUniqueWithoutFiling_itemsInput | FilingWastageUpsertWithWhereUniqueWithoutFiling_itemsInput[]
    set?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    disconnect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    delete?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    connect?: FilingWastageWhereUniqueInput | FilingWastageWhereUniqueInput[]
    update?: FilingWastageUpdateWithWhereUniqueWithoutFiling_itemsInput | FilingWastageUpdateWithWhereUniqueWithoutFiling_itemsInput[]
    updateMany?: FilingWastageUpdateManyWithWhereWithoutFiling_itemsInput | FilingWastageUpdateManyWithWhereWithoutFiling_itemsInput[]
    deleteMany?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput> | LotSettingMapperCreateWithoutItemIdInput[] | LotSettingMapperUncheckedCreateWithoutItemIdInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutItemIdInput | LotSettingMapperCreateOrConnectWithoutItemIdInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutItemIdInput | LotSettingMapperUpsertWithWhereUniqueWithoutItemIdInput[]
    createMany?: LotSettingMapperCreateManyItemIdInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutItemIdInput | LotSettingMapperUpdateWithWhereUniqueWithoutItemIdInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutItemIdInput | LotSettingMapperUpdateManyWithWhereWithoutItemIdInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput> | LotBuffingMapperCreateWithoutFilingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput | LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutFilingItemIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutFilingItemIdInput[]
    createMany?: LotBuffingMapperCreateManyFilingItemIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutFilingItemIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutFilingItemIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutFilingItemIdInput | LotBuffingMapperUpdateManyWithWhereWithoutFilingItemIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type FilingEntryCreateNestedOneWithoutFilingTotalBalanceInput = {
    create?: XOR<FilingEntryCreateWithoutFilingTotalBalanceInput, FilingEntryUncheckedCreateWithoutFilingTotalBalanceInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFilingTotalBalanceInput
    connect?: FilingEntryWhereUniqueInput
  }

  export type FilingEntryUpdateOneRequiredWithoutFilingTotalBalanceNestedInput = {
    create?: XOR<FilingEntryCreateWithoutFilingTotalBalanceInput, FilingEntryUncheckedCreateWithoutFilingTotalBalanceInput>
    connectOrCreate?: FilingEntryCreateOrConnectWithoutFilingTotalBalanceInput
    upsert?: FilingEntryUpsertWithoutFilingTotalBalanceInput
    connect?: FilingEntryWhereUniqueInput
    update?: XOR<XOR<FilingEntryUpdateToOneWithWhereWithoutFilingTotalBalanceInput, FilingEntryUpdateWithoutFilingTotalBalanceInput>, FilingEntryUncheckedUpdateWithoutFilingTotalBalanceInput>
  }

  export type AddFilingCreateNestedOneWithoutFilingWastagesInput = {
    create?: XOR<AddFilingCreateWithoutFilingWastagesInput, AddFilingUncheckedCreateWithoutFilingWastagesInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutFilingWastagesInput
    connect?: AddFilingWhereUniqueInput
  }

  export type LotInfoCreateNestedOneWithoutFilingWastagesInput = {
    create?: XOR<LotInfoCreateWithoutFilingWastagesInput, LotInfoUncheckedCreateWithoutFilingWastagesInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingWastagesInput
    connect?: LotInfoWhereUniqueInput
  }

  export type FilingItemsCreateNestedManyWithoutFiling_wastageInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput> | FilingItemsCreateWithoutFiling_wastageInput[] | FilingItemsUncheckedCreateWithoutFiling_wastageInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_wastageInput | FilingItemsCreateOrConnectWithoutFiling_wastageInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutFiling_wastageInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput> | FilingItemsCreateWithoutFiling_wastageInput[] | FilingItemsUncheckedCreateWithoutFiling_wastageInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_wastageInput | FilingItemsCreateOrConnectWithoutFiling_wastageInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type AddFilingUpdateOneWithoutFilingWastagesNestedInput = {
    create?: XOR<AddFilingCreateWithoutFilingWastagesInput, AddFilingUncheckedCreateWithoutFilingWastagesInput>
    connectOrCreate?: AddFilingCreateOrConnectWithoutFilingWastagesInput
    upsert?: AddFilingUpsertWithoutFilingWastagesInput
    disconnect?: AddFilingWhereInput | boolean
    delete?: AddFilingWhereInput | boolean
    connect?: AddFilingWhereUniqueInput
    update?: XOR<XOR<AddFilingUpdateToOneWithWhereWithoutFilingWastagesInput, AddFilingUpdateWithoutFilingWastagesInput>, AddFilingUncheckedUpdateWithoutFilingWastagesInput>
  }

  export type LotInfoUpdateOneWithoutFilingWastagesNestedInput = {
    create?: XOR<LotInfoCreateWithoutFilingWastagesInput, LotInfoUncheckedCreateWithoutFilingWastagesInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutFilingWastagesInput
    upsert?: LotInfoUpsertWithoutFilingWastagesInput
    disconnect?: LotInfoWhereInput | boolean
    delete?: LotInfoWhereInput | boolean
    connect?: LotInfoWhereUniqueInput
    update?: XOR<XOR<LotInfoUpdateToOneWithWhereWithoutFilingWastagesInput, LotInfoUpdateWithoutFilingWastagesInput>, LotInfoUncheckedUpdateWithoutFilingWastagesInput>
  }

  export type FilingItemsUpdateManyWithoutFiling_wastageNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput> | FilingItemsCreateWithoutFiling_wastageInput[] | FilingItemsUncheckedCreateWithoutFiling_wastageInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_wastageInput | FilingItemsCreateOrConnectWithoutFiling_wastageInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFiling_wastageInput | FilingItemsUpsertWithWhereUniqueWithoutFiling_wastageInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFiling_wastageInput | FilingItemsUpdateWithWhereUniqueWithoutFiling_wastageInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFiling_wastageInput | FilingItemsUpdateManyWithWhereWithoutFiling_wastageInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutFiling_wastageNestedInput = {
    create?: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput> | FilingItemsCreateWithoutFiling_wastageInput[] | FilingItemsUncheckedCreateWithoutFiling_wastageInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutFiling_wastageInput | FilingItemsCreateOrConnectWithoutFiling_wastageInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutFiling_wastageInput | FilingItemsUpsertWithWhereUniqueWithoutFiling_wastageInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutFiling_wastageInput | FilingItemsUpdateWithWhereUniqueWithoutFiling_wastageInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutFiling_wastageInput | FilingItemsUpdateManyWithWhereWithoutFiling_wastageInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type AddSettingCreateNestedOneWithoutSettingsInput = {
    create?: XOR<AddSettingCreateWithoutSettingsInput, AddSettingUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutSettingsInput
    connect?: AddSettingWhereUniqueInput
  }

  export type CastingItemsCreateNestedOneWithoutSettingEntryInput = {
    create?: XOR<CastingItemsCreateWithoutSettingEntryInput, CastingItemsUncheckedCreateWithoutSettingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutSettingEntryInput
    connect?: CastingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedManyWithoutSetting_entryInput = {
    create?: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput> | FilingItemsCreateWithoutSetting_entryInput[] | FilingItemsUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutSetting_entryInput | FilingItemsCreateOrConnectWithoutSetting_entryInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput = {
    create?: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput> | SettingTotalBalanceCreateWithoutSetting_entryInput[] | SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput | SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput[]
    createMany?: SettingTotalBalanceCreateManySetting_entryInputEnvelope
    connect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
  }

  export type SettingWastageCreateNestedManyWithoutSettingEntryIdInput = {
    create?: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput> | SettingWastageCreateWithoutSettingEntryIdInput[] | SettingWastageUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSettingEntryIdInput | SettingWastageCreateOrConnectWithoutSettingEntryIdInput[]
    createMany?: SettingWastageCreateManySettingEntryIdInputEnvelope
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
  }

  export type LotSettingMapperCreateNestedManyWithoutSettingEntryInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput> | LotSettingMapperCreateWithoutSettingEntryInput[] | LotSettingMapperUncheckedCreateWithoutSettingEntryInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingEntryInput | LotSettingMapperCreateOrConnectWithoutSettingEntryInput[]
    createMany?: LotSettingMapperCreateManySettingEntryInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type SettingItemsCreateNestedManyWithoutSettingEntryIdInput = {
    create?: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput> | SettingItemsCreateWithoutSettingEntryIdInput[] | SettingItemsUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSettingEntryIdInput | SettingItemsCreateOrConnectWithoutSettingEntryIdInput[]
    createMany?: SettingItemsCreateManySettingEntryIdInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput = {
    create?: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput> | FilingItemsCreateWithoutSetting_entryInput[] | FilingItemsUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutSetting_entryInput | FilingItemsCreateOrConnectWithoutSetting_entryInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput = {
    create?: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput> | SettingTotalBalanceCreateWithoutSetting_entryInput[] | SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput | SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput[]
    createMany?: SettingTotalBalanceCreateManySetting_entryInputEnvelope
    connect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
  }

  export type SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput = {
    create?: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput> | SettingWastageCreateWithoutSettingEntryIdInput[] | SettingWastageUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSettingEntryIdInput | SettingWastageCreateOrConnectWithoutSettingEntryIdInput[]
    createMany?: SettingWastageCreateManySettingEntryIdInputEnvelope
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
  }

  export type LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput> | LotSettingMapperCreateWithoutSettingEntryInput[] | LotSettingMapperUncheckedCreateWithoutSettingEntryInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingEntryInput | LotSettingMapperCreateOrConnectWithoutSettingEntryInput[]
    createMany?: LotSettingMapperCreateManySettingEntryInputEnvelope
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
  }

  export type SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput = {
    create?: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput> | SettingItemsCreateWithoutSettingEntryIdInput[] | SettingItemsUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSettingEntryIdInput | SettingItemsCreateOrConnectWithoutSettingEntryIdInput[]
    createMany?: SettingItemsCreateManySettingEntryIdInputEnvelope
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type AddSettingUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<AddSettingCreateWithoutSettingsInput, AddSettingUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutSettingsInput
    upsert?: AddSettingUpsertWithoutSettingsInput
    connect?: AddSettingWhereUniqueInput
    update?: XOR<XOR<AddSettingUpdateToOneWithWhereWithoutSettingsInput, AddSettingUpdateWithoutSettingsInput>, AddSettingUncheckedUpdateWithoutSettingsInput>
  }

  export type CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput = {
    create?: XOR<CastingItemsCreateWithoutSettingEntryInput, CastingItemsUncheckedCreateWithoutSettingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutSettingEntryInput
    upsert?: CastingItemsUpsertWithoutSettingEntryInput
    connect?: CastingItemsWhereUniqueInput
    update?: XOR<XOR<CastingItemsUpdateToOneWithWhereWithoutSettingEntryInput, CastingItemsUpdateWithoutSettingEntryInput>, CastingItemsUncheckedUpdateWithoutSettingEntryInput>
  }

  export type FilingItemsUpdateManyWithoutSetting_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput> | FilingItemsCreateWithoutSetting_entryInput[] | FilingItemsUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutSetting_entryInput | FilingItemsCreateOrConnectWithoutSetting_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutSetting_entryInput | FilingItemsUpsertWithWhereUniqueWithoutSetting_entryInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutSetting_entryInput | FilingItemsUpdateWithWhereUniqueWithoutSetting_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutSetting_entryInput | FilingItemsUpdateManyWithWhereWithoutSetting_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput = {
    create?: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput> | SettingTotalBalanceCreateWithoutSetting_entryInput[] | SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput | SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput[]
    upsert?: SettingTotalBalanceUpsertWithWhereUniqueWithoutSetting_entryInput | SettingTotalBalanceUpsertWithWhereUniqueWithoutSetting_entryInput[]
    createMany?: SettingTotalBalanceCreateManySetting_entryInputEnvelope
    set?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    disconnect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    delete?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    connect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    update?: SettingTotalBalanceUpdateWithWhereUniqueWithoutSetting_entryInput | SettingTotalBalanceUpdateWithWhereUniqueWithoutSetting_entryInput[]
    updateMany?: SettingTotalBalanceUpdateManyWithWhereWithoutSetting_entryInput | SettingTotalBalanceUpdateManyWithWhereWithoutSetting_entryInput[]
    deleteMany?: SettingTotalBalanceScalarWhereInput | SettingTotalBalanceScalarWhereInput[]
  }

  export type SettingWastageUpdateManyWithoutSettingEntryIdNestedInput = {
    create?: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput> | SettingWastageCreateWithoutSettingEntryIdInput[] | SettingWastageUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSettingEntryIdInput | SettingWastageCreateOrConnectWithoutSettingEntryIdInput[]
    upsert?: SettingWastageUpsertWithWhereUniqueWithoutSettingEntryIdInput | SettingWastageUpsertWithWhereUniqueWithoutSettingEntryIdInput[]
    createMany?: SettingWastageCreateManySettingEntryIdInputEnvelope
    set?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    disconnect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    delete?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    update?: SettingWastageUpdateWithWhereUniqueWithoutSettingEntryIdInput | SettingWastageUpdateWithWhereUniqueWithoutSettingEntryIdInput[]
    updateMany?: SettingWastageUpdateManyWithWhereWithoutSettingEntryIdInput | SettingWastageUpdateManyWithWhereWithoutSettingEntryIdInput[]
    deleteMany?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
  }

  export type LotSettingMapperUpdateManyWithoutSettingEntryNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput> | LotSettingMapperCreateWithoutSettingEntryInput[] | LotSettingMapperUncheckedCreateWithoutSettingEntryInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingEntryInput | LotSettingMapperCreateOrConnectWithoutSettingEntryInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutSettingEntryInput | LotSettingMapperUpsertWithWhereUniqueWithoutSettingEntryInput[]
    createMany?: LotSettingMapperCreateManySettingEntryInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutSettingEntryInput | LotSettingMapperUpdateWithWhereUniqueWithoutSettingEntryInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutSettingEntryInput | LotSettingMapperUpdateManyWithWhereWithoutSettingEntryInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type SettingItemsUpdateManyWithoutSettingEntryIdNestedInput = {
    create?: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput> | SettingItemsCreateWithoutSettingEntryIdInput[] | SettingItemsUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSettingEntryIdInput | SettingItemsCreateOrConnectWithoutSettingEntryIdInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutSettingEntryIdInput | SettingItemsUpsertWithWhereUniqueWithoutSettingEntryIdInput[]
    createMany?: SettingItemsCreateManySettingEntryIdInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutSettingEntryIdInput | SettingItemsUpdateWithWhereUniqueWithoutSettingEntryIdInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutSettingEntryIdInput | SettingItemsUpdateManyWithWhereWithoutSettingEntryIdInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput> | FilingItemsCreateWithoutSetting_entryInput[] | FilingItemsUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutSetting_entryInput | FilingItemsCreateOrConnectWithoutSetting_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutSetting_entryInput | FilingItemsUpsertWithWhereUniqueWithoutSetting_entryInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutSetting_entryInput | FilingItemsUpdateWithWhereUniqueWithoutSetting_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutSetting_entryInput | FilingItemsUpdateManyWithWhereWithoutSetting_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput = {
    create?: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput> | SettingTotalBalanceCreateWithoutSetting_entryInput[] | SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput[]
    connectOrCreate?: SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput | SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput[]
    upsert?: SettingTotalBalanceUpsertWithWhereUniqueWithoutSetting_entryInput | SettingTotalBalanceUpsertWithWhereUniqueWithoutSetting_entryInput[]
    createMany?: SettingTotalBalanceCreateManySetting_entryInputEnvelope
    set?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    disconnect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    delete?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    connect?: SettingTotalBalanceWhereUniqueInput | SettingTotalBalanceWhereUniqueInput[]
    update?: SettingTotalBalanceUpdateWithWhereUniqueWithoutSetting_entryInput | SettingTotalBalanceUpdateWithWhereUniqueWithoutSetting_entryInput[]
    updateMany?: SettingTotalBalanceUpdateManyWithWhereWithoutSetting_entryInput | SettingTotalBalanceUpdateManyWithWhereWithoutSetting_entryInput[]
    deleteMany?: SettingTotalBalanceScalarWhereInput | SettingTotalBalanceScalarWhereInput[]
  }

  export type SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput = {
    create?: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput> | SettingWastageCreateWithoutSettingEntryIdInput[] | SettingWastageUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSettingEntryIdInput | SettingWastageCreateOrConnectWithoutSettingEntryIdInput[]
    upsert?: SettingWastageUpsertWithWhereUniqueWithoutSettingEntryIdInput | SettingWastageUpsertWithWhereUniqueWithoutSettingEntryIdInput[]
    createMany?: SettingWastageCreateManySettingEntryIdInputEnvelope
    set?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    disconnect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    delete?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    update?: SettingWastageUpdateWithWhereUniqueWithoutSettingEntryIdInput | SettingWastageUpdateWithWhereUniqueWithoutSettingEntryIdInput[]
    updateMany?: SettingWastageUpdateManyWithWhereWithoutSettingEntryIdInput | SettingWastageUpdateManyWithWhereWithoutSettingEntryIdInput[]
    deleteMany?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput = {
    create?: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput> | LotSettingMapperCreateWithoutSettingEntryInput[] | LotSettingMapperUncheckedCreateWithoutSettingEntryInput[]
    connectOrCreate?: LotSettingMapperCreateOrConnectWithoutSettingEntryInput | LotSettingMapperCreateOrConnectWithoutSettingEntryInput[]
    upsert?: LotSettingMapperUpsertWithWhereUniqueWithoutSettingEntryInput | LotSettingMapperUpsertWithWhereUniqueWithoutSettingEntryInput[]
    createMany?: LotSettingMapperCreateManySettingEntryInputEnvelope
    set?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    disconnect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    delete?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    connect?: LotSettingMapperWhereUniqueInput | LotSettingMapperWhereUniqueInput[]
    update?: LotSettingMapperUpdateWithWhereUniqueWithoutSettingEntryInput | LotSettingMapperUpdateWithWhereUniqueWithoutSettingEntryInput[]
    updateMany?: LotSettingMapperUpdateManyWithWhereWithoutSettingEntryInput | LotSettingMapperUpdateManyWithWhereWithoutSettingEntryInput[]
    deleteMany?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
  }

  export type SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput = {
    create?: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput> | SettingItemsCreateWithoutSettingEntryIdInput[] | SettingItemsUncheckedCreateWithoutSettingEntryIdInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSettingEntryIdInput | SettingItemsCreateOrConnectWithoutSettingEntryIdInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutSettingEntryIdInput | SettingItemsUpsertWithWhereUniqueWithoutSettingEntryIdInput[]
    createMany?: SettingItemsCreateManySettingEntryIdInputEnvelope
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutSettingEntryIdInput | SettingItemsUpdateWithWhereUniqueWithoutSettingEntryIdInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutSettingEntryIdInput | SettingItemsUpdateManyWithWhereWithoutSettingEntryIdInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type AddItemCreateNestedOneWithoutSetting_itemsInput = {
    create?: XOR<AddItemCreateWithoutSetting_itemsInput, AddItemUncheckedCreateWithoutSetting_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutSetting_itemsInput
    connect?: AddItemWhereUniqueInput
  }

  export type AddTouchCreateNestedOneWithoutSetting_itemsInput = {
    create?: XOR<AddTouchCreateWithoutSetting_itemsInput, AddTouchUncheckedCreateWithoutSetting_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutSetting_itemsInput
    connect?: AddTouchWhereUniqueInput
  }

  export type SettingWastageCreateNestedManyWithoutSetting_itemsInput = {
    create?: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput> | SettingWastageCreateWithoutSetting_itemsInput[] | SettingWastageUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSetting_itemsInput | SettingWastageCreateOrConnectWithoutSetting_itemsInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
  }

  export type BuffingEntryCreateNestedManyWithoutSetting_itemsInput = {
    create?: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput> | BuffingEntryCreateWithoutSetting_itemsInput[] | BuffingEntryUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutSetting_itemsInput | BuffingEntryCreateOrConnectWithoutSetting_itemsInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutSettingItemInput = {
    create?: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput> | StockCreateWithoutSettingItemInput[] | StockUncheckedCreateWithoutSettingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutSettingItemInput | StockCreateOrConnectWithoutSettingItemInput[]
    createMany?: StockCreateManySettingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput> | LotBuffingMapperCreateWithoutSettingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput | LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput[]
    createMany?: LotBuffingMapperCreateManySettingItemIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type SettingEntryCreateNestedOneWithoutSettingItemsInput = {
    create?: XOR<SettingEntryCreateWithoutSettingItemsInput, SettingEntryUncheckedCreateWithoutSettingItemsInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingItemsInput
    connect?: SettingEntryWhereUniqueInput
  }

  export type SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput = {
    create?: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput> | SettingWastageCreateWithoutSetting_itemsInput[] | SettingWastageUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSetting_itemsInput | SettingWastageCreateOrConnectWithoutSetting_itemsInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
  }

  export type BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput = {
    create?: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput> | BuffingEntryCreateWithoutSetting_itemsInput[] | BuffingEntryUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutSetting_itemsInput | BuffingEntryCreateOrConnectWithoutSetting_itemsInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutSettingItemInput = {
    create?: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput> | StockCreateWithoutSettingItemInput[] | StockUncheckedCreateWithoutSettingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutSettingItemInput | StockCreateOrConnectWithoutSettingItemInput[]
    createMany?: StockCreateManySettingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput = {
    create?: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput> | LotBuffingMapperCreateWithoutSettingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput | LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput[]
    createMany?: LotBuffingMapperCreateManySettingItemIdInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput = {
    set?: $Enums.CASTINGENTRYTYPE | null
  }

  export type AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput = {
    create?: XOR<AddItemCreateWithoutSetting_itemsInput, AddItemUncheckedCreateWithoutSetting_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutSetting_itemsInput
    upsert?: AddItemUpsertWithoutSetting_itemsInput
    connect?: AddItemWhereUniqueInput
    update?: XOR<XOR<AddItemUpdateToOneWithWhereWithoutSetting_itemsInput, AddItemUpdateWithoutSetting_itemsInput>, AddItemUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput = {
    create?: XOR<AddTouchCreateWithoutSetting_itemsInput, AddTouchUncheckedCreateWithoutSetting_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutSetting_itemsInput
    upsert?: AddTouchUpsertWithoutSetting_itemsInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutSetting_itemsInput, AddTouchUpdateWithoutSetting_itemsInput>, AddTouchUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type SettingWastageUpdateManyWithoutSetting_itemsNestedInput = {
    create?: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput> | SettingWastageCreateWithoutSetting_itemsInput[] | SettingWastageUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSetting_itemsInput | SettingWastageCreateOrConnectWithoutSetting_itemsInput[]
    upsert?: SettingWastageUpsertWithWhereUniqueWithoutSetting_itemsInput | SettingWastageUpsertWithWhereUniqueWithoutSetting_itemsInput[]
    set?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    disconnect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    delete?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    update?: SettingWastageUpdateWithWhereUniqueWithoutSetting_itemsInput | SettingWastageUpdateWithWhereUniqueWithoutSetting_itemsInput[]
    updateMany?: SettingWastageUpdateManyWithWhereWithoutSetting_itemsInput | SettingWastageUpdateManyWithWhereWithoutSetting_itemsInput[]
    deleteMany?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
  }

  export type BuffingEntryUpdateManyWithoutSetting_itemsNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput> | BuffingEntryCreateWithoutSetting_itemsInput[] | BuffingEntryUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutSetting_itemsInput | BuffingEntryCreateOrConnectWithoutSetting_itemsInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutSetting_itemsInput | BuffingEntryUpsertWithWhereUniqueWithoutSetting_itemsInput[]
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutSetting_itemsInput | BuffingEntryUpdateWithWhereUniqueWithoutSetting_itemsInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutSetting_itemsInput | BuffingEntryUpdateManyWithWhereWithoutSetting_itemsInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type StockUpdateManyWithoutSettingItemNestedInput = {
    create?: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput> | StockCreateWithoutSettingItemInput[] | StockUncheckedCreateWithoutSettingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutSettingItemInput | StockCreateOrConnectWithoutSettingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutSettingItemInput | StockUpsertWithWhereUniqueWithoutSettingItemInput[]
    createMany?: StockCreateManySettingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutSettingItemInput | StockUpdateWithWhereUniqueWithoutSettingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutSettingItemInput | StockUpdateManyWithWhereWithoutSettingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput> | LotBuffingMapperCreateWithoutSettingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput | LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutSettingItemIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutSettingItemIdInput[]
    createMany?: LotBuffingMapperCreateManySettingItemIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutSettingItemIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutSettingItemIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutSettingItemIdInput | LotBuffingMapperUpdateManyWithWhereWithoutSettingItemIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput = {
    create?: XOR<SettingEntryCreateWithoutSettingItemsInput, SettingEntryUncheckedCreateWithoutSettingItemsInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingItemsInput
    upsert?: SettingEntryUpsertWithoutSettingItemsInput
    connect?: SettingEntryWhereUniqueInput
    update?: XOR<XOR<SettingEntryUpdateToOneWithWhereWithoutSettingItemsInput, SettingEntryUpdateWithoutSettingItemsInput>, SettingEntryUncheckedUpdateWithoutSettingItemsInput>
  }

  export type SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput = {
    create?: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput> | SettingWastageCreateWithoutSetting_itemsInput[] | SettingWastageUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: SettingWastageCreateOrConnectWithoutSetting_itemsInput | SettingWastageCreateOrConnectWithoutSetting_itemsInput[]
    upsert?: SettingWastageUpsertWithWhereUniqueWithoutSetting_itemsInput | SettingWastageUpsertWithWhereUniqueWithoutSetting_itemsInput[]
    set?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    disconnect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    delete?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    connect?: SettingWastageWhereUniqueInput | SettingWastageWhereUniqueInput[]
    update?: SettingWastageUpdateWithWhereUniqueWithoutSetting_itemsInput | SettingWastageUpdateWithWhereUniqueWithoutSetting_itemsInput[]
    updateMany?: SettingWastageUpdateManyWithWhereWithoutSetting_itemsInput | SettingWastageUpdateManyWithWhereWithoutSetting_itemsInput[]
    deleteMany?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
  }

  export type BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput> | BuffingEntryCreateWithoutSetting_itemsInput[] | BuffingEntryUncheckedCreateWithoutSetting_itemsInput[]
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutSetting_itemsInput | BuffingEntryCreateOrConnectWithoutSetting_itemsInput[]
    upsert?: BuffingEntryUpsertWithWhereUniqueWithoutSetting_itemsInput | BuffingEntryUpsertWithWhereUniqueWithoutSetting_itemsInput[]
    set?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    disconnect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    delete?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    connect?: BuffingEntryWhereUniqueInput | BuffingEntryWhereUniqueInput[]
    update?: BuffingEntryUpdateWithWhereUniqueWithoutSetting_itemsInput | BuffingEntryUpdateWithWhereUniqueWithoutSetting_itemsInput[]
    updateMany?: BuffingEntryUpdateManyWithWhereWithoutSetting_itemsInput | BuffingEntryUpdateManyWithWhereWithoutSetting_itemsInput[]
    deleteMany?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutSettingItemNestedInput = {
    create?: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput> | StockCreateWithoutSettingItemInput[] | StockUncheckedCreateWithoutSettingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutSettingItemInput | StockCreateOrConnectWithoutSettingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutSettingItemInput | StockUpsertWithWhereUniqueWithoutSettingItemInput[]
    createMany?: StockCreateManySettingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutSettingItemInput | StockUpdateWithWhereUniqueWithoutSettingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutSettingItemInput | StockUpdateManyWithWhereWithoutSettingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput> | LotBuffingMapperCreateWithoutSettingItemIdInput[] | LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput | LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutSettingItemIdInput | LotBuffingMapperUpsertWithWhereUniqueWithoutSettingItemIdInput[]
    createMany?: LotBuffingMapperCreateManySettingItemIdInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutSettingItemIdInput | LotBuffingMapperUpdateWithWhereUniqueWithoutSettingItemIdInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutSettingItemIdInput | LotBuffingMapperUpdateManyWithWhereWithoutSettingItemIdInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type AddSettingCreateNestedOneWithoutSettingMapperInput = {
    create?: XOR<AddSettingCreateWithoutSettingMapperInput, AddSettingUncheckedCreateWithoutSettingMapperInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutSettingMapperInput
    connect?: AddSettingWhereUniqueInput
  }

  export type LotInfoCreateNestedOneWithoutSettingMapperInput = {
    create?: XOR<LotInfoCreateWithoutSettingMapperInput, LotInfoUncheckedCreateWithoutSettingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingMapperInput
    connect?: LotInfoWhereUniqueInput
  }

  export type FilingItemsCreateNestedOneWithoutLot_setting_mapperInput = {
    create?: XOR<FilingItemsCreateWithoutLot_setting_mapperInput, FilingItemsUncheckedCreateWithoutLot_setting_mapperInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLot_setting_mapperInput
    connect?: FilingItemsWhereUniqueInput
  }

  export type SettingEntryCreateNestedOneWithoutLotSettingMapperInput = {
    create?: XOR<SettingEntryCreateWithoutLotSettingMapperInput, SettingEntryUncheckedCreateWithoutLotSettingMapperInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutLotSettingMapperInput
    connect?: SettingEntryWhereUniqueInput
  }

  export type AddSettingUpdateOneRequiredWithoutSettingMapperNestedInput = {
    create?: XOR<AddSettingCreateWithoutSettingMapperInput, AddSettingUncheckedCreateWithoutSettingMapperInput>
    connectOrCreate?: AddSettingCreateOrConnectWithoutSettingMapperInput
    upsert?: AddSettingUpsertWithoutSettingMapperInput
    connect?: AddSettingWhereUniqueInput
    update?: XOR<XOR<AddSettingUpdateToOneWithWhereWithoutSettingMapperInput, AddSettingUpdateWithoutSettingMapperInput>, AddSettingUncheckedUpdateWithoutSettingMapperInput>
  }

  export type LotInfoUpdateOneRequiredWithoutSettingMapperNestedInput = {
    create?: XOR<LotInfoCreateWithoutSettingMapperInput, LotInfoUncheckedCreateWithoutSettingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutSettingMapperInput
    upsert?: LotInfoUpsertWithoutSettingMapperInput
    connect?: LotInfoWhereUniqueInput
    update?: XOR<XOR<LotInfoUpdateToOneWithWhereWithoutSettingMapperInput, LotInfoUpdateWithoutSettingMapperInput>, LotInfoUncheckedUpdateWithoutSettingMapperInput>
  }

  export type FilingItemsUpdateOneWithoutLot_setting_mapperNestedInput = {
    create?: XOR<FilingItemsCreateWithoutLot_setting_mapperInput, FilingItemsUncheckedCreateWithoutLot_setting_mapperInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLot_setting_mapperInput
    upsert?: FilingItemsUpsertWithoutLot_setting_mapperInput
    disconnect?: FilingItemsWhereInput | boolean
    delete?: FilingItemsWhereInput | boolean
    connect?: FilingItemsWhereUniqueInput
    update?: XOR<XOR<FilingItemsUpdateToOneWithWhereWithoutLot_setting_mapperInput, FilingItemsUpdateWithoutLot_setting_mapperInput>, FilingItemsUncheckedUpdateWithoutLot_setting_mapperInput>
  }

  export type SettingEntryUpdateOneRequiredWithoutLotSettingMapperNestedInput = {
    create?: XOR<SettingEntryCreateWithoutLotSettingMapperInput, SettingEntryUncheckedCreateWithoutLotSettingMapperInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutLotSettingMapperInput
    upsert?: SettingEntryUpsertWithoutLotSettingMapperInput
    connect?: SettingEntryWhereUniqueInput
    update?: XOR<XOR<SettingEntryUpdateToOneWithWhereWithoutLotSettingMapperInput, SettingEntryUpdateWithoutLotSettingMapperInput>, SettingEntryUncheckedUpdateWithoutLotSettingMapperInput>
  }

  export type SettingEntryCreateNestedOneWithoutSettingTotalBalanceInput = {
    create?: XOR<SettingEntryCreateWithoutSettingTotalBalanceInput, SettingEntryUncheckedCreateWithoutSettingTotalBalanceInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingTotalBalanceInput
    connect?: SettingEntryWhereUniqueInput
  }

  export type SettingEntryUpdateOneRequiredWithoutSettingTotalBalanceNestedInput = {
    create?: XOR<SettingEntryCreateWithoutSettingTotalBalanceInput, SettingEntryUncheckedCreateWithoutSettingTotalBalanceInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingTotalBalanceInput
    upsert?: SettingEntryUpsertWithoutSettingTotalBalanceInput
    connect?: SettingEntryWhereUniqueInput
    update?: XOR<XOR<SettingEntryUpdateToOneWithWhereWithoutSettingTotalBalanceInput, SettingEntryUpdateWithoutSettingTotalBalanceInput>, SettingEntryUncheckedUpdateWithoutSettingTotalBalanceInput>
  }

  export type SettingItemsCreateNestedManyWithoutSetting_wastageInput = {
    create?: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput> | SettingItemsCreateWithoutSetting_wastageInput[] | SettingItemsUncheckedCreateWithoutSetting_wastageInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSetting_wastageInput | SettingItemsCreateOrConnectWithoutSetting_wastageInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type SettingEntryCreateNestedOneWithoutSettingWastageInput = {
    create?: XOR<SettingEntryCreateWithoutSettingWastageInput, SettingEntryUncheckedCreateWithoutSettingWastageInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingWastageInput
    connect?: SettingEntryWhereUniqueInput
  }

  export type SettingItemsUncheckedCreateNestedManyWithoutSetting_wastageInput = {
    create?: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput> | SettingItemsCreateWithoutSetting_wastageInput[] | SettingItemsUncheckedCreateWithoutSetting_wastageInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSetting_wastageInput | SettingItemsCreateOrConnectWithoutSetting_wastageInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type SettingItemsUpdateManyWithoutSetting_wastageNestedInput = {
    create?: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput> | SettingItemsCreateWithoutSetting_wastageInput[] | SettingItemsUncheckedCreateWithoutSetting_wastageInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSetting_wastageInput | SettingItemsCreateOrConnectWithoutSetting_wastageInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutSetting_wastageInput | SettingItemsUpsertWithWhereUniqueWithoutSetting_wastageInput[]
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutSetting_wastageInput | SettingItemsUpdateWithWhereUniqueWithoutSetting_wastageInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutSetting_wastageInput | SettingItemsUpdateManyWithWhereWithoutSetting_wastageInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type SettingEntryUpdateOneRequiredWithoutSettingWastageNestedInput = {
    create?: XOR<SettingEntryCreateWithoutSettingWastageInput, SettingEntryUncheckedCreateWithoutSettingWastageInput>
    connectOrCreate?: SettingEntryCreateOrConnectWithoutSettingWastageInput
    upsert?: SettingEntryUpsertWithoutSettingWastageInput
    connect?: SettingEntryWhereUniqueInput
    update?: XOR<XOR<SettingEntryUpdateToOneWithWhereWithoutSettingWastageInput, SettingEntryUpdateWithoutSettingWastageInput>, SettingEntryUncheckedUpdateWithoutSettingWastageInput>
  }

  export type SettingItemsUncheckedUpdateManyWithoutSetting_wastageNestedInput = {
    create?: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput> | SettingItemsCreateWithoutSetting_wastageInput[] | SettingItemsUncheckedCreateWithoutSetting_wastageInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutSetting_wastageInput | SettingItemsCreateOrConnectWithoutSetting_wastageInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutSetting_wastageInput | SettingItemsUpsertWithWhereUniqueWithoutSetting_wastageInput[]
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutSetting_wastageInput | SettingItemsUpdateWithWhereUniqueWithoutSetting_wastageInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutSetting_wastageInput | SettingItemsUpdateManyWithWhereWithoutSetting_wastageInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type AddBuffingCreateNestedOneWithoutBuffingsInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingsInput, AddBuffingUncheckedCreateWithoutBuffingsInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingsInput
    connect?: AddBuffingWhereUniqueInput
  }

  export type CastingItemsCreateNestedOneWithoutBuffingEntryInput = {
    create?: XOR<CastingItemsCreateWithoutBuffingEntryInput, CastingItemsUncheckedCreateWithoutBuffingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutBuffingEntryInput
    connect?: CastingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedManyWithoutBuffing_entryInput = {
    create?: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput> | FilingItemsCreateWithoutBuffing_entryInput[] | FilingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutBuffing_entryInput | FilingItemsCreateOrConnectWithoutBuffing_entryInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsCreateNestedManyWithoutBuffing_entryInput = {
    create?: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput> | SettingItemsCreateWithoutBuffing_entryInput[] | SettingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutBuffing_entryInput | SettingItemsCreateOrConnectWithoutBuffing_entryInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput = {
    create?: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput> | BuffingTotalBalanceCreateWithoutBuffingEntryIdInput[] | BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput | BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput[]
    createMany?: BuffingTotalBalanceCreateManyBuffingEntryIdInputEnvelope
    connect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
  }

  export type LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput> | LotBuffingMapperCreateWithoutBuffingEntryInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput | LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput[]
    createMany?: LotBuffingMapperCreateManyBuffingEntryInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput> | BuffingItemsCreateWithoutBuffingEntryIdInput[] | BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput | BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput[]
    createMany?: BuffingItemsCreateManyBuffingEntryIdInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput = {
    create?: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput> | FilingItemsCreateWithoutBuffing_entryInput[] | FilingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutBuffing_entryInput | FilingItemsCreateOrConnectWithoutBuffing_entryInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
  }

  export type SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput = {
    create?: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput> | SettingItemsCreateWithoutBuffing_entryInput[] | SettingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutBuffing_entryInput | SettingItemsCreateOrConnectWithoutBuffing_entryInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
  }

  export type BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput = {
    create?: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput> | BuffingTotalBalanceCreateWithoutBuffingEntryIdInput[] | BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput | BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput[]
    createMany?: BuffingTotalBalanceCreateManyBuffingEntryIdInputEnvelope
    connect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
  }

  export type LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput> | LotBuffingMapperCreateWithoutBuffingEntryInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput | LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput[]
    createMany?: LotBuffingMapperCreateManyBuffingEntryInputEnvelope
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
  }

  export type BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput> | BuffingItemsCreateWithoutBuffingEntryIdInput[] | BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput | BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput[]
    createMany?: BuffingItemsCreateManyBuffingEntryIdInputEnvelope
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingsInput, AddBuffingUncheckedCreateWithoutBuffingsInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingsInput
    upsert?: AddBuffingUpsertWithoutBuffingsInput
    connect?: AddBuffingWhereUniqueInput
    update?: XOR<XOR<AddBuffingUpdateToOneWithWhereWithoutBuffingsInput, AddBuffingUpdateWithoutBuffingsInput>, AddBuffingUncheckedUpdateWithoutBuffingsInput>
  }

  export type CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput = {
    create?: XOR<CastingItemsCreateWithoutBuffingEntryInput, CastingItemsUncheckedCreateWithoutBuffingEntryInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutBuffingEntryInput
    upsert?: CastingItemsUpsertWithoutBuffingEntryInput
    connect?: CastingItemsWhereUniqueInput
    update?: XOR<XOR<CastingItemsUpdateToOneWithWhereWithoutBuffingEntryInput, CastingItemsUpdateWithoutBuffingEntryInput>, CastingItemsUncheckedUpdateWithoutBuffingEntryInput>
  }

  export type FilingItemsUpdateManyWithoutBuffing_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput> | FilingItemsCreateWithoutBuffing_entryInput[] | FilingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutBuffing_entryInput | FilingItemsCreateOrConnectWithoutBuffing_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput | FilingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput | FilingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutBuffing_entryInput | FilingItemsUpdateManyWithWhereWithoutBuffing_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUpdateManyWithoutBuffing_entryNestedInput = {
    create?: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput> | SettingItemsCreateWithoutBuffing_entryInput[] | SettingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutBuffing_entryInput | SettingItemsCreateOrConnectWithoutBuffing_entryInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput | SettingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput[]
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput | SettingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutBuffing_entryInput | SettingItemsUpdateManyWithWhereWithoutBuffing_entryInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput = {
    create?: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput> | BuffingTotalBalanceCreateWithoutBuffingEntryIdInput[] | BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput | BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput[]
    upsert?: BuffingTotalBalanceUpsertWithWhereUniqueWithoutBuffingEntryIdInput | BuffingTotalBalanceUpsertWithWhereUniqueWithoutBuffingEntryIdInput[]
    createMany?: BuffingTotalBalanceCreateManyBuffingEntryIdInputEnvelope
    set?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    disconnect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    delete?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    connect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    update?: BuffingTotalBalanceUpdateWithWhereUniqueWithoutBuffingEntryIdInput | BuffingTotalBalanceUpdateWithWhereUniqueWithoutBuffingEntryIdInput[]
    updateMany?: BuffingTotalBalanceUpdateManyWithWhereWithoutBuffingEntryIdInput | BuffingTotalBalanceUpdateManyWithWhereWithoutBuffingEntryIdInput[]
    deleteMany?: BuffingTotalBalanceScalarWhereInput | BuffingTotalBalanceScalarWhereInput[]
  }

  export type LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput> | LotBuffingMapperCreateWithoutBuffingEntryInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput | LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingEntryInput | LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingEntryInput[]
    createMany?: LotBuffingMapperCreateManyBuffingEntryInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingEntryInput | LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingEntryInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutBuffingEntryInput | LotBuffingMapperUpdateManyWithWhereWithoutBuffingEntryInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput> | BuffingItemsCreateWithoutBuffingEntryIdInput[] | BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput | BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutBuffingEntryIdInput | BuffingItemsUpsertWithWhereUniqueWithoutBuffingEntryIdInput[]
    createMany?: BuffingItemsCreateManyBuffingEntryIdInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutBuffingEntryIdInput | BuffingItemsUpdateWithWhereUniqueWithoutBuffingEntryIdInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutBuffingEntryIdInput | BuffingItemsUpdateManyWithWhereWithoutBuffingEntryIdInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput = {
    create?: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput> | FilingItemsCreateWithoutBuffing_entryInput[] | FilingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: FilingItemsCreateOrConnectWithoutBuffing_entryInput | FilingItemsCreateOrConnectWithoutBuffing_entryInput[]
    upsert?: FilingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput | FilingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput[]
    set?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    disconnect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    delete?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    connect?: FilingItemsWhereUniqueInput | FilingItemsWhereUniqueInput[]
    update?: FilingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput | FilingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput[]
    updateMany?: FilingItemsUpdateManyWithWhereWithoutBuffing_entryInput | FilingItemsUpdateManyWithWhereWithoutBuffing_entryInput[]
    deleteMany?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
  }

  export type SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput = {
    create?: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput> | SettingItemsCreateWithoutBuffing_entryInput[] | SettingItemsUncheckedCreateWithoutBuffing_entryInput[]
    connectOrCreate?: SettingItemsCreateOrConnectWithoutBuffing_entryInput | SettingItemsCreateOrConnectWithoutBuffing_entryInput[]
    upsert?: SettingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput | SettingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput[]
    set?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    disconnect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    delete?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    connect?: SettingItemsWhereUniqueInput | SettingItemsWhereUniqueInput[]
    update?: SettingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput | SettingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput[]
    updateMany?: SettingItemsUpdateManyWithWhereWithoutBuffing_entryInput | SettingItemsUpdateManyWithWhereWithoutBuffing_entryInput[]
    deleteMany?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
  }

  export type BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput = {
    create?: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput> | BuffingTotalBalanceCreateWithoutBuffingEntryIdInput[] | BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput | BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput[]
    upsert?: BuffingTotalBalanceUpsertWithWhereUniqueWithoutBuffingEntryIdInput | BuffingTotalBalanceUpsertWithWhereUniqueWithoutBuffingEntryIdInput[]
    createMany?: BuffingTotalBalanceCreateManyBuffingEntryIdInputEnvelope
    set?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    disconnect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    delete?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    connect?: BuffingTotalBalanceWhereUniqueInput | BuffingTotalBalanceWhereUniqueInput[]
    update?: BuffingTotalBalanceUpdateWithWhereUniqueWithoutBuffingEntryIdInput | BuffingTotalBalanceUpdateWithWhereUniqueWithoutBuffingEntryIdInput[]
    updateMany?: BuffingTotalBalanceUpdateManyWithWhereWithoutBuffingEntryIdInput | BuffingTotalBalanceUpdateManyWithWhereWithoutBuffingEntryIdInput[]
    deleteMany?: BuffingTotalBalanceScalarWhereInput | BuffingTotalBalanceScalarWhereInput[]
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput = {
    create?: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput> | LotBuffingMapperCreateWithoutBuffingEntryInput[] | LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput[]
    connectOrCreate?: LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput | LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput[]
    upsert?: LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingEntryInput | LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingEntryInput[]
    createMany?: LotBuffingMapperCreateManyBuffingEntryInputEnvelope
    set?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    disconnect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    delete?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    connect?: LotBuffingMapperWhereUniqueInput | LotBuffingMapperWhereUniqueInput[]
    update?: LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingEntryInput | LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingEntryInput[]
    updateMany?: LotBuffingMapperUpdateManyWithWhereWithoutBuffingEntryInput | LotBuffingMapperUpdateManyWithWhereWithoutBuffingEntryInput[]
    deleteMany?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
  }

  export type BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput> | BuffingItemsCreateWithoutBuffingEntryIdInput[] | BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput | BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutBuffingEntryIdInput | BuffingItemsUpsertWithWhereUniqueWithoutBuffingEntryIdInput[]
    createMany?: BuffingItemsCreateManyBuffingEntryIdInputEnvelope
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutBuffingEntryIdInput | BuffingItemsUpdateWithWhereUniqueWithoutBuffingEntryIdInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutBuffingEntryIdInput | BuffingItemsUpdateManyWithWhereWithoutBuffingEntryIdInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type AddItemCreateNestedOneWithoutBuffing_itemsInput = {
    create?: XOR<AddItemCreateWithoutBuffing_itemsInput, AddItemUncheckedCreateWithoutBuffing_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutBuffing_itemsInput
    connect?: AddItemWhereUniqueInput
  }

  export type AddTouchCreateNestedOneWithoutBuffing_itemsInput = {
    create?: XOR<AddTouchCreateWithoutBuffing_itemsInput, AddTouchUncheckedCreateWithoutBuffing_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutBuffing_itemsInput
    connect?: AddTouchWhereUniqueInput
  }

  export type StockCreateNestedManyWithoutBuffingItemInput = {
    create?: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput> | StockCreateWithoutBuffingItemInput[] | StockUncheckedCreateWithoutBuffingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutBuffingItemInput | StockCreateOrConnectWithoutBuffingItemInput[]
    createMany?: StockCreateManyBuffingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type BuffingWastageCreateNestedManyWithoutBuffing_itemsInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput> | BuffingWastageCreateWithoutBuffing_itemsInput[] | BuffingWastageUncheckedCreateWithoutBuffing_itemsInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffing_itemsInput | BuffingWastageCreateOrConnectWithoutBuffing_itemsInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type BuffingEntryCreateNestedOneWithoutBuffingItemsInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffingItemsInput, BuffingEntryUncheckedCreateWithoutBuffingItemsInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffingItemsInput
    connect?: BuffingEntryWhereUniqueInput
  }

  export type StockUncheckedCreateNestedManyWithoutBuffingItemInput = {
    create?: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput> | StockCreateWithoutBuffingItemInput[] | StockUncheckedCreateWithoutBuffingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutBuffingItemInput | StockCreateOrConnectWithoutBuffingItemInput[]
    createMany?: StockCreateManyBuffingItemInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput> | BuffingWastageCreateWithoutBuffing_itemsInput[] | BuffingWastageUncheckedCreateWithoutBuffing_itemsInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffing_itemsInput | BuffingWastageCreateOrConnectWithoutBuffing_itemsInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
  }

  export type AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput = {
    create?: XOR<AddItemCreateWithoutBuffing_itemsInput, AddItemUncheckedCreateWithoutBuffing_itemsInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutBuffing_itemsInput
    upsert?: AddItemUpsertWithoutBuffing_itemsInput
    connect?: AddItemWhereUniqueInput
    update?: XOR<XOR<AddItemUpdateToOneWithWhereWithoutBuffing_itemsInput, AddItemUpdateWithoutBuffing_itemsInput>, AddItemUncheckedUpdateWithoutBuffing_itemsInput>
  }

  export type AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput = {
    create?: XOR<AddTouchCreateWithoutBuffing_itemsInput, AddTouchUncheckedCreateWithoutBuffing_itemsInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutBuffing_itemsInput
    upsert?: AddTouchUpsertWithoutBuffing_itemsInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutBuffing_itemsInput, AddTouchUpdateWithoutBuffing_itemsInput>, AddTouchUncheckedUpdateWithoutBuffing_itemsInput>
  }

  export type StockUpdateManyWithoutBuffingItemNestedInput = {
    create?: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput> | StockCreateWithoutBuffingItemInput[] | StockUncheckedCreateWithoutBuffingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutBuffingItemInput | StockCreateOrConnectWithoutBuffingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutBuffingItemInput | StockUpsertWithWhereUniqueWithoutBuffingItemInput[]
    createMany?: StockCreateManyBuffingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutBuffingItemInput | StockUpdateWithWhereUniqueWithoutBuffingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutBuffingItemInput | StockUpdateManyWithWhereWithoutBuffingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput> | BuffingWastageCreateWithoutBuffing_itemsInput[] | BuffingWastageUncheckedCreateWithoutBuffing_itemsInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffing_itemsInput | BuffingWastageCreateOrConnectWithoutBuffing_itemsInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffing_itemsInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffing_itemsInput[]
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffing_itemsInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffing_itemsInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffing_itemsInput | BuffingWastageUpdateManyWithWhereWithoutBuffing_itemsInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffingItemsInput, BuffingEntryUncheckedCreateWithoutBuffingItemsInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffingItemsInput
    upsert?: BuffingEntryUpsertWithoutBuffingItemsInput
    connect?: BuffingEntryWhereUniqueInput
    update?: XOR<XOR<BuffingEntryUpdateToOneWithWhereWithoutBuffingItemsInput, BuffingEntryUpdateWithoutBuffingItemsInput>, BuffingEntryUncheckedUpdateWithoutBuffingItemsInput>
  }

  export type StockUncheckedUpdateManyWithoutBuffingItemNestedInput = {
    create?: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput> | StockCreateWithoutBuffingItemInput[] | StockUncheckedCreateWithoutBuffingItemInput[]
    connectOrCreate?: StockCreateOrConnectWithoutBuffingItemInput | StockCreateOrConnectWithoutBuffingItemInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutBuffingItemInput | StockUpsertWithWhereUniqueWithoutBuffingItemInput[]
    createMany?: StockCreateManyBuffingItemInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutBuffingItemInput | StockUpdateWithWhereUniqueWithoutBuffingItemInput[]
    updateMany?: StockUpdateManyWithWhereWithoutBuffingItemInput | StockUpdateManyWithWhereWithoutBuffingItemInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput = {
    create?: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput> | BuffingWastageCreateWithoutBuffing_itemsInput[] | BuffingWastageUncheckedCreateWithoutBuffing_itemsInput[]
    connectOrCreate?: BuffingWastageCreateOrConnectWithoutBuffing_itemsInput | BuffingWastageCreateOrConnectWithoutBuffing_itemsInput[]
    upsert?: BuffingWastageUpsertWithWhereUniqueWithoutBuffing_itemsInput | BuffingWastageUpsertWithWhereUniqueWithoutBuffing_itemsInput[]
    set?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    disconnect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    delete?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    connect?: BuffingWastageWhereUniqueInput | BuffingWastageWhereUniqueInput[]
    update?: BuffingWastageUpdateWithWhereUniqueWithoutBuffing_itemsInput | BuffingWastageUpdateWithWhereUniqueWithoutBuffing_itemsInput[]
    updateMany?: BuffingWastageUpdateManyWithWhereWithoutBuffing_itemsInput | BuffingWastageUpdateManyWithWhereWithoutBuffing_itemsInput[]
    deleteMany?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
  }

  export type BuffingEntryCreateNestedOneWithoutBuffingTotalBalanceInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedCreateWithoutBuffingTotalBalanceInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffingTotalBalanceInput
    connect?: BuffingEntryWhereUniqueInput
  }

  export type BuffingEntryUpdateOneRequiredWithoutBuffingTotalBalanceNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedCreateWithoutBuffingTotalBalanceInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutBuffingTotalBalanceInput
    upsert?: BuffingEntryUpsertWithoutBuffingTotalBalanceInput
    connect?: BuffingEntryWhereUniqueInput
    update?: XOR<XOR<BuffingEntryUpdateToOneWithWhereWithoutBuffingTotalBalanceInput, BuffingEntryUpdateWithoutBuffingTotalBalanceInput>, BuffingEntryUncheckedUpdateWithoutBuffingTotalBalanceInput>
  }

  export type AddBuffingCreateNestedOneWithoutBuffingMapperInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingMapperInput, AddBuffingUncheckedCreateWithoutBuffingMapperInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingMapperInput
    connect?: AddBuffingWhereUniqueInput
  }

  export type LotInfoCreateNestedOneWithoutBuffingMapperInput = {
    create?: XOR<LotInfoCreateWithoutBuffingMapperInput, LotInfoUncheckedCreateWithoutBuffingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingMapperInput
    connect?: LotInfoWhereUniqueInput
  }

  export type SettingItemsCreateNestedOneWithoutLotBuffingMapperInput = {
    create?: XOR<SettingItemsCreateWithoutLotBuffingMapperInput, SettingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: SettingItemsCreateOrConnectWithoutLotBuffingMapperInput
    connect?: SettingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedOneWithoutLotBuffingMapperInput = {
    create?: XOR<FilingItemsCreateWithoutLotBuffingMapperInput, FilingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotBuffingMapperInput
    connect?: FilingItemsWhereUniqueInput
  }

  export type BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput = {
    create?: XOR<BuffingEntryCreateWithoutLotBuffingMapperInput, BuffingEntryUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutLotBuffingMapperInput
    connect?: BuffingEntryWhereUniqueInput
  }

  export type AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingMapperInput, AddBuffingUncheckedCreateWithoutBuffingMapperInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingMapperInput
    upsert?: AddBuffingUpsertWithoutBuffingMapperInput
    connect?: AddBuffingWhereUniqueInput
    update?: XOR<XOR<AddBuffingUpdateToOneWithWhereWithoutBuffingMapperInput, AddBuffingUpdateWithoutBuffingMapperInput>, AddBuffingUncheckedUpdateWithoutBuffingMapperInput>
  }

  export type LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput = {
    create?: XOR<LotInfoCreateWithoutBuffingMapperInput, LotInfoUncheckedCreateWithoutBuffingMapperInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingMapperInput
    upsert?: LotInfoUpsertWithoutBuffingMapperInput
    connect?: LotInfoWhereUniqueInput
    update?: XOR<XOR<LotInfoUpdateToOneWithWhereWithoutBuffingMapperInput, LotInfoUpdateWithoutBuffingMapperInput>, LotInfoUncheckedUpdateWithoutBuffingMapperInput>
  }

  export type SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput = {
    create?: XOR<SettingItemsCreateWithoutLotBuffingMapperInput, SettingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: SettingItemsCreateOrConnectWithoutLotBuffingMapperInput
    upsert?: SettingItemsUpsertWithoutLotBuffingMapperInput
    disconnect?: SettingItemsWhereInput | boolean
    delete?: SettingItemsWhereInput | boolean
    connect?: SettingItemsWhereUniqueInput
    update?: XOR<XOR<SettingItemsUpdateToOneWithWhereWithoutLotBuffingMapperInput, SettingItemsUpdateWithoutLotBuffingMapperInput>, SettingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput = {
    create?: XOR<FilingItemsCreateWithoutLotBuffingMapperInput, FilingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutLotBuffingMapperInput
    upsert?: FilingItemsUpsertWithoutLotBuffingMapperInput
    disconnect?: FilingItemsWhereInput | boolean
    delete?: FilingItemsWhereInput | boolean
    connect?: FilingItemsWhereUniqueInput
    update?: XOR<XOR<FilingItemsUpdateToOneWithWhereWithoutLotBuffingMapperInput, FilingItemsUpdateWithoutLotBuffingMapperInput>, FilingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput = {
    create?: XOR<BuffingEntryCreateWithoutLotBuffingMapperInput, BuffingEntryUncheckedCreateWithoutLotBuffingMapperInput>
    connectOrCreate?: BuffingEntryCreateOrConnectWithoutLotBuffingMapperInput
    upsert?: BuffingEntryUpsertWithoutLotBuffingMapperInput
    connect?: BuffingEntryWhereUniqueInput
    update?: XOR<XOR<BuffingEntryUpdateToOneWithWhereWithoutLotBuffingMapperInput, BuffingEntryUpdateWithoutLotBuffingMapperInput>, BuffingEntryUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type AddBuffingCreateNestedOneWithoutBuffingWastagesInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingWastagesInput, AddBuffingUncheckedCreateWithoutBuffingWastagesInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingWastagesInput
    connect?: AddBuffingWhereUniqueInput
  }

  export type LotInfoCreateNestedOneWithoutBuffingWastagesInput = {
    create?: XOR<LotInfoCreateWithoutBuffingWastagesInput, LotInfoUncheckedCreateWithoutBuffingWastagesInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingWastagesInput
    connect?: LotInfoWhereUniqueInput
  }

  export type BuffingItemsCreateNestedManyWithoutBuffing_wastageInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput> | BuffingItemsCreateWithoutBuffing_wastageInput[] | BuffingItemsUncheckedCreateWithoutBuffing_wastageInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffing_wastageInput | BuffingItemsCreateOrConnectWithoutBuffing_wastageInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type BuffingItemsUncheckedCreateNestedManyWithoutBuffing_wastageInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput> | BuffingItemsCreateWithoutBuffing_wastageInput[] | BuffingItemsUncheckedCreateWithoutBuffing_wastageInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffing_wastageInput | BuffingItemsCreateOrConnectWithoutBuffing_wastageInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
  }

  export type AddBuffingUpdateOneWithoutBuffingWastagesNestedInput = {
    create?: XOR<AddBuffingCreateWithoutBuffingWastagesInput, AddBuffingUncheckedCreateWithoutBuffingWastagesInput>
    connectOrCreate?: AddBuffingCreateOrConnectWithoutBuffingWastagesInput
    upsert?: AddBuffingUpsertWithoutBuffingWastagesInput
    disconnect?: AddBuffingWhereInput | boolean
    delete?: AddBuffingWhereInput | boolean
    connect?: AddBuffingWhereUniqueInput
    update?: XOR<XOR<AddBuffingUpdateToOneWithWhereWithoutBuffingWastagesInput, AddBuffingUpdateWithoutBuffingWastagesInput>, AddBuffingUncheckedUpdateWithoutBuffingWastagesInput>
  }

  export type LotInfoUpdateOneWithoutBuffingWastagesNestedInput = {
    create?: XOR<LotInfoCreateWithoutBuffingWastagesInput, LotInfoUncheckedCreateWithoutBuffingWastagesInput>
    connectOrCreate?: LotInfoCreateOrConnectWithoutBuffingWastagesInput
    upsert?: LotInfoUpsertWithoutBuffingWastagesInput
    disconnect?: LotInfoWhereInput | boolean
    delete?: LotInfoWhereInput | boolean
    connect?: LotInfoWhereUniqueInput
    update?: XOR<XOR<LotInfoUpdateToOneWithWhereWithoutBuffingWastagesInput, LotInfoUpdateWithoutBuffingWastagesInput>, LotInfoUncheckedUpdateWithoutBuffingWastagesInput>
  }

  export type BuffingItemsUpdateManyWithoutBuffing_wastageNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput> | BuffingItemsCreateWithoutBuffing_wastageInput[] | BuffingItemsUncheckedCreateWithoutBuffing_wastageInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffing_wastageInput | BuffingItemsCreateOrConnectWithoutBuffing_wastageInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutBuffing_wastageInput | BuffingItemsUpsertWithWhereUniqueWithoutBuffing_wastageInput[]
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutBuffing_wastageInput | BuffingItemsUpdateWithWhereUniqueWithoutBuffing_wastageInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutBuffing_wastageInput | BuffingItemsUpdateManyWithWhereWithoutBuffing_wastageInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput> | BuffingItemsCreateWithoutBuffing_wastageInput[] | BuffingItemsUncheckedCreateWithoutBuffing_wastageInput[]
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutBuffing_wastageInput | BuffingItemsCreateOrConnectWithoutBuffing_wastageInput[]
    upsert?: BuffingItemsUpsertWithWhereUniqueWithoutBuffing_wastageInput | BuffingItemsUpsertWithWhereUniqueWithoutBuffing_wastageInput[]
    set?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    disconnect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    delete?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    connect?: BuffingItemsWhereUniqueInput | BuffingItemsWhereUniqueInput[]
    update?: BuffingItemsUpdateWithWhereUniqueWithoutBuffing_wastageInput | BuffingItemsUpdateWithWhereUniqueWithoutBuffing_wastageInput[]
    updateMany?: BuffingItemsUpdateManyWithWhereWithoutBuffing_wastageInput | BuffingItemsUpdateManyWithWhereWithoutBuffing_wastageInput[]
    deleteMany?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
  }

  export type CastingItemsCreateNestedOneWithoutStockInput = {
    create?: XOR<CastingItemsCreateWithoutStockInput, CastingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutStockInput
    connect?: CastingItemsWhereUniqueInput
  }

  export type FilingItemsCreateNestedOneWithoutStockInput = {
    create?: XOR<FilingItemsCreateWithoutStockInput, FilingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutStockInput
    connect?: FilingItemsWhereUniqueInput
  }

  export type SettingItemsCreateNestedOneWithoutStockInput = {
    create?: XOR<SettingItemsCreateWithoutStockInput, SettingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: SettingItemsCreateOrConnectWithoutStockInput
    connect?: SettingItemsWhereUniqueInput
  }

  export type BuffingItemsCreateNestedOneWithoutStockInput = {
    create?: XOR<BuffingItemsCreateWithoutStockInput, BuffingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutStockInput
    connect?: BuffingItemsWhereUniqueInput
  }

  export type AddItemCreateNestedOneWithoutStockInput = {
    create?: XOR<AddItemCreateWithoutStockInput, AddItemUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutStockInput
    connect?: AddItemWhereUniqueInput
  }

  export type AddTouchCreateNestedOneWithoutStockInput = {
    create?: XOR<AddTouchCreateWithoutStockInput, AddTouchUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutStockInput
    connect?: AddTouchWhereUniqueInput
  }

  export type AddCastingCreateNestedOneWithoutStockInput = {
    create?: XOR<AddCastingCreateWithoutStockInput, AddCastingUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutStockInput
    connect?: AddCastingWhereUniqueInput
  }

  export type CastingItemsUpdateOneWithoutStockNestedInput = {
    create?: XOR<CastingItemsCreateWithoutStockInput, CastingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: CastingItemsCreateOrConnectWithoutStockInput
    upsert?: CastingItemsUpsertWithoutStockInput
    disconnect?: CastingItemsWhereInput | boolean
    delete?: CastingItemsWhereInput | boolean
    connect?: CastingItemsWhereUniqueInput
    update?: XOR<XOR<CastingItemsUpdateToOneWithWhereWithoutStockInput, CastingItemsUpdateWithoutStockInput>, CastingItemsUncheckedUpdateWithoutStockInput>
  }

  export type FilingItemsUpdateOneWithoutStockNestedInput = {
    create?: XOR<FilingItemsCreateWithoutStockInput, FilingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: FilingItemsCreateOrConnectWithoutStockInput
    upsert?: FilingItemsUpsertWithoutStockInput
    disconnect?: FilingItemsWhereInput | boolean
    delete?: FilingItemsWhereInput | boolean
    connect?: FilingItemsWhereUniqueInput
    update?: XOR<XOR<FilingItemsUpdateToOneWithWhereWithoutStockInput, FilingItemsUpdateWithoutStockInput>, FilingItemsUncheckedUpdateWithoutStockInput>
  }

  export type SettingItemsUpdateOneWithoutStockNestedInput = {
    create?: XOR<SettingItemsCreateWithoutStockInput, SettingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: SettingItemsCreateOrConnectWithoutStockInput
    upsert?: SettingItemsUpsertWithoutStockInput
    disconnect?: SettingItemsWhereInput | boolean
    delete?: SettingItemsWhereInput | boolean
    connect?: SettingItemsWhereUniqueInput
    update?: XOR<XOR<SettingItemsUpdateToOneWithWhereWithoutStockInput, SettingItemsUpdateWithoutStockInput>, SettingItemsUncheckedUpdateWithoutStockInput>
  }

  export type BuffingItemsUpdateOneWithoutStockNestedInput = {
    create?: XOR<BuffingItemsCreateWithoutStockInput, BuffingItemsUncheckedCreateWithoutStockInput>
    connectOrCreate?: BuffingItemsCreateOrConnectWithoutStockInput
    upsert?: BuffingItemsUpsertWithoutStockInput
    disconnect?: BuffingItemsWhereInput | boolean
    delete?: BuffingItemsWhereInput | boolean
    connect?: BuffingItemsWhereUniqueInput
    update?: XOR<XOR<BuffingItemsUpdateToOneWithWhereWithoutStockInput, BuffingItemsUpdateWithoutStockInput>, BuffingItemsUncheckedUpdateWithoutStockInput>
  }

  export type AddItemUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<AddItemCreateWithoutStockInput, AddItemUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddItemCreateOrConnectWithoutStockInput
    upsert?: AddItemUpsertWithoutStockInput
    connect?: AddItemWhereUniqueInput
    update?: XOR<XOR<AddItemUpdateToOneWithWhereWithoutStockInput, AddItemUpdateWithoutStockInput>, AddItemUncheckedUpdateWithoutStockInput>
  }

  export type AddTouchUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<AddTouchCreateWithoutStockInput, AddTouchUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddTouchCreateOrConnectWithoutStockInput
    upsert?: AddTouchUpsertWithoutStockInput
    connect?: AddTouchWhereUniqueInput
    update?: XOR<XOR<AddTouchUpdateToOneWithWhereWithoutStockInput, AddTouchUpdateWithoutStockInput>, AddTouchUncheckedUpdateWithoutStockInput>
  }

  export type AddCastingUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<AddCastingCreateWithoutStockInput, AddCastingUncheckedCreateWithoutStockInput>
    connectOrCreate?: AddCastingCreateOrConnectWithoutStockInput
    upsert?: AddCastingUpsertWithoutStockInput
    connect?: AddCastingWhereUniqueInput
    update?: XOR<XOR<AddCastingUpdateToOneWithWhereWithoutStockInput, AddCastingUpdateWithoutStockInput>, AddCastingUncheckedUpdateWithoutStockInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumITEMTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.ITEMTYPE | EnumITEMTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.ITEMTYPE[]
    notIn?: $Enums.ITEMTYPE[]
    not?: NestedEnumITEMTYPEFilter<$PrismaModel> | $Enums.ITEMTYPE
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumITEMTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITEMTYPE | EnumITEMTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.ITEMTYPE[]
    notIn?: $Enums.ITEMTYPE[]
    not?: NestedEnumITEMTYPEWithAggregatesFilter<$PrismaModel> | $Enums.ITEMTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITEMTYPEFilter<$PrismaModel>
    _max?: NestedEnumITEMTYPEFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.CASTINGENTRYTYPE[]
    notIn?: $Enums.CASTINGENTRYTYPE[]
    not?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE
  }

  export type NestedEnumCASTINGENTRYTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.CASTINGENTRYTYPE[]
    notIn?: $Enums.CASTINGENTRYTYPE[]
    not?: NestedEnumCASTINGENTRYTYPEWithAggregatesFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel>
    _max?: NestedEnumCASTINGENTRYTYPEFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSTONEOPTIONNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.STONEOPTION | EnumSTONEOPTIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.STONEOPTION[] | null
    notIn?: $Enums.STONEOPTION[] | null
    not?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel> | $Enums.STONEOPTION | null
  }

  export type NestedEnumSTONEOPTIONNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STONEOPTION | EnumSTONEOPTIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.STONEOPTION[] | null
    notIn?: $Enums.STONEOPTION[] | null
    not?: NestedEnumSTONEOPTIONNullableWithAggregatesFilter<$PrismaModel> | $Enums.STONEOPTION | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel>
    _max?: NestedEnumSTONEOPTIONNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel> | null
    in?: $Enums.CASTINGENTRYTYPE[] | null
    notIn?: $Enums.CASTINGENTRYTYPE[] | null
    not?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE | null
  }

  export type NestedEnumCASTINGENTRYTYPENullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CASTINGENTRYTYPE | EnumCASTINGENTRYTYPEFieldRefInput<$PrismaModel> | null
    in?: $Enums.CASTINGENTRYTYPE[] | null
    notIn?: $Enums.CASTINGENTRYTYPE[] | null
    not?: NestedEnumCASTINGENTRYTYPENullableWithAggregatesFilter<$PrismaModel> | $Enums.CASTINGENTRYTYPE | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel>
    _max?: NestedEnumCASTINGENTRYTYPENullableFilter<$PrismaModel>
  }

  export type CustomerTransactionCreateWithoutCustomerInput = {
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
  }

  export type CustomerTransactionUncheckedCreateWithoutCustomerInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
  }

  export type CustomerTransactionCreateOrConnectWithoutCustomerInput = {
    where: CustomerTransactionWhereUniqueInput
    create: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerTransactionCreateManyCustomerInputEnvelope = {
    data: CustomerTransactionCreateManyCustomerInput | CustomerTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerTransactionWhereUniqueInput
    update: XOR<CustomerTransactionUpdateWithoutCustomerInput, CustomerTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerTransactionCreateWithoutCustomerInput, CustomerTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerTransactionWhereUniqueInput
    data: XOR<CustomerTransactionUpdateWithoutCustomerInput, CustomerTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerTransactionScalarWhereInput
    data: XOR<CustomerTransactionUpdateManyMutationInput, CustomerTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerTransactionScalarWhereInput = {
    AND?: CustomerTransactionScalarWhereInput | CustomerTransactionScalarWhereInput[]
    OR?: CustomerTransactionScalarWhereInput[]
    NOT?: CustomerTransactionScalarWhereInput | CustomerTransactionScalarWhereInput[]
    id?: IntFilter<"CustomerTransaction"> | number
    createdAt?: DateTimeFilter<"CustomerTransaction"> | Date | string
    date?: DateTimeFilter<"CustomerTransaction"> | Date | string
    value?: FloatFilter<"CustomerTransaction"> | number
    type?: StringFilter<"CustomerTransaction"> | string
    touch?: FloatNullableFilter<"CustomerTransaction"> | number | null
    purity?: FloatNullableFilter<"CustomerTransaction"> | number | null
    goldRate?: FloatNullableFilter<"CustomerTransaction"> | number | null
    customerId?: IntFilter<"CustomerTransaction"> | number
  }

  export type CastingEntryCreateWithoutCasting_customerInput = {
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    touch: AddTouchCreateNestedOneWithoutCasting_entryInput
    items?: CastingItemsCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryUncheckedCreateWithoutCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    items?: CastingItemsUncheckedCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryCreateOrConnectWithoutCasting_customerInput = {
    where: CastingEntryWhereUniqueInput
    create: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput>
  }

  export type CastingEntryCreateManyCasting_customerInputEnvelope = {
    data: CastingEntryCreateManyCasting_customerInput | CastingEntryCreateManyCasting_customerInput[]
    skipDuplicates?: boolean
  }

  export type CastingItemsCreateWithoutCasting_customerInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsUncheckedCreateWithoutCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutCasting_customerInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput>
  }

  export type CastingItemsCreateManyCasting_customerInputEnvelope = {
    data: CastingItemsCreateManyCasting_customerInput | CastingItemsCreateManyCasting_customerInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutCasting_customerInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
  }

  export type StockCreateOrConnectWithoutCasting_customerInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput>
  }

  export type StockCreateManyCasting_customerInputEnvelope = {
    data: StockCreateManyCasting_customerInput | StockCreateManyCasting_customerInput[]
    skipDuplicates?: boolean
  }

  export type CastingEntryUpsertWithWhereUniqueWithoutCasting_customerInput = {
    where: CastingEntryWhereUniqueInput
    update: XOR<CastingEntryUpdateWithoutCasting_customerInput, CastingEntryUncheckedUpdateWithoutCasting_customerInput>
    create: XOR<CastingEntryCreateWithoutCasting_customerInput, CastingEntryUncheckedCreateWithoutCasting_customerInput>
  }

  export type CastingEntryUpdateWithWhereUniqueWithoutCasting_customerInput = {
    where: CastingEntryWhereUniqueInput
    data: XOR<CastingEntryUpdateWithoutCasting_customerInput, CastingEntryUncheckedUpdateWithoutCasting_customerInput>
  }

  export type CastingEntryUpdateManyWithWhereWithoutCasting_customerInput = {
    where: CastingEntryScalarWhereInput
    data: XOR<CastingEntryUpdateManyMutationInput, CastingEntryUncheckedUpdateManyWithoutCasting_customerInput>
  }

  export type CastingEntryScalarWhereInput = {
    AND?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
    OR?: CastingEntryScalarWhereInput[]
    NOT?: CastingEntryScalarWhereInput | CastingEntryScalarWhereInput[]
    id?: IntFilter<"CastingEntry"> | number
    createdAt?: DateTimeFilter<"CastingEntry"> | Date | string
    date?: DateTimeFilter<"CastingEntry"> | Date | string
    given_gold?: FloatFilter<"CastingEntry"> | number
    touch_id?: IntFilter<"CastingEntry"> | number
    purity?: FloatFilter<"CastingEntry"> | number
    final_touch?: FloatFilter<"CastingEntry"> | number
    pure_value?: FloatFilter<"CastingEntry"> | number
    copper?: FloatFilter<"CastingEntry"> | number
    final_weight?: FloatFilter<"CastingEntry"> | number
    casting_customer_id?: IntFilter<"CastingEntry"> | number
  }

  export type CastingItemsUpsertWithWhereUniqueWithoutCasting_customerInput = {
    where: CastingItemsWhereUniqueInput
    update: XOR<CastingItemsUpdateWithoutCasting_customerInput, CastingItemsUncheckedUpdateWithoutCasting_customerInput>
    create: XOR<CastingItemsCreateWithoutCasting_customerInput, CastingItemsUncheckedCreateWithoutCasting_customerInput>
  }

  export type CastingItemsUpdateWithWhereUniqueWithoutCasting_customerInput = {
    where: CastingItemsWhereUniqueInput
    data: XOR<CastingItemsUpdateWithoutCasting_customerInput, CastingItemsUncheckedUpdateWithoutCasting_customerInput>
  }

  export type CastingItemsUpdateManyWithWhereWithoutCasting_customerInput = {
    where: CastingItemsScalarWhereInput
    data: XOR<CastingItemsUpdateManyMutationInput, CastingItemsUncheckedUpdateManyWithoutCasting_customerInput>
  }

  export type CastingItemsScalarWhereInput = {
    AND?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
    OR?: CastingItemsScalarWhereInput[]
    NOT?: CastingItemsScalarWhereInput | CastingItemsScalarWhereInput[]
    id?: IntFilter<"CastingItems"> | number
    createdAt?: DateTimeFilter<"CastingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"CastingItems"> | $Enums.CASTINGENTRYTYPE
    item_id?: IntFilter<"CastingItems"> | number
    weight?: FloatFilter<"CastingItems"> | number
    touch_id?: IntFilter<"CastingItems"> | number
    item_purity?: FloatFilter<"CastingItems"> | number
    remarks?: StringNullableFilter<"CastingItems"> | string | null
    casting_entry_id?: IntFilter<"CastingItems"> | number
    casting_customer_id?: IntFilter<"CastingItems"> | number
  }

  export type StockUpsertWithWhereUniqueWithoutCasting_customerInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutCasting_customerInput, StockUncheckedUpdateWithoutCasting_customerInput>
    create: XOR<StockCreateWithoutCasting_customerInput, StockUncheckedCreateWithoutCasting_customerInput>
  }

  export type StockUpdateWithWhereUniqueWithoutCasting_customerInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutCasting_customerInput, StockUncheckedUpdateWithoutCasting_customerInput>
  }

  export type StockUpdateManyWithWhereWithoutCasting_customerInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutCasting_customerInput>
  }

  export type StockScalarWhereInput = {
    AND?: StockScalarWhereInput | StockScalarWhereInput[]
    OR?: StockScalarWhereInput[]
    NOT?: StockScalarWhereInput | StockScalarWhereInput[]
    id?: IntFilter<"Stock"> | number
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    casting_item_id?: IntNullableFilter<"Stock"> | number | null
    filing_item_id?: IntNullableFilter<"Stock"> | number | null
    setting_item_id?: IntNullableFilter<"Stock"> | number | null
    buffing_item_id?: IntNullableFilter<"Stock"> | number | null
    item_id?: IntFilter<"Stock"> | number
    weight?: FloatFilter<"Stock"> | number
    touch_id?: IntFilter<"Stock"> | number
    item_purity?: FloatFilter<"Stock"> | number
    remarks?: StringNullableFilter<"Stock"> | string | null
    casting_customer_id?: IntFilter<"Stock"> | number
  }

  export type FilingWastageCreateWithoutFilingPersonIdInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filingLotId?: LotInfoCreateNestedOneWithoutFilingWastagesInput
    filing_items?: FilingItemsCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageUncheckedCreateWithoutFilingPersonIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_lot_id?: number | null
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageCreateOrConnectWithoutFilingPersonIdInput = {
    where: FilingWastageWhereUniqueInput
    create: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput>
  }

  export type FilingWastageCreateManyFilingPersonIdInputEnvelope = {
    data: FilingWastageCreateManyFilingPersonIdInput | FilingWastageCreateManyFilingPersonIdInput[]
    skipDuplicates?: boolean
  }

  export type FilingEntryCreateWithoutFiling_personInput = {
    createdAt?: Date | string
    castingItem: CastingItemsCreateNestedOneWithoutFilingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUncheckedCreateWithoutFiling_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryCreateOrConnectWithoutFiling_personInput = {
    where: FilingEntryWhereUniqueInput
    create: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput>
  }

  export type FilingEntryCreateManyFiling_personInputEnvelope = {
    data: FilingEntryCreateManyFiling_personInput | FilingEntryCreateManyFiling_personInput[]
    skipDuplicates?: boolean
  }

  export type LotInfoCreateWithoutFilingCustomerIdInput = {
    lotNumber: number
    IsActive?: boolean
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutFilingCustomerIdInput = {
    id?: number
    lotNumber: number
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutFilingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput>
  }

  export type LotInfoCreateManyFilingCustomerIdInputEnvelope = {
    data: LotInfoCreateManyFilingCustomerIdInput | LotInfoCreateManyFilingCustomerIdInput[]
    skipDuplicates?: boolean
  }

  export type LotFilingMapperCreateWithoutFilingIdInput = {
    lotId: LotInfoCreateNestedOneWithoutFilingMapperInput
    itemId: CastingItemsCreateNestedOneWithoutFilingLotMapperInput
    filing_items?: FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput
    filingEntry: FilingEntryCreateNestedOneWithoutLotFilingMapperInput
  }

  export type LotFilingMapperUncheckedCreateWithoutFilingIdInput = {
    id?: number
    lot_id: number
    item_id: number
    filing_entry_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperCreateOrConnectWithoutFilingIdInput = {
    where: LotFilingMapperWhereUniqueInput
    create: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput>
  }

  export type LotFilingMapperCreateManyFilingIdInputEnvelope = {
    data: LotFilingMapperCreateManyFilingIdInput | LotFilingMapperCreateManyFilingIdInput[]
    skipDuplicates?: boolean
  }

  export type FilingWastageUpsertWithWhereUniqueWithoutFilingPersonIdInput = {
    where: FilingWastageWhereUniqueInput
    update: XOR<FilingWastageUpdateWithoutFilingPersonIdInput, FilingWastageUncheckedUpdateWithoutFilingPersonIdInput>
    create: XOR<FilingWastageCreateWithoutFilingPersonIdInput, FilingWastageUncheckedCreateWithoutFilingPersonIdInput>
  }

  export type FilingWastageUpdateWithWhereUniqueWithoutFilingPersonIdInput = {
    where: FilingWastageWhereUniqueInput
    data: XOR<FilingWastageUpdateWithoutFilingPersonIdInput, FilingWastageUncheckedUpdateWithoutFilingPersonIdInput>
  }

  export type FilingWastageUpdateManyWithWhereWithoutFilingPersonIdInput = {
    where: FilingWastageScalarWhereInput
    data: XOR<FilingWastageUpdateManyMutationInput, FilingWastageUncheckedUpdateManyWithoutFilingPersonIdInput>
  }

  export type FilingWastageScalarWhereInput = {
    AND?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
    OR?: FilingWastageScalarWhereInput[]
    NOT?: FilingWastageScalarWhereInput | FilingWastageScalarWhereInput[]
    id?: IntFilter<"FilingWastage"> | number
    createdAt?: DateTimeFilter<"FilingWastage"> | Date | string
    total_receipt?: FloatFilter<"FilingWastage"> | number
    total_wastage?: FloatFilter<"FilingWastage"> | number
    balance?: FloatFilter<"FilingWastage"> | number
    wastage_percentage?: IntFilter<"FilingWastage"> | number
    given_gold?: FloatNullableFilter<"FilingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"FilingWastage"> | number | null
    overall_wastage?: FloatFilter<"FilingWastage"> | number
    closing_balance?: FloatFilter<"FilingWastage"> | number
    opening_balance?: FloatFilter<"FilingWastage"> | number
    filing_person_id?: IntNullableFilter<"FilingWastage"> | number | null
    filing_lot_id?: IntNullableFilter<"FilingWastage"> | number | null
  }

  export type FilingEntryUpsertWithWhereUniqueWithoutFiling_personInput = {
    where: FilingEntryWhereUniqueInput
    update: XOR<FilingEntryUpdateWithoutFiling_personInput, FilingEntryUncheckedUpdateWithoutFiling_personInput>
    create: XOR<FilingEntryCreateWithoutFiling_personInput, FilingEntryUncheckedCreateWithoutFiling_personInput>
  }

  export type FilingEntryUpdateWithWhereUniqueWithoutFiling_personInput = {
    where: FilingEntryWhereUniqueInput
    data: XOR<FilingEntryUpdateWithoutFiling_personInput, FilingEntryUncheckedUpdateWithoutFiling_personInput>
  }

  export type FilingEntryUpdateManyWithWhereWithoutFiling_personInput = {
    where: FilingEntryScalarWhereInput
    data: XOR<FilingEntryUpdateManyMutationInput, FilingEntryUncheckedUpdateManyWithoutFiling_personInput>
  }

  export type FilingEntryScalarWhereInput = {
    AND?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
    OR?: FilingEntryScalarWhereInput[]
    NOT?: FilingEntryScalarWhereInput | FilingEntryScalarWhereInput[]
    id?: IntFilter<"FilingEntry"> | number
    createdAt?: DateTimeFilter<"FilingEntry"> | Date | string
    filing_person_id?: IntFilter<"FilingEntry"> | number
    casting_item_id?: IntFilter<"FilingEntry"> | number
  }

  export type LotInfoUpsertWithWhereUniqueWithoutFilingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    update: XOR<LotInfoUpdateWithoutFilingCustomerIdInput, LotInfoUncheckedUpdateWithoutFilingCustomerIdInput>
    create: XOR<LotInfoCreateWithoutFilingCustomerIdInput, LotInfoUncheckedCreateWithoutFilingCustomerIdInput>
  }

  export type LotInfoUpdateWithWhereUniqueWithoutFilingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    data: XOR<LotInfoUpdateWithoutFilingCustomerIdInput, LotInfoUncheckedUpdateWithoutFilingCustomerIdInput>
  }

  export type LotInfoUpdateManyWithWhereWithoutFilingCustomerIdInput = {
    where: LotInfoScalarWhereInput
    data: XOR<LotInfoUpdateManyMutationInput, LotInfoUncheckedUpdateManyWithoutFilingCustomerIdInput>
  }

  export type LotInfoScalarWhereInput = {
    AND?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
    OR?: LotInfoScalarWhereInput[]
    NOT?: LotInfoScalarWhereInput | LotInfoScalarWhereInput[]
    id?: IntFilter<"LotInfo"> | number
    lotNumber?: IntFilter<"LotInfo"> | number
    filing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    setting_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    buffing_customer_id?: IntNullableFilter<"LotInfo"> | number | null
    IsActive?: BoolFilter<"LotInfo"> | boolean
  }

  export type LotFilingMapperUpsertWithWhereUniqueWithoutFilingIdInput = {
    where: LotFilingMapperWhereUniqueInput
    update: XOR<LotFilingMapperUpdateWithoutFilingIdInput, LotFilingMapperUncheckedUpdateWithoutFilingIdInput>
    create: XOR<LotFilingMapperCreateWithoutFilingIdInput, LotFilingMapperUncheckedCreateWithoutFilingIdInput>
  }

  export type LotFilingMapperUpdateWithWhereUniqueWithoutFilingIdInput = {
    where: LotFilingMapperWhereUniqueInput
    data: XOR<LotFilingMapperUpdateWithoutFilingIdInput, LotFilingMapperUncheckedUpdateWithoutFilingIdInput>
  }

  export type LotFilingMapperUpdateManyWithWhereWithoutFilingIdInput = {
    where: LotFilingMapperScalarWhereInput
    data: XOR<LotFilingMapperUpdateManyMutationInput, LotFilingMapperUncheckedUpdateManyWithoutFilingIdInput>
  }

  export type LotFilingMapperScalarWhereInput = {
    AND?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
    OR?: LotFilingMapperScalarWhereInput[]
    NOT?: LotFilingMapperScalarWhereInput | LotFilingMapperScalarWhereInput[]
    id?: IntFilter<"LotFilingMapper"> | number
    filing_id?: IntFilter<"LotFilingMapper"> | number
    lot_id?: IntFilter<"LotFilingMapper"> | number
    item_id?: IntFilter<"LotFilingMapper"> | number
    filing_entry_id?: IntFilter<"LotFilingMapper"> | number
  }

  export type SettingEntryCreateWithoutSetting_personInput = {
    createdAt?: Date | string
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutSetting_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutSetting_personInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput>
  }

  export type SettingEntryCreateManySetting_personInputEnvelope = {
    data: SettingEntryCreateManySetting_personInput | SettingEntryCreateManySetting_personInput[]
    skipDuplicates?: boolean
  }

  export type LotSettingMapperCreateWithoutSettingIdInput = {
    lotId: LotInfoCreateNestedOneWithoutSettingMapperInput
    itemId?: FilingItemsCreateNestedOneWithoutLot_setting_mapperInput
    settingEntry: SettingEntryCreateNestedOneWithoutLotSettingMapperInput
  }

  export type LotSettingMapperUncheckedCreateWithoutSettingIdInput = {
    id?: number
    lot_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotSettingMapperCreateOrConnectWithoutSettingIdInput = {
    where: LotSettingMapperWhereUniqueInput
    create: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput>
  }

  export type LotSettingMapperCreateManySettingIdInputEnvelope = {
    data: LotSettingMapperCreateManySettingIdInput | LotSettingMapperCreateManySettingIdInput[]
    skipDuplicates?: boolean
  }

  export type LotInfoCreateWithoutSettingCustomerIdInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutSettingCustomerIdInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutSettingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput>
  }

  export type LotInfoCreateManySettingCustomerIdInputEnvelope = {
    data: LotInfoCreateManySettingCustomerIdInput | LotInfoCreateManySettingCustomerIdInput[]
    skipDuplicates?: boolean
  }

  export type SettingEntryUpsertWithWhereUniqueWithoutSetting_personInput = {
    where: SettingEntryWhereUniqueInput
    update: XOR<SettingEntryUpdateWithoutSetting_personInput, SettingEntryUncheckedUpdateWithoutSetting_personInput>
    create: XOR<SettingEntryCreateWithoutSetting_personInput, SettingEntryUncheckedCreateWithoutSetting_personInput>
  }

  export type SettingEntryUpdateWithWhereUniqueWithoutSetting_personInput = {
    where: SettingEntryWhereUniqueInput
    data: XOR<SettingEntryUpdateWithoutSetting_personInput, SettingEntryUncheckedUpdateWithoutSetting_personInput>
  }

  export type SettingEntryUpdateManyWithWhereWithoutSetting_personInput = {
    where: SettingEntryScalarWhereInput
    data: XOR<SettingEntryUpdateManyMutationInput, SettingEntryUncheckedUpdateManyWithoutSetting_personInput>
  }

  export type SettingEntryScalarWhereInput = {
    AND?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
    OR?: SettingEntryScalarWhereInput[]
    NOT?: SettingEntryScalarWhereInput | SettingEntryScalarWhereInput[]
    id?: IntFilter<"SettingEntry"> | number
    createdAt?: DateTimeFilter<"SettingEntry"> | Date | string
    setting_person_id?: IntFilter<"SettingEntry"> | number
    casting_item_id?: IntFilter<"SettingEntry"> | number
  }

  export type LotSettingMapperUpsertWithWhereUniqueWithoutSettingIdInput = {
    where: LotSettingMapperWhereUniqueInput
    update: XOR<LotSettingMapperUpdateWithoutSettingIdInput, LotSettingMapperUncheckedUpdateWithoutSettingIdInput>
    create: XOR<LotSettingMapperCreateWithoutSettingIdInput, LotSettingMapperUncheckedCreateWithoutSettingIdInput>
  }

  export type LotSettingMapperUpdateWithWhereUniqueWithoutSettingIdInput = {
    where: LotSettingMapperWhereUniqueInput
    data: XOR<LotSettingMapperUpdateWithoutSettingIdInput, LotSettingMapperUncheckedUpdateWithoutSettingIdInput>
  }

  export type LotSettingMapperUpdateManyWithWhereWithoutSettingIdInput = {
    where: LotSettingMapperScalarWhereInput
    data: XOR<LotSettingMapperUpdateManyMutationInput, LotSettingMapperUncheckedUpdateManyWithoutSettingIdInput>
  }

  export type LotSettingMapperScalarWhereInput = {
    AND?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
    OR?: LotSettingMapperScalarWhereInput[]
    NOT?: LotSettingMapperScalarWhereInput | LotSettingMapperScalarWhereInput[]
    id?: IntFilter<"LotSettingMapper"> | number
    setting_id?: IntFilter<"LotSettingMapper"> | number
    lot_id?: IntFilter<"LotSettingMapper"> | number
    filing_item_id?: IntNullableFilter<"LotSettingMapper"> | number | null
    setting_entry_id?: IntFilter<"LotSettingMapper"> | number
  }

  export type LotInfoUpsertWithWhereUniqueWithoutSettingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    update: XOR<LotInfoUpdateWithoutSettingCustomerIdInput, LotInfoUncheckedUpdateWithoutSettingCustomerIdInput>
    create: XOR<LotInfoCreateWithoutSettingCustomerIdInput, LotInfoUncheckedCreateWithoutSettingCustomerIdInput>
  }

  export type LotInfoUpdateWithWhereUniqueWithoutSettingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    data: XOR<LotInfoUpdateWithoutSettingCustomerIdInput, LotInfoUncheckedUpdateWithoutSettingCustomerIdInput>
  }

  export type LotInfoUpdateManyWithWhereWithoutSettingCustomerIdInput = {
    where: LotInfoScalarWhereInput
    data: XOR<LotInfoUpdateManyMutationInput, LotInfoUncheckedUpdateManyWithoutSettingCustomerIdInput>
  }

  export type BuffingEntryCreateWithoutBuffing_personInput = {
    createdAt?: Date | string
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutBuffing_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutBuffing_personInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput>
  }

  export type BuffingEntryCreateManyBuffing_personInputEnvelope = {
    data: BuffingEntryCreateManyBuffing_personInput | BuffingEntryCreateManyBuffing_personInput[]
    skipDuplicates?: boolean
  }

  export type LotBuffingMapperCreateWithoutBuffingIdInput = {
    lotId: LotInfoCreateNestedOneWithoutBuffingMapperInput
    settingItemId?: SettingItemsCreateNestedOneWithoutLotBuffingMapperInput
    filingItemId?: FilingItemsCreateNestedOneWithoutLotBuffingMapperInput
    buffingEntry: BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateWithoutBuffingIdInput = {
    id?: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperCreateOrConnectWithoutBuffingIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    create: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput>
  }

  export type LotBuffingMapperCreateManyBuffingIdInputEnvelope = {
    data: LotBuffingMapperCreateManyBuffingIdInput | LotBuffingMapperCreateManyBuffingIdInput[]
    skipDuplicates?: boolean
  }

  export type LotInfoCreateWithoutBuffingCustomerIdInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutBuffingCustomerIdInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutBuffingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput>
  }

  export type LotInfoCreateManyBuffingCustomerIdInputEnvelope = {
    data: LotInfoCreateManyBuffingCustomerIdInput | LotInfoCreateManyBuffingCustomerIdInput[]
    skipDuplicates?: boolean
  }

  export type BuffingWastageCreateWithoutBuffingPersonIdInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffingLotId?: LotInfoCreateNestedOneWithoutBuffingWastagesInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_lot_id?: number | null
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageCreateOrConnectWithoutBuffingPersonIdInput = {
    where: BuffingWastageWhereUniqueInput
    create: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput>
  }

  export type BuffingWastageCreateManyBuffingPersonIdInputEnvelope = {
    data: BuffingWastageCreateManyBuffingPersonIdInput | BuffingWastageCreateManyBuffingPersonIdInput[]
    skipDuplicates?: boolean
  }

  export type BuffingEntryUpsertWithWhereUniqueWithoutBuffing_personInput = {
    where: BuffingEntryWhereUniqueInput
    update: XOR<BuffingEntryUpdateWithoutBuffing_personInput, BuffingEntryUncheckedUpdateWithoutBuffing_personInput>
    create: XOR<BuffingEntryCreateWithoutBuffing_personInput, BuffingEntryUncheckedCreateWithoutBuffing_personInput>
  }

  export type BuffingEntryUpdateWithWhereUniqueWithoutBuffing_personInput = {
    where: BuffingEntryWhereUniqueInput
    data: XOR<BuffingEntryUpdateWithoutBuffing_personInput, BuffingEntryUncheckedUpdateWithoutBuffing_personInput>
  }

  export type BuffingEntryUpdateManyWithWhereWithoutBuffing_personInput = {
    where: BuffingEntryScalarWhereInput
    data: XOR<BuffingEntryUpdateManyMutationInput, BuffingEntryUncheckedUpdateManyWithoutBuffing_personInput>
  }

  export type BuffingEntryScalarWhereInput = {
    AND?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
    OR?: BuffingEntryScalarWhereInput[]
    NOT?: BuffingEntryScalarWhereInput | BuffingEntryScalarWhereInput[]
    id?: IntFilter<"BuffingEntry"> | number
    createdAt?: DateTimeFilter<"BuffingEntry"> | Date | string
    buffing_person_id?: IntFilter<"BuffingEntry"> | number
    casting_item_id?: IntFilter<"BuffingEntry"> | number
  }

  export type LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    update: XOR<LotBuffingMapperUpdateWithoutBuffingIdInput, LotBuffingMapperUncheckedUpdateWithoutBuffingIdInput>
    create: XOR<LotBuffingMapperCreateWithoutBuffingIdInput, LotBuffingMapperUncheckedCreateWithoutBuffingIdInput>
  }

  export type LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    data: XOR<LotBuffingMapperUpdateWithoutBuffingIdInput, LotBuffingMapperUncheckedUpdateWithoutBuffingIdInput>
  }

  export type LotBuffingMapperUpdateManyWithWhereWithoutBuffingIdInput = {
    where: LotBuffingMapperScalarWhereInput
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdInput>
  }

  export type LotBuffingMapperScalarWhereInput = {
    AND?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
    OR?: LotBuffingMapperScalarWhereInput[]
    NOT?: LotBuffingMapperScalarWhereInput | LotBuffingMapperScalarWhereInput[]
    id?: IntFilter<"LotBuffingMapper"> | number
    buffing_id?: IntFilter<"LotBuffingMapper"> | number
    lot_id?: IntFilter<"LotBuffingMapper"> | number
    setting_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    filing_item_id?: IntNullableFilter<"LotBuffingMapper"> | number | null
    buffing_entry_id?: IntFilter<"LotBuffingMapper"> | number
  }

  export type LotInfoUpsertWithWhereUniqueWithoutBuffingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    update: XOR<LotInfoUpdateWithoutBuffingCustomerIdInput, LotInfoUncheckedUpdateWithoutBuffingCustomerIdInput>
    create: XOR<LotInfoCreateWithoutBuffingCustomerIdInput, LotInfoUncheckedCreateWithoutBuffingCustomerIdInput>
  }

  export type LotInfoUpdateWithWhereUniqueWithoutBuffingCustomerIdInput = {
    where: LotInfoWhereUniqueInput
    data: XOR<LotInfoUpdateWithoutBuffingCustomerIdInput, LotInfoUncheckedUpdateWithoutBuffingCustomerIdInput>
  }

  export type LotInfoUpdateManyWithWhereWithoutBuffingCustomerIdInput = {
    where: LotInfoScalarWhereInput
    data: XOR<LotInfoUpdateManyMutationInput, LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdInput>
  }

  export type BuffingWastageUpsertWithWhereUniqueWithoutBuffingPersonIdInput = {
    where: BuffingWastageWhereUniqueInput
    update: XOR<BuffingWastageUpdateWithoutBuffingPersonIdInput, BuffingWastageUncheckedUpdateWithoutBuffingPersonIdInput>
    create: XOR<BuffingWastageCreateWithoutBuffingPersonIdInput, BuffingWastageUncheckedCreateWithoutBuffingPersonIdInput>
  }

  export type BuffingWastageUpdateWithWhereUniqueWithoutBuffingPersonIdInput = {
    where: BuffingWastageWhereUniqueInput
    data: XOR<BuffingWastageUpdateWithoutBuffingPersonIdInput, BuffingWastageUncheckedUpdateWithoutBuffingPersonIdInput>
  }

  export type BuffingWastageUpdateManyWithWhereWithoutBuffingPersonIdInput = {
    where: BuffingWastageScalarWhereInput
    data: XOR<BuffingWastageUpdateManyMutationInput, BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdInput>
  }

  export type BuffingWastageScalarWhereInput = {
    AND?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
    OR?: BuffingWastageScalarWhereInput[]
    NOT?: BuffingWastageScalarWhereInput | BuffingWastageScalarWhereInput[]
    id?: IntFilter<"BuffingWastage"> | number
    createdAt?: DateTimeFilter<"BuffingWastage"> | Date | string
    total_receipt?: FloatFilter<"BuffingWastage"> | number
    total_wastage?: FloatFilter<"BuffingWastage"> | number
    balance?: FloatFilter<"BuffingWastage"> | number
    wastage_percentage?: IntFilter<"BuffingWastage"> | number
    given_gold?: FloatNullableFilter<"BuffingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"BuffingWastage"> | number | null
    overall_wastage?: FloatFilter<"BuffingWastage"> | number
    closing_balance?: FloatFilter<"BuffingWastage"> | number
    opening_balance?: FloatFilter<"BuffingWastage"> | number
    buffing_person_id?: IntNullableFilter<"BuffingWastage"> | number | null
    buffing_lot_id?: IntNullableFilter<"BuffingWastage"> | number | null
  }

  export type AddCustomerCreateWithoutTransactionsInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddCustomerUncheckedCreateWithoutTransactionsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
  }

  export type AddCustomerCreateOrConnectWithoutTransactionsInput = {
    where: AddCustomerWhereUniqueInput
    create: XOR<AddCustomerCreateWithoutTransactionsInput, AddCustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type AddCustomerUpsertWithoutTransactionsInput = {
    update: XOR<AddCustomerUpdateWithoutTransactionsInput, AddCustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AddCustomerCreateWithoutTransactionsInput, AddCustomerUncheckedCreateWithoutTransactionsInput>
    where?: AddCustomerWhereInput
  }

  export type AddCustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AddCustomerWhereInput
    data: XOR<AddCustomerUpdateWithoutTransactionsInput, AddCustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type AddCustomerUpdateWithoutTransactionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddCustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CastingItemsCreateWithoutItemInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutItemInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutItemInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput>
  }

  export type CastingItemsCreateManyItemInputEnvelope = {
    data: CastingItemsCreateManyItemInput | CastingItemsCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutItemInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutItemInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput>
  }

  export type StockCreateManyItemInputEnvelope = {
    data: StockCreateManyItemInput | StockCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type FilingItemsCreateWithoutFilingitemInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutFilingitemInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutFilingitemInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput>
  }

  export type FilingItemsCreateManyFilingitemInputEnvelope = {
    data: FilingItemsCreateManyFilingitemInput | FilingItemsCreateManyFilingitemInput[]
    skipDuplicates?: boolean
  }

  export type SettingItemsCreateWithoutItemInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutItemInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutItemInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput>
  }

  export type SettingItemsCreateManyItemInputEnvelope = {
    data: SettingItemsCreateManyItemInput | SettingItemsCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type BuffingItemsCreateWithoutItemInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutBuffing_itemsInput
    stock?: StockCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageCreateNestedManyWithoutBuffing_itemsInput
    buffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingItemsInput
  }

  export type BuffingItemsUncheckedCreateWithoutItemInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
    stock?: StockUncheckedCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsCreateOrConnectWithoutItemInput = {
    where: BuffingItemsWhereUniqueInput
    create: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput>
  }

  export type BuffingItemsCreateManyItemInputEnvelope = {
    data: BuffingItemsCreateManyItemInput | BuffingItemsCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CastingItemsUpsertWithWhereUniqueWithoutItemInput = {
    where: CastingItemsWhereUniqueInput
    update: XOR<CastingItemsUpdateWithoutItemInput, CastingItemsUncheckedUpdateWithoutItemInput>
    create: XOR<CastingItemsCreateWithoutItemInput, CastingItemsUncheckedCreateWithoutItemInput>
  }

  export type CastingItemsUpdateWithWhereUniqueWithoutItemInput = {
    where: CastingItemsWhereUniqueInput
    data: XOR<CastingItemsUpdateWithoutItemInput, CastingItemsUncheckedUpdateWithoutItemInput>
  }

  export type CastingItemsUpdateManyWithWhereWithoutItemInput = {
    where: CastingItemsScalarWhereInput
    data: XOR<CastingItemsUpdateManyMutationInput, CastingItemsUncheckedUpdateManyWithoutItemInput>
  }

  export type StockUpsertWithWhereUniqueWithoutItemInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutItemInput, StockUncheckedUpdateWithoutItemInput>
    create: XOR<StockCreateWithoutItemInput, StockUncheckedCreateWithoutItemInput>
  }

  export type StockUpdateWithWhereUniqueWithoutItemInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutItemInput, StockUncheckedUpdateWithoutItemInput>
  }

  export type StockUpdateManyWithWhereWithoutItemInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutItemInput>
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutFilingitemInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutFilingitemInput, FilingItemsUncheckedUpdateWithoutFilingitemInput>
    create: XOR<FilingItemsCreateWithoutFilingitemInput, FilingItemsUncheckedCreateWithoutFilingitemInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutFilingitemInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutFilingitemInput, FilingItemsUncheckedUpdateWithoutFilingitemInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutFilingitemInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutFilingitemInput>
  }

  export type FilingItemsScalarWhereInput = {
    AND?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
    OR?: FilingItemsScalarWhereInput[]
    NOT?: FilingItemsScalarWhereInput | FilingItemsScalarWhereInput[]
    id?: IntFilter<"FilingItems"> | number
    createdAt?: DateTimeFilter<"FilingItems"> | Date | string
    filing_entry_id?: IntFilter<"FilingItems"> | number
    type?: EnumCASTINGENTRYTYPEFilter<"FilingItems"> | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFilter<"FilingItems"> | number
    weight?: FloatFilter<"FilingItems"> | number
    touch_id?: IntFilter<"FilingItems"> | number
    item_purity?: FloatFilter<"FilingItems"> | number
    remarks?: StringNullableFilter<"FilingItems"> | string | null
    stone_option?: EnumSTONEOPTIONNullableFilter<"FilingItems"> | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: IntNullableFilter<"FilingItems"> | number | null
  }

  export type SettingItemsUpsertWithWhereUniqueWithoutItemInput = {
    where: SettingItemsWhereUniqueInput
    update: XOR<SettingItemsUpdateWithoutItemInput, SettingItemsUncheckedUpdateWithoutItemInput>
    create: XOR<SettingItemsCreateWithoutItemInput, SettingItemsUncheckedCreateWithoutItemInput>
  }

  export type SettingItemsUpdateWithWhereUniqueWithoutItemInput = {
    where: SettingItemsWhereUniqueInput
    data: XOR<SettingItemsUpdateWithoutItemInput, SettingItemsUncheckedUpdateWithoutItemInput>
  }

  export type SettingItemsUpdateManyWithWhereWithoutItemInput = {
    where: SettingItemsScalarWhereInput
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyWithoutItemInput>
  }

  export type SettingItemsScalarWhereInput = {
    AND?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
    OR?: SettingItemsScalarWhereInput[]
    NOT?: SettingItemsScalarWhereInput | SettingItemsScalarWhereInput[]
    id?: IntFilter<"SettingItems"> | number
    createdAt?: DateTimeFilter<"SettingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPENullableFilter<"SettingItems"> | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFilter<"SettingItems"> | number
    scrap_weight?: FloatFilter<"SettingItems"> | number
    touch_id?: IntFilter<"SettingItems"> | number
    item_purity?: FloatFilter<"SettingItems"> | number
    scrap_remarks?: StringNullableFilter<"SettingItems"> | string | null
    setting_entry_id?: IntFilter<"SettingItems"> | number
  }

  export type BuffingItemsUpsertWithWhereUniqueWithoutItemInput = {
    where: BuffingItemsWhereUniqueInput
    update: XOR<BuffingItemsUpdateWithoutItemInput, BuffingItemsUncheckedUpdateWithoutItemInput>
    create: XOR<BuffingItemsCreateWithoutItemInput, BuffingItemsUncheckedCreateWithoutItemInput>
  }

  export type BuffingItemsUpdateWithWhereUniqueWithoutItemInput = {
    where: BuffingItemsWhereUniqueInput
    data: XOR<BuffingItemsUpdateWithoutItemInput, BuffingItemsUncheckedUpdateWithoutItemInput>
  }

  export type BuffingItemsUpdateManyWithWhereWithoutItemInput = {
    where: BuffingItemsScalarWhereInput
    data: XOR<BuffingItemsUpdateManyMutationInput, BuffingItemsUncheckedUpdateManyWithoutItemInput>
  }

  export type BuffingItemsScalarWhereInput = {
    AND?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
    OR?: BuffingItemsScalarWhereInput[]
    NOT?: BuffingItemsScalarWhereInput | BuffingItemsScalarWhereInput[]
    id?: IntFilter<"BuffingItems"> | number
    createdAt?: DateTimeFilter<"BuffingItems"> | Date | string
    type?: EnumCASTINGENTRYTYPEFilter<"BuffingItems"> | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFilter<"BuffingItems"> | number
    scrap_weight?: FloatFilter<"BuffingItems"> | number
    touch_id?: IntFilter<"BuffingItems"> | number
    item_purity?: FloatFilter<"BuffingItems"> | number
    scrap_remarks?: StringNullableFilter<"BuffingItems"> | string | null
    buffing_entry_id?: IntFilter<"BuffingItems"> | number
  }

  export type CastingEntryCreateWithoutTouchInput = {
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer: AddCastingCreateNestedOneWithoutEntriesInput
    items?: CastingItemsCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    items?: CastingItemsUncheckedCreateNestedManyWithoutCastingEntryInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryCreateOrConnectWithoutTouchInput = {
    where: CastingEntryWhereUniqueInput
    create: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput>
  }

  export type CastingEntryCreateManyTouchInputEnvelope = {
    data: CastingEntryCreateManyTouchInput | CastingEntryCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type CastingItemsCreateWithoutTouchInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutTouchInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput>
  }

  export type CastingItemsCreateManyTouchInputEnvelope = {
    data: CastingItemsCreateManyTouchInput | CastingItemsCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type FilingItemsCreateWithoutTouchInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutTouchInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput>
  }

  export type FilingItemsCreateManyTouchInputEnvelope = {
    data: FilingItemsCreateManyTouchInput | FilingItemsCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type SettingItemsCreateWithoutTouchInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutTouchInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput>
  }

  export type SettingItemsCreateManyTouchInputEnvelope = {
    data: SettingItemsCreateManyTouchInput | SettingItemsCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type BuffingItemsCreateWithoutTouchInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutBuffing_itemsInput
    stock?: StockCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageCreateNestedManyWithoutBuffing_itemsInput
    buffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingItemsInput
  }

  export type BuffingItemsUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
    stock?: StockUncheckedCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsCreateOrConnectWithoutTouchInput = {
    where: BuffingItemsWhereUniqueInput
    create: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput>
  }

  export type BuffingItemsCreateManyTouchInputEnvelope = {
    data: BuffingItemsCreateManyTouchInput | BuffingItemsCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutTouchInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutTouchInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutTouchInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput>
  }

  export type StockCreateManyTouchInputEnvelope = {
    data: StockCreateManyTouchInput | StockCreateManyTouchInput[]
    skipDuplicates?: boolean
  }

  export type CastingEntryUpsertWithWhereUniqueWithoutTouchInput = {
    where: CastingEntryWhereUniqueInput
    update: XOR<CastingEntryUpdateWithoutTouchInput, CastingEntryUncheckedUpdateWithoutTouchInput>
    create: XOR<CastingEntryCreateWithoutTouchInput, CastingEntryUncheckedCreateWithoutTouchInput>
  }

  export type CastingEntryUpdateWithWhereUniqueWithoutTouchInput = {
    where: CastingEntryWhereUniqueInput
    data: XOR<CastingEntryUpdateWithoutTouchInput, CastingEntryUncheckedUpdateWithoutTouchInput>
  }

  export type CastingEntryUpdateManyWithWhereWithoutTouchInput = {
    where: CastingEntryScalarWhereInput
    data: XOR<CastingEntryUpdateManyMutationInput, CastingEntryUncheckedUpdateManyWithoutTouchInput>
  }

  export type CastingItemsUpsertWithWhereUniqueWithoutTouchInput = {
    where: CastingItemsWhereUniqueInput
    update: XOR<CastingItemsUpdateWithoutTouchInput, CastingItemsUncheckedUpdateWithoutTouchInput>
    create: XOR<CastingItemsCreateWithoutTouchInput, CastingItemsUncheckedCreateWithoutTouchInput>
  }

  export type CastingItemsUpdateWithWhereUniqueWithoutTouchInput = {
    where: CastingItemsWhereUniqueInput
    data: XOR<CastingItemsUpdateWithoutTouchInput, CastingItemsUncheckedUpdateWithoutTouchInput>
  }

  export type CastingItemsUpdateManyWithWhereWithoutTouchInput = {
    where: CastingItemsScalarWhereInput
    data: XOR<CastingItemsUpdateManyMutationInput, CastingItemsUncheckedUpdateManyWithoutTouchInput>
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutTouchInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutTouchInput, FilingItemsUncheckedUpdateWithoutTouchInput>
    create: XOR<FilingItemsCreateWithoutTouchInput, FilingItemsUncheckedCreateWithoutTouchInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutTouchInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutTouchInput, FilingItemsUncheckedUpdateWithoutTouchInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutTouchInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutTouchInput>
  }

  export type SettingItemsUpsertWithWhereUniqueWithoutTouchInput = {
    where: SettingItemsWhereUniqueInput
    update: XOR<SettingItemsUpdateWithoutTouchInput, SettingItemsUncheckedUpdateWithoutTouchInput>
    create: XOR<SettingItemsCreateWithoutTouchInput, SettingItemsUncheckedCreateWithoutTouchInput>
  }

  export type SettingItemsUpdateWithWhereUniqueWithoutTouchInput = {
    where: SettingItemsWhereUniqueInput
    data: XOR<SettingItemsUpdateWithoutTouchInput, SettingItemsUncheckedUpdateWithoutTouchInput>
  }

  export type SettingItemsUpdateManyWithWhereWithoutTouchInput = {
    where: SettingItemsScalarWhereInput
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyWithoutTouchInput>
  }

  export type BuffingItemsUpsertWithWhereUniqueWithoutTouchInput = {
    where: BuffingItemsWhereUniqueInput
    update: XOR<BuffingItemsUpdateWithoutTouchInput, BuffingItemsUncheckedUpdateWithoutTouchInput>
    create: XOR<BuffingItemsCreateWithoutTouchInput, BuffingItemsUncheckedCreateWithoutTouchInput>
  }

  export type BuffingItemsUpdateWithWhereUniqueWithoutTouchInput = {
    where: BuffingItemsWhereUniqueInput
    data: XOR<BuffingItemsUpdateWithoutTouchInput, BuffingItemsUncheckedUpdateWithoutTouchInput>
  }

  export type BuffingItemsUpdateManyWithWhereWithoutTouchInput = {
    where: BuffingItemsScalarWhereInput
    data: XOR<BuffingItemsUpdateManyMutationInput, BuffingItemsUncheckedUpdateManyWithoutTouchInput>
  }

  export type StockUpsertWithWhereUniqueWithoutTouchInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutTouchInput, StockUncheckedUpdateWithoutTouchInput>
    create: XOR<StockCreateWithoutTouchInput, StockUncheckedCreateWithoutTouchInput>
  }

  export type StockUpdateWithWhereUniqueWithoutTouchInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutTouchInput, StockUncheckedUpdateWithoutTouchInput>
  }

  export type StockUpdateManyWithWhereWithoutTouchInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutTouchInput>
  }

  export type AddTouchCreateWithoutCasting_entryInput = {
    createdAt?: Date | string
    touch: number
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutCasting_entryInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutCasting_entryInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutCasting_entryInput, AddTouchUncheckedCreateWithoutCasting_entryInput>
  }

  export type AddCastingCreateWithoutEntriesInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    castingitems?: CastingItemsCreateNestedManyWithoutCasting_customerInput
    stock?: StockCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingUncheckedCreateWithoutEntriesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    castingitems?: CastingItemsUncheckedCreateNestedManyWithoutCasting_customerInput
    stock?: StockUncheckedCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingCreateOrConnectWithoutEntriesInput = {
    where: AddCastingWhereUniqueInput
    create: XOR<AddCastingCreateWithoutEntriesInput, AddCastingUncheckedCreateWithoutEntriesInput>
  }

  export type CastingItemsCreateWithoutCastingEntryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutCastingEntryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutCastingEntryInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput>
  }

  export type CastingItemsCreateManyCastingEntryInputEnvelope = {
    data: CastingItemsCreateManyCastingEntryInput | CastingItemsCreateManyCastingEntryInput[]
    skipDuplicates?: boolean
  }

  export type CastiingTotalBalanceCreateWithoutItem_entry_idInput = {
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
  }

  export type CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput = {
    id?: number
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
  }

  export type CastiingTotalBalanceCreateOrConnectWithoutItem_entry_idInput = {
    where: CastiingTotalBalanceWhereUniqueInput
    create: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput>
  }

  export type CastiingTotalBalanceCreateManyItem_entry_idInputEnvelope = {
    data: CastiingTotalBalanceCreateManyItem_entry_idInput | CastiingTotalBalanceCreateManyItem_entry_idInput[]
    skipDuplicates?: boolean
  }

  export type AddTouchUpsertWithoutCasting_entryInput = {
    update: XOR<AddTouchUpdateWithoutCasting_entryInput, AddTouchUncheckedUpdateWithoutCasting_entryInput>
    create: XOR<AddTouchCreateWithoutCasting_entryInput, AddTouchUncheckedCreateWithoutCasting_entryInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutCasting_entryInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutCasting_entryInput, AddTouchUncheckedUpdateWithoutCasting_entryInput>
  }

  export type AddTouchUpdateWithoutCasting_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutCasting_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type AddCastingUpsertWithoutEntriesInput = {
    update: XOR<AddCastingUpdateWithoutEntriesInput, AddCastingUncheckedUpdateWithoutEntriesInput>
    create: XOR<AddCastingCreateWithoutEntriesInput, AddCastingUncheckedCreateWithoutEntriesInput>
    where?: AddCastingWhereInput
  }

  export type AddCastingUpdateToOneWithWhereWithoutEntriesInput = {
    where?: AddCastingWhereInput
    data: XOR<AddCastingUpdateWithoutEntriesInput, AddCastingUncheckedUpdateWithoutEntriesInput>
  }

  export type AddCastingUpdateWithoutEntriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    castingitems?: CastingItemsUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUpdateManyWithoutCasting_customerNestedInput
  }

  export type AddCastingUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    castingitems?: CastingItemsUncheckedUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUncheckedUpdateManyWithoutCasting_customerNestedInput
  }

  export type CastingItemsUpsertWithWhereUniqueWithoutCastingEntryInput = {
    where: CastingItemsWhereUniqueInput
    update: XOR<CastingItemsUpdateWithoutCastingEntryInput, CastingItemsUncheckedUpdateWithoutCastingEntryInput>
    create: XOR<CastingItemsCreateWithoutCastingEntryInput, CastingItemsUncheckedCreateWithoutCastingEntryInput>
  }

  export type CastingItemsUpdateWithWhereUniqueWithoutCastingEntryInput = {
    where: CastingItemsWhereUniqueInput
    data: XOR<CastingItemsUpdateWithoutCastingEntryInput, CastingItemsUncheckedUpdateWithoutCastingEntryInput>
  }

  export type CastingItemsUpdateManyWithWhereWithoutCastingEntryInput = {
    where: CastingItemsScalarWhereInput
    data: XOR<CastingItemsUpdateManyMutationInput, CastingItemsUncheckedUpdateManyWithoutCastingEntryInput>
  }

  export type CastiingTotalBalanceUpsertWithWhereUniqueWithoutItem_entry_idInput = {
    where: CastiingTotalBalanceWhereUniqueInput
    update: XOR<CastiingTotalBalanceUpdateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedUpdateWithoutItem_entry_idInput>
    create: XOR<CastiingTotalBalanceCreateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedCreateWithoutItem_entry_idInput>
  }

  export type CastiingTotalBalanceUpdateWithWhereUniqueWithoutItem_entry_idInput = {
    where: CastiingTotalBalanceWhereUniqueInput
    data: XOR<CastiingTotalBalanceUpdateWithoutItem_entry_idInput, CastiingTotalBalanceUncheckedUpdateWithoutItem_entry_idInput>
  }

  export type CastiingTotalBalanceUpdateManyWithWhereWithoutItem_entry_idInput = {
    where: CastiingTotalBalanceScalarWhereInput
    data: XOR<CastiingTotalBalanceUpdateManyMutationInput, CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idInput>
  }

  export type CastiingTotalBalanceScalarWhereInput = {
    AND?: CastiingTotalBalanceScalarWhereInput | CastiingTotalBalanceScalarWhereInput[]
    OR?: CastiingTotalBalanceScalarWhereInput[]
    NOT?: CastiingTotalBalanceScalarWhereInput | CastiingTotalBalanceScalarWhereInput[]
    id?: IntFilter<"CastiingTotalBalance"> | number
    createdAt?: DateTimeFilter<"CastiingTotalBalance"> | Date | string
    total_item_weight?: FloatFilter<"CastiingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"CastiingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"CastiingTotalBalance"> | number | null
    total_wastage?: FloatFilter<"CastiingTotalBalance"> | number
    item_entry?: IntFilter<"CastiingTotalBalance"> | number
  }

  export type AddTouchCreateWithoutCasting_itemsInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutCasting_itemsInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutCasting_itemsInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutCasting_itemsInput, AddTouchUncheckedCreateWithoutCasting_itemsInput>
  }

  export type AddItemCreateWithoutCasting_itemsInput = {
    createdAt?: Date | string
    name: string
    stock?: StockCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateWithoutCasting_itemsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    stock?: StockUncheckedCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemCreateOrConnectWithoutCasting_itemsInput = {
    where: AddItemWhereUniqueInput
    create: XOR<AddItemCreateWithoutCasting_itemsInput, AddItemUncheckedCreateWithoutCasting_itemsInput>
  }

  export type CastingEntryCreateWithoutItemsInput = {
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    touch: AddTouchCreateNestedOneWithoutCasting_entryInput
    casting_customer: AddCastingCreateNestedOneWithoutEntriesInput
    CastiingTotalBalance?: CastiingTotalBalanceCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryUncheckedCreateWithoutItemsInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedCreateNestedManyWithoutItem_entry_idInput
  }

  export type CastingEntryCreateOrConnectWithoutItemsInput = {
    where: CastingEntryWhereUniqueInput
    create: XOR<CastingEntryCreateWithoutItemsInput, CastingEntryUncheckedCreateWithoutItemsInput>
  }

  export type FilingEntryCreateWithoutCastingItemInput = {
    createdAt?: Date | string
    filing_person: AddFilingCreateNestedOneWithoutFilingsInput
    filingItems?: FilingItemsCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUncheckedCreateWithoutCastingItemInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryCreateOrConnectWithoutCastingItemInput = {
    where: FilingEntryWhereUniqueInput
    create: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type FilingEntryCreateManyCastingItemInputEnvelope = {
    data: FilingEntryCreateManyCastingItemInput | FilingEntryCreateManyCastingItemInput[]
    skipDuplicates?: boolean
  }

  export type SettingEntryCreateWithoutCastingItemInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutCastingItemInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutCastingItemInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type SettingEntryCreateManyCastingItemInputEnvelope = {
    data: SettingEntryCreateManyCastingItemInput | SettingEntryCreateManyCastingItemInput[]
    skipDuplicates?: boolean
  }

  export type BuffingEntryCreateWithoutCastingItemInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutCastingItemInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutCastingItemInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type BuffingEntryCreateManyCastingItemInputEnvelope = {
    data: BuffingEntryCreateManyCastingItemInput | BuffingEntryCreateManyCastingItemInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutCastingItemInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutCastingItemInput = {
    id?: number
    createdAt?: Date | string
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutCastingItemInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput>
  }

  export type StockCreateManyCastingItemInputEnvelope = {
    data: StockCreateManyCastingItemInput | StockCreateManyCastingItemInput[]
    skipDuplicates?: boolean
  }

  export type LotFilingMapperCreateWithoutItemIdInput = {
    filingId: AddFilingCreateNestedOneWithoutLotFilingMapperInput
    lotId: LotInfoCreateNestedOneWithoutFilingMapperInput
    filing_items?: FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput
    filingEntry: FilingEntryCreateNestedOneWithoutLotFilingMapperInput
  }

  export type LotFilingMapperUncheckedCreateWithoutItemIdInput = {
    id?: number
    filing_id: number
    lot_id: number
    filing_entry_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperCreateOrConnectWithoutItemIdInput = {
    where: LotFilingMapperWhereUniqueInput
    create: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput>
  }

  export type LotFilingMapperCreateManyItemIdInputEnvelope = {
    data: LotFilingMapperCreateManyItemIdInput | LotFilingMapperCreateManyItemIdInput[]
    skipDuplicates?: boolean
  }

  export type AddCastingCreateWithoutCastingitemsInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryCreateNestedManyWithoutCasting_customerInput
    stock?: StockCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingUncheckedCreateWithoutCastingitemsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryUncheckedCreateNestedManyWithoutCasting_customerInput
    stock?: StockUncheckedCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingCreateOrConnectWithoutCastingitemsInput = {
    where: AddCastingWhereUniqueInput
    create: XOR<AddCastingCreateWithoutCastingitemsInput, AddCastingUncheckedCreateWithoutCastingitemsInput>
  }

  export type AddTouchUpsertWithoutCasting_itemsInput = {
    update: XOR<AddTouchUpdateWithoutCasting_itemsInput, AddTouchUncheckedUpdateWithoutCasting_itemsInput>
    create: XOR<AddTouchCreateWithoutCasting_itemsInput, AddTouchUncheckedCreateWithoutCasting_itemsInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutCasting_itemsInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutCasting_itemsInput, AddTouchUncheckedUpdateWithoutCasting_itemsInput>
  }

  export type AddTouchUpdateWithoutCasting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutCasting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type AddItemUpsertWithoutCasting_itemsInput = {
    update: XOR<AddItemUpdateWithoutCasting_itemsInput, AddItemUncheckedUpdateWithoutCasting_itemsInput>
    create: XOR<AddItemCreateWithoutCasting_itemsInput, AddItemUncheckedCreateWithoutCasting_itemsInput>
    where?: AddItemWhereInput
  }

  export type AddItemUpdateToOneWithWhereWithoutCasting_itemsInput = {
    where?: AddItemWhereInput
    data: XOR<AddItemUpdateWithoutCasting_itemsInput, AddItemUncheckedUpdateWithoutCasting_itemsInput>
  }

  export type AddItemUpdateWithoutCasting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    stock?: StockUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateWithoutCasting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    stock?: StockUncheckedUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CastingEntryUpsertWithoutItemsInput = {
    update: XOR<CastingEntryUpdateWithoutItemsInput, CastingEntryUncheckedUpdateWithoutItemsInput>
    create: XOR<CastingEntryCreateWithoutItemsInput, CastingEntryUncheckedCreateWithoutItemsInput>
    where?: CastingEntryWhereInput
  }

  export type CastingEntryUpdateToOneWithWhereWithoutItemsInput = {
    where?: CastingEntryWhereInput
    data: XOR<CastingEntryUpdateWithoutItemsInput, CastingEntryUncheckedUpdateWithoutItemsInput>
  }

  export type CastingEntryUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    touch?: AddTouchUpdateOneRequiredWithoutCasting_entryNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutEntriesNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idNestedInput
  }

  export type FilingEntryUpsertWithWhereUniqueWithoutCastingItemInput = {
    where: FilingEntryWhereUniqueInput
    update: XOR<FilingEntryUpdateWithoutCastingItemInput, FilingEntryUncheckedUpdateWithoutCastingItemInput>
    create: XOR<FilingEntryCreateWithoutCastingItemInput, FilingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type FilingEntryUpdateWithWhereUniqueWithoutCastingItemInput = {
    where: FilingEntryWhereUniqueInput
    data: XOR<FilingEntryUpdateWithoutCastingItemInput, FilingEntryUncheckedUpdateWithoutCastingItemInput>
  }

  export type FilingEntryUpdateManyWithWhereWithoutCastingItemInput = {
    where: FilingEntryScalarWhereInput
    data: XOR<FilingEntryUpdateManyMutationInput, FilingEntryUncheckedUpdateManyWithoutCastingItemInput>
  }

  export type SettingEntryUpsertWithWhereUniqueWithoutCastingItemInput = {
    where: SettingEntryWhereUniqueInput
    update: XOR<SettingEntryUpdateWithoutCastingItemInput, SettingEntryUncheckedUpdateWithoutCastingItemInput>
    create: XOR<SettingEntryCreateWithoutCastingItemInput, SettingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type SettingEntryUpdateWithWhereUniqueWithoutCastingItemInput = {
    where: SettingEntryWhereUniqueInput
    data: XOR<SettingEntryUpdateWithoutCastingItemInput, SettingEntryUncheckedUpdateWithoutCastingItemInput>
  }

  export type SettingEntryUpdateManyWithWhereWithoutCastingItemInput = {
    where: SettingEntryScalarWhereInput
    data: XOR<SettingEntryUpdateManyMutationInput, SettingEntryUncheckedUpdateManyWithoutCastingItemInput>
  }

  export type BuffingEntryUpsertWithWhereUniqueWithoutCastingItemInput = {
    where: BuffingEntryWhereUniqueInput
    update: XOR<BuffingEntryUpdateWithoutCastingItemInput, BuffingEntryUncheckedUpdateWithoutCastingItemInput>
    create: XOR<BuffingEntryCreateWithoutCastingItemInput, BuffingEntryUncheckedCreateWithoutCastingItemInput>
  }

  export type BuffingEntryUpdateWithWhereUniqueWithoutCastingItemInput = {
    where: BuffingEntryWhereUniqueInput
    data: XOR<BuffingEntryUpdateWithoutCastingItemInput, BuffingEntryUncheckedUpdateWithoutCastingItemInput>
  }

  export type BuffingEntryUpdateWithoutCastingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
  }

  export type StockUpsertWithWhereUniqueWithoutCastingItemInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutCastingItemInput, StockUncheckedUpdateWithoutCastingItemInput>
    create: XOR<StockCreateWithoutCastingItemInput, StockUncheckedCreateWithoutCastingItemInput>
  }

  export type StockUpdateWithWhereUniqueWithoutCastingItemInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutCastingItemInput, StockUncheckedUpdateWithoutCastingItemInput>
  }

  export type StockUpdateManyWithWhereWithoutCastingItemInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutCastingItemInput>
  }

  export type LotFilingMapperUpsertWithWhereUniqueWithoutItemIdInput = {
    where: LotFilingMapperWhereUniqueInput
    update: XOR<LotFilingMapperUpdateWithoutItemIdInput, LotFilingMapperUncheckedUpdateWithoutItemIdInput>
    create: XOR<LotFilingMapperCreateWithoutItemIdInput, LotFilingMapperUncheckedCreateWithoutItemIdInput>
  }

  export type LotFilingMapperUpdateWithWhereUniqueWithoutItemIdInput = {
    where: LotFilingMapperWhereUniqueInput
    data: XOR<LotFilingMapperUpdateWithoutItemIdInput, LotFilingMapperUncheckedUpdateWithoutItemIdInput>
  }

  export type LotFilingMapperUpdateManyWithWhereWithoutItemIdInput = {
    where: LotFilingMapperScalarWhereInput
    data: XOR<LotFilingMapperUpdateManyMutationInput, LotFilingMapperUncheckedUpdateManyWithoutItemIdInput>
  }

  export type AddCastingUpsertWithoutCastingitemsInput = {
    update: XOR<AddCastingUpdateWithoutCastingitemsInput, AddCastingUncheckedUpdateWithoutCastingitemsInput>
    create: XOR<AddCastingCreateWithoutCastingitemsInput, AddCastingUncheckedCreateWithoutCastingitemsInput>
    where?: AddCastingWhereInput
  }

  export type AddCastingUpdateToOneWithWhereWithoutCastingitemsInput = {
    where?: AddCastingWhereInput
    data: XOR<AddCastingUpdateWithoutCastingitemsInput, AddCastingUncheckedUpdateWithoutCastingitemsInput>
  }

  export type AddCastingUpdateWithoutCastingitemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUpdateManyWithoutCasting_customerNestedInput
  }

  export type AddCastingUncheckedUpdateWithoutCastingitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUncheckedUpdateManyWithoutCasting_customerNestedInput
    stock?: StockUncheckedUpdateManyWithoutCasting_customerNestedInput
  }

  export type CastingEntryCreateWithoutCastiingTotalBalanceInput = {
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    touch: AddTouchCreateNestedOneWithoutCasting_entryInput
    casting_customer: AddCastingCreateNestedOneWithoutEntriesInput
    items?: CastingItemsCreateNestedManyWithoutCastingEntryInput
  }

  export type CastingEntryUncheckedCreateWithoutCastiingTotalBalanceInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
    items?: CastingItemsUncheckedCreateNestedManyWithoutCastingEntryInput
  }

  export type CastingEntryCreateOrConnectWithoutCastiingTotalBalanceInput = {
    where: CastingEntryWhereUniqueInput
    create: XOR<CastingEntryCreateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedCreateWithoutCastiingTotalBalanceInput>
  }

  export type CastingEntryUpsertWithoutCastiingTotalBalanceInput = {
    update: XOR<CastingEntryUpdateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedUpdateWithoutCastiingTotalBalanceInput>
    create: XOR<CastingEntryCreateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedCreateWithoutCastiingTotalBalanceInput>
    where?: CastingEntryWhereInput
  }

  export type CastingEntryUpdateToOneWithWhereWithoutCastiingTotalBalanceInput = {
    where?: CastingEntryWhereInput
    data: XOR<CastingEntryUpdateWithoutCastiingTotalBalanceInput, CastingEntryUncheckedUpdateWithoutCastiingTotalBalanceInput>
  }

  export type CastingEntryUpdateWithoutCastiingTotalBalanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    touch?: AddTouchUpdateOneRequiredWithoutCasting_entryNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutEntriesNestedInput
    items?: CastingItemsUpdateManyWithoutCastingEntryNestedInput
  }

  export type CastingEntryUncheckedUpdateWithoutCastiingTotalBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    items?: CastingItemsUncheckedUpdateManyWithoutCastingEntryNestedInput
  }

  export type AddFilingCreateWithoutLotInfoInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryCreateNestedManyWithoutFiling_personInput
    lotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingUncheckedCreateWithoutLotInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryUncheckedCreateNestedManyWithoutFiling_personInput
    lotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingCreateOrConnectWithoutLotInfoInput = {
    where: AddFilingWhereUniqueInput
    create: XOR<AddFilingCreateWithoutLotInfoInput, AddFilingUncheckedCreateWithoutLotInfoInput>
  }

  export type AddSettingCreateWithoutLotInfoInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryCreateNestedManyWithoutSetting_personInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutSettingIdInput
  }

  export type AddSettingUncheckedCreateWithoutLotInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryUncheckedCreateNestedManyWithoutSetting_personInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingIdInput
  }

  export type AddSettingCreateOrConnectWithoutLotInfoInput = {
    where: AddSettingWhereUniqueInput
    create: XOR<AddSettingCreateWithoutLotInfoInput, AddSettingUncheckedCreateWithoutLotInfoInput>
  }

  export type AddBuffingCreateWithoutLotInfoInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryCreateNestedManyWithoutBuffing_personInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingUncheckedCreateWithoutLotInfoInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryUncheckedCreateNestedManyWithoutBuffing_personInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingCreateOrConnectWithoutLotInfoInput = {
    where: AddBuffingWhereUniqueInput
    create: XOR<AddBuffingCreateWithoutLotInfoInput, AddBuffingUncheckedCreateWithoutLotInfoInput>
  }

  export type LotFilingMapperCreateWithoutLotIdInput = {
    filingId: AddFilingCreateNestedOneWithoutLotFilingMapperInput
    itemId: CastingItemsCreateNestedOneWithoutFilingLotMapperInput
    filing_items?: FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput
    filingEntry: FilingEntryCreateNestedOneWithoutLotFilingMapperInput
  }

  export type LotFilingMapperUncheckedCreateWithoutLotIdInput = {
    id?: number
    filing_id: number
    item_id: number
    filing_entry_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperCreateOrConnectWithoutLotIdInput = {
    where: LotFilingMapperWhereUniqueInput
    create: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotFilingMapperCreateManyLotIdInputEnvelope = {
    data: LotFilingMapperCreateManyLotIdInput | LotFilingMapperCreateManyLotIdInput[]
    skipDuplicates?: boolean
  }

  export type LotSettingMapperCreateWithoutLotIdInput = {
    settingId: AddSettingCreateNestedOneWithoutSettingMapperInput
    itemId?: FilingItemsCreateNestedOneWithoutLot_setting_mapperInput
    settingEntry: SettingEntryCreateNestedOneWithoutLotSettingMapperInput
  }

  export type LotSettingMapperUncheckedCreateWithoutLotIdInput = {
    id?: number
    setting_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotSettingMapperCreateOrConnectWithoutLotIdInput = {
    where: LotSettingMapperWhereUniqueInput
    create: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotSettingMapperCreateManyLotIdInputEnvelope = {
    data: LotSettingMapperCreateManyLotIdInput | LotSettingMapperCreateManyLotIdInput[]
    skipDuplicates?: boolean
  }

  export type LotBuffingMapperCreateWithoutLotIdInput = {
    buffingId: AddBuffingCreateNestedOneWithoutBuffingMapperInput
    settingItemId?: SettingItemsCreateNestedOneWithoutLotBuffingMapperInput
    filingItemId?: FilingItemsCreateNestedOneWithoutLotBuffingMapperInput
    buffingEntry: BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateWithoutLotIdInput = {
    id?: number
    buffing_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperCreateOrConnectWithoutLotIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    create: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotBuffingMapperCreateManyLotIdInputEnvelope = {
    data: LotBuffingMapperCreateManyLotIdInput | LotBuffingMapperCreateManyLotIdInput[]
    skipDuplicates?: boolean
  }

  export type FilingWastageCreateWithoutFilingLotIdInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filingPersonId?: AddFilingCreateNestedOneWithoutFilingWastagesInput
    filing_items?: FilingItemsCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageUncheckedCreateWithoutFilingLotIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id?: number | null
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFiling_wastageInput
  }

  export type FilingWastageCreateOrConnectWithoutFilingLotIdInput = {
    where: FilingWastageWhereUniqueInput
    create: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput>
  }

  export type FilingWastageCreateManyFilingLotIdInputEnvelope = {
    data: FilingWastageCreateManyFilingLotIdInput | FilingWastageCreateManyFilingLotIdInput[]
    skipDuplicates?: boolean
  }

  export type BuffingWastageCreateWithoutBuffingLotIdInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffingPersonId?: AddBuffingCreateNestedOneWithoutBuffingWastagesInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageUncheckedCreateWithoutBuffingLotIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id?: number | null
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutBuffing_wastageInput
  }

  export type BuffingWastageCreateOrConnectWithoutBuffingLotIdInput = {
    where: BuffingWastageWhereUniqueInput
    create: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput>
  }

  export type BuffingWastageCreateManyBuffingLotIdInputEnvelope = {
    data: BuffingWastageCreateManyBuffingLotIdInput | BuffingWastageCreateManyBuffingLotIdInput[]
    skipDuplicates?: boolean
  }

  export type AddFilingUpsertWithoutLotInfoInput = {
    update: XOR<AddFilingUpdateWithoutLotInfoInput, AddFilingUncheckedUpdateWithoutLotInfoInput>
    create: XOR<AddFilingCreateWithoutLotInfoInput, AddFilingUncheckedCreateWithoutLotInfoInput>
    where?: AddFilingWhereInput
  }

  export type AddFilingUpdateToOneWithWhereWithoutLotInfoInput = {
    where?: AddFilingWhereInput
    data: XOR<AddFilingUpdateWithoutLotInfoInput, AddFilingUncheckedUpdateWithoutLotInfoInput>
  }

  export type AddFilingUpdateWithoutLotInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUpdateManyWithoutFiling_personNestedInput
    lotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingIdNestedInput
  }

  export type AddFilingUncheckedUpdateWithoutLotInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUncheckedUpdateManyWithoutFiling_personNestedInput
    lotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingIdNestedInput
  }

  export type AddSettingUpsertWithoutLotInfoInput = {
    update: XOR<AddSettingUpdateWithoutLotInfoInput, AddSettingUncheckedUpdateWithoutLotInfoInput>
    create: XOR<AddSettingCreateWithoutLotInfoInput, AddSettingUncheckedCreateWithoutLotInfoInput>
    where?: AddSettingWhereInput
  }

  export type AddSettingUpdateToOneWithWhereWithoutLotInfoInput = {
    where?: AddSettingWhereInput
    data: XOR<AddSettingUpdateWithoutLotInfoInput, AddSettingUncheckedUpdateWithoutLotInfoInput>
  }

  export type AddSettingUpdateWithoutLotInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUpdateManyWithoutSetting_personNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutSettingIdNestedInput
  }

  export type AddSettingUncheckedUpdateWithoutLotInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUncheckedUpdateManyWithoutSetting_personNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingIdNestedInput
  }

  export type AddBuffingUpsertWithoutLotInfoInput = {
    update: XOR<AddBuffingUpdateWithoutLotInfoInput, AddBuffingUncheckedUpdateWithoutLotInfoInput>
    create: XOR<AddBuffingCreateWithoutLotInfoInput, AddBuffingUncheckedCreateWithoutLotInfoInput>
    where?: AddBuffingWhereInput
  }

  export type AddBuffingUpdateToOneWithWhereWithoutLotInfoInput = {
    where?: AddBuffingWhereInput
    data: XOR<AddBuffingUpdateWithoutLotInfoInput, AddBuffingUncheckedUpdateWithoutLotInfoInput>
  }

  export type AddBuffingUpdateWithoutLotInfoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUpdateManyWithoutBuffing_personNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type AddBuffingUncheckedUpdateWithoutLotInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUncheckedUpdateManyWithoutBuffing_personNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type LotFilingMapperUpsertWithWhereUniqueWithoutLotIdInput = {
    where: LotFilingMapperWhereUniqueInput
    update: XOR<LotFilingMapperUpdateWithoutLotIdInput, LotFilingMapperUncheckedUpdateWithoutLotIdInput>
    create: XOR<LotFilingMapperCreateWithoutLotIdInput, LotFilingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotFilingMapperUpdateWithWhereUniqueWithoutLotIdInput = {
    where: LotFilingMapperWhereUniqueInput
    data: XOR<LotFilingMapperUpdateWithoutLotIdInput, LotFilingMapperUncheckedUpdateWithoutLotIdInput>
  }

  export type LotFilingMapperUpdateManyWithWhereWithoutLotIdInput = {
    where: LotFilingMapperScalarWhereInput
    data: XOR<LotFilingMapperUpdateManyMutationInput, LotFilingMapperUncheckedUpdateManyWithoutLotIdInput>
  }

  export type LotSettingMapperUpsertWithWhereUniqueWithoutLotIdInput = {
    where: LotSettingMapperWhereUniqueInput
    update: XOR<LotSettingMapperUpdateWithoutLotIdInput, LotSettingMapperUncheckedUpdateWithoutLotIdInput>
    create: XOR<LotSettingMapperCreateWithoutLotIdInput, LotSettingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotSettingMapperUpdateWithWhereUniqueWithoutLotIdInput = {
    where: LotSettingMapperWhereUniqueInput
    data: XOR<LotSettingMapperUpdateWithoutLotIdInput, LotSettingMapperUncheckedUpdateWithoutLotIdInput>
  }

  export type LotSettingMapperUpdateManyWithWhereWithoutLotIdInput = {
    where: LotSettingMapperScalarWhereInput
    data: XOR<LotSettingMapperUpdateManyMutationInput, LotSettingMapperUncheckedUpdateManyWithoutLotIdInput>
  }

  export type LotBuffingMapperUpsertWithWhereUniqueWithoutLotIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    update: XOR<LotBuffingMapperUpdateWithoutLotIdInput, LotBuffingMapperUncheckedUpdateWithoutLotIdInput>
    create: XOR<LotBuffingMapperCreateWithoutLotIdInput, LotBuffingMapperUncheckedCreateWithoutLotIdInput>
  }

  export type LotBuffingMapperUpdateWithWhereUniqueWithoutLotIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    data: XOR<LotBuffingMapperUpdateWithoutLotIdInput, LotBuffingMapperUncheckedUpdateWithoutLotIdInput>
  }

  export type LotBuffingMapperUpdateManyWithWhereWithoutLotIdInput = {
    where: LotBuffingMapperScalarWhereInput
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyWithoutLotIdInput>
  }

  export type FilingWastageUpsertWithWhereUniqueWithoutFilingLotIdInput = {
    where: FilingWastageWhereUniqueInput
    update: XOR<FilingWastageUpdateWithoutFilingLotIdInput, FilingWastageUncheckedUpdateWithoutFilingLotIdInput>
    create: XOR<FilingWastageCreateWithoutFilingLotIdInput, FilingWastageUncheckedCreateWithoutFilingLotIdInput>
  }

  export type FilingWastageUpdateWithWhereUniqueWithoutFilingLotIdInput = {
    where: FilingWastageWhereUniqueInput
    data: XOR<FilingWastageUpdateWithoutFilingLotIdInput, FilingWastageUncheckedUpdateWithoutFilingLotIdInput>
  }

  export type FilingWastageUpdateManyWithWhereWithoutFilingLotIdInput = {
    where: FilingWastageScalarWhereInput
    data: XOR<FilingWastageUpdateManyMutationInput, FilingWastageUncheckedUpdateManyWithoutFilingLotIdInput>
  }

  export type BuffingWastageUpsertWithWhereUniqueWithoutBuffingLotIdInput = {
    where: BuffingWastageWhereUniqueInput
    update: XOR<BuffingWastageUpdateWithoutBuffingLotIdInput, BuffingWastageUncheckedUpdateWithoutBuffingLotIdInput>
    create: XOR<BuffingWastageCreateWithoutBuffingLotIdInput, BuffingWastageUncheckedCreateWithoutBuffingLotIdInput>
  }

  export type BuffingWastageUpdateWithWhereUniqueWithoutBuffingLotIdInput = {
    where: BuffingWastageWhereUniqueInput
    data: XOR<BuffingWastageUpdateWithoutBuffingLotIdInput, BuffingWastageUncheckedUpdateWithoutBuffingLotIdInput>
  }

  export type BuffingWastageUpdateManyWithWhereWithoutBuffingLotIdInput = {
    where: BuffingWastageScalarWhereInput
    data: XOR<BuffingWastageUpdateManyMutationInput, BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdInput>
  }

  export type AddFilingCreateWithoutFilingsInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingPersonIdInput
    lotInfo?: LotInfoCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingUncheckedCreateWithoutFilingsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingPersonIdInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingCreateOrConnectWithoutFilingsInput = {
    where: AddFilingWhereUniqueInput
    create: XOR<AddFilingCreateWithoutFilingsInput, AddFilingUncheckedCreateWithoutFilingsInput>
  }

  export type CastingItemsCreateWithoutFilingEntryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutFilingEntryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutFilingEntryInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutFilingEntryInput, CastingItemsUncheckedCreateWithoutFilingEntryInput>
  }

  export type FilingItemsCreateWithoutFiling_entryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutFiling_entryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutFiling_entryInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput>
  }

  export type FilingItemsCreateManyFiling_entryInputEnvelope = {
    data: FilingItemsCreateManyFiling_entryInput | FilingItemsCreateManyFiling_entryInput[]
    skipDuplicates?: boolean
  }

  export type FilingTotalBalanceCreateWithoutFilingEntryIdInput = {
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
  }

  export type FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
  }

  export type FilingTotalBalanceCreateOrConnectWithoutFilingEntryIdInput = {
    where: FilingTotalBalanceWhereUniqueInput
    create: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput>
  }

  export type FilingTotalBalanceCreateManyFilingEntryIdInputEnvelope = {
    data: FilingTotalBalanceCreateManyFilingEntryIdInput | FilingTotalBalanceCreateManyFilingEntryIdInput[]
    skipDuplicates?: boolean
  }

  export type LotFilingMapperCreateWithoutFilingEntryInput = {
    filingId: AddFilingCreateNestedOneWithoutLotFilingMapperInput
    lotId: LotInfoCreateNestedOneWithoutFilingMapperInput
    itemId: CastingItemsCreateNestedOneWithoutFilingLotMapperInput
    filing_items?: FilingItemsCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperUncheckedCreateWithoutFilingEntryInput = {
    id?: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutLotFilingMapperIdInput
  }

  export type LotFilingMapperCreateOrConnectWithoutFilingEntryInput = {
    where: LotFilingMapperWhereUniqueInput
    create: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput>
  }

  export type LotFilingMapperCreateManyFilingEntryInputEnvelope = {
    data: LotFilingMapperCreateManyFilingEntryInput | LotFilingMapperCreateManyFilingEntryInput[]
    skipDuplicates?: boolean
  }

  export type AddFilingUpsertWithoutFilingsInput = {
    update: XOR<AddFilingUpdateWithoutFilingsInput, AddFilingUncheckedUpdateWithoutFilingsInput>
    create: XOR<AddFilingCreateWithoutFilingsInput, AddFilingUncheckedCreateWithoutFilingsInput>
    where?: AddFilingWhereInput
  }

  export type AddFilingUpdateToOneWithWhereWithoutFilingsInput = {
    where?: AddFilingWhereInput
    data: XOR<AddFilingUpdateWithoutFilingsInput, AddFilingUncheckedUpdateWithoutFilingsInput>
  }

  export type AddFilingUpdateWithoutFilingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUpdateManyWithoutFilingPersonIdNestedInput
    lotInfo?: LotInfoUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingIdNestedInput
  }

  export type AddFilingUncheckedUpdateWithoutFilingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingPersonIdNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingIdNestedInput
  }

  export type CastingItemsUpsertWithoutFilingEntryInput = {
    update: XOR<CastingItemsUpdateWithoutFilingEntryInput, CastingItemsUncheckedUpdateWithoutFilingEntryInput>
    create: XOR<CastingItemsCreateWithoutFilingEntryInput, CastingItemsUncheckedCreateWithoutFilingEntryInput>
    where?: CastingItemsWhereInput
  }

  export type CastingItemsUpdateToOneWithWhereWithoutFilingEntryInput = {
    where?: CastingItemsWhereInput
    data: XOR<CastingItemsUpdateWithoutFilingEntryInput, CastingItemsUncheckedUpdateWithoutFilingEntryInput>
  }

  export type CastingItemsUpdateWithoutFilingEntryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutFilingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutFiling_entryInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutFiling_entryInput, FilingItemsUncheckedUpdateWithoutFiling_entryInput>
    create: XOR<FilingItemsCreateWithoutFiling_entryInput, FilingItemsUncheckedCreateWithoutFiling_entryInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutFiling_entryInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutFiling_entryInput, FilingItemsUncheckedUpdateWithoutFiling_entryInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutFiling_entryInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutFiling_entryInput>
  }

  export type FilingTotalBalanceUpsertWithWhereUniqueWithoutFilingEntryIdInput = {
    where: FilingTotalBalanceWhereUniqueInput
    update: XOR<FilingTotalBalanceUpdateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedUpdateWithoutFilingEntryIdInput>
    create: XOR<FilingTotalBalanceCreateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedCreateWithoutFilingEntryIdInput>
  }

  export type FilingTotalBalanceUpdateWithWhereUniqueWithoutFilingEntryIdInput = {
    where: FilingTotalBalanceWhereUniqueInput
    data: XOR<FilingTotalBalanceUpdateWithoutFilingEntryIdInput, FilingTotalBalanceUncheckedUpdateWithoutFilingEntryIdInput>
  }

  export type FilingTotalBalanceUpdateManyWithWhereWithoutFilingEntryIdInput = {
    where: FilingTotalBalanceScalarWhereInput
    data: XOR<FilingTotalBalanceUpdateManyMutationInput, FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdInput>
  }

  export type FilingTotalBalanceScalarWhereInput = {
    AND?: FilingTotalBalanceScalarWhereInput | FilingTotalBalanceScalarWhereInput[]
    OR?: FilingTotalBalanceScalarWhereInput[]
    NOT?: FilingTotalBalanceScalarWhereInput | FilingTotalBalanceScalarWhereInput[]
    id?: IntFilter<"FilingTotalBalance"> | number
    createdAt?: DateTimeFilter<"FilingTotalBalance"> | Date | string
    after_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    total_product_weight?: FloatFilter<"FilingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"FilingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"FilingTotalBalance"> | number | null
    wastage?: BoolFilter<"FilingTotalBalance"> | boolean
    balance?: FloatFilter<"FilingTotalBalance"> | number
    filing_entry_id?: IntFilter<"FilingTotalBalance"> | number
  }

  export type LotFilingMapperUpsertWithWhereUniqueWithoutFilingEntryInput = {
    where: LotFilingMapperWhereUniqueInput
    update: XOR<LotFilingMapperUpdateWithoutFilingEntryInput, LotFilingMapperUncheckedUpdateWithoutFilingEntryInput>
    create: XOR<LotFilingMapperCreateWithoutFilingEntryInput, LotFilingMapperUncheckedCreateWithoutFilingEntryInput>
  }

  export type LotFilingMapperUpdateWithWhereUniqueWithoutFilingEntryInput = {
    where: LotFilingMapperWhereUniqueInput
    data: XOR<LotFilingMapperUpdateWithoutFilingEntryInput, LotFilingMapperUncheckedUpdateWithoutFilingEntryInput>
  }

  export type LotFilingMapperUpdateManyWithWhereWithoutFilingEntryInput = {
    where: LotFilingMapperScalarWhereInput
    data: XOR<LotFilingMapperUpdateManyMutationInput, LotFilingMapperUncheckedUpdateManyWithoutFilingEntryInput>
  }

  export type AddFilingCreateWithoutLotFilingMapperInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoCreateNestedManyWithoutFilingCustomerIdInput
  }

  export type AddFilingUncheckedCreateWithoutLotFilingMapperInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingPersonIdInput
    filings?: FilingEntryUncheckedCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutFilingCustomerIdInput
  }

  export type AddFilingCreateOrConnectWithoutLotFilingMapperInput = {
    where: AddFilingWhereUniqueInput
    create: XOR<AddFilingCreateWithoutLotFilingMapperInput, AddFilingUncheckedCreateWithoutLotFilingMapperInput>
  }

  export type LotInfoCreateWithoutFilingMapperInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutFilingMapperInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutFilingMapperInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutFilingMapperInput, LotInfoUncheckedCreateWithoutFilingMapperInput>
  }

  export type CastingItemsCreateWithoutFilingLotMapperInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutFilingLotMapperInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
  }

  export type CastingItemsCreateOrConnectWithoutFilingLotMapperInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutFilingLotMapperInput, CastingItemsUncheckedCreateWithoutFilingLotMapperInput>
  }

  export type FilingItemsCreateWithoutLotFilingMapperIdInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutLotFilingMapperIdInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput>
  }

  export type FilingItemsCreateManyLotFilingMapperIdInputEnvelope = {
    data: FilingItemsCreateManyLotFilingMapperIdInput | FilingItemsCreateManyLotFilingMapperIdInput[]
    skipDuplicates?: boolean
  }

  export type FilingEntryCreateWithoutLotFilingMapperInput = {
    createdAt?: Date | string
    filing_person: AddFilingCreateNestedOneWithoutFilingsInput
    castingItem: CastingItemsCreateNestedOneWithoutFilingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput
  }

  export type FilingEntryUncheckedCreateWithoutLotFilingMapperInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput
    filingTotalBalance?: FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput
  }

  export type FilingEntryCreateOrConnectWithoutLotFilingMapperInput = {
    where: FilingEntryWhereUniqueInput
    create: XOR<FilingEntryCreateWithoutLotFilingMapperInput, FilingEntryUncheckedCreateWithoutLotFilingMapperInput>
  }

  export type AddFilingUpsertWithoutLotFilingMapperInput = {
    update: XOR<AddFilingUpdateWithoutLotFilingMapperInput, AddFilingUncheckedUpdateWithoutLotFilingMapperInput>
    create: XOR<AddFilingCreateWithoutLotFilingMapperInput, AddFilingUncheckedCreateWithoutLotFilingMapperInput>
    where?: AddFilingWhereInput
  }

  export type AddFilingUpdateToOneWithWhereWithoutLotFilingMapperInput = {
    where?: AddFilingWhereInput
    data: XOR<AddFilingUpdateWithoutLotFilingMapperInput, AddFilingUncheckedUpdateWithoutLotFilingMapperInput>
  }

  export type AddFilingUpdateWithoutLotFilingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUpdateManyWithoutFilingCustomerIdNestedInput
  }

  export type AddFilingUncheckedUpdateWithoutLotFilingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingPersonIdNestedInput
    filings?: FilingEntryUncheckedUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutFilingCustomerIdNestedInput
  }

  export type LotInfoUpsertWithoutFilingMapperInput = {
    update: XOR<LotInfoUpdateWithoutFilingMapperInput, LotInfoUncheckedUpdateWithoutFilingMapperInput>
    create: XOR<LotInfoCreateWithoutFilingMapperInput, LotInfoUncheckedCreateWithoutFilingMapperInput>
    where?: LotInfoWhereInput
  }

  export type LotInfoUpdateToOneWithWhereWithoutFilingMapperInput = {
    where?: LotInfoWhereInput
    data: XOR<LotInfoUpdateWithoutFilingMapperInput, LotInfoUncheckedUpdateWithoutFilingMapperInput>
  }

  export type LotInfoUpdateWithoutFilingMapperInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutFilingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type CastingItemsUpsertWithoutFilingLotMapperInput = {
    update: XOR<CastingItemsUpdateWithoutFilingLotMapperInput, CastingItemsUncheckedUpdateWithoutFilingLotMapperInput>
    create: XOR<CastingItemsCreateWithoutFilingLotMapperInput, CastingItemsUncheckedCreateWithoutFilingLotMapperInput>
    where?: CastingItemsWhereInput
  }

  export type CastingItemsUpdateToOneWithWhereWithoutFilingLotMapperInput = {
    where?: CastingItemsWhereInput
    data: XOR<CastingItemsUpdateWithoutFilingLotMapperInput, CastingItemsUncheckedUpdateWithoutFilingLotMapperInput>
  }

  export type CastingItemsUpdateWithoutFilingLotMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutFilingLotMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutLotFilingMapperIdInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutLotFilingMapperIdInput, FilingItemsUncheckedUpdateWithoutLotFilingMapperIdInput>
    create: XOR<FilingItemsCreateWithoutLotFilingMapperIdInput, FilingItemsUncheckedCreateWithoutLotFilingMapperIdInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutLotFilingMapperIdInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutLotFilingMapperIdInput, FilingItemsUncheckedUpdateWithoutLotFilingMapperIdInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutLotFilingMapperIdInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdInput>
  }

  export type FilingEntryUpsertWithoutLotFilingMapperInput = {
    update: XOR<FilingEntryUpdateWithoutLotFilingMapperInput, FilingEntryUncheckedUpdateWithoutLotFilingMapperInput>
    create: XOR<FilingEntryCreateWithoutLotFilingMapperInput, FilingEntryUncheckedCreateWithoutLotFilingMapperInput>
    where?: FilingEntryWhereInput
  }

  export type FilingEntryUpdateToOneWithWhereWithoutLotFilingMapperInput = {
    where?: FilingEntryWhereInput
    data: XOR<FilingEntryUpdateWithoutLotFilingMapperInput, FilingEntryUncheckedUpdateWithoutLotFilingMapperInput>
  }

  export type FilingEntryUpdateWithoutLotFilingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person?: AddFilingUpdateOneRequiredWithoutFilingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput
  }

  export type FilingEntryUncheckedUpdateWithoutLotFilingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput
  }

  export type FilingEntryCreateWithoutFilingItemsInput = {
    createdAt?: Date | string
    filing_person: AddFilingCreateNestedOneWithoutFilingsInput
    castingItem: CastingItemsCreateNestedOneWithoutFilingEntryInput
    filingTotalBalance?: FilingTotalBalanceCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUncheckedCreateWithoutFilingItemsInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    casting_item_id: number
    filingTotalBalance?: FilingTotalBalanceUncheckedCreateNestedManyWithoutFilingEntryIdInput
    LotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryCreateOrConnectWithoutFilingItemsInput = {
    where: FilingEntryWhereUniqueInput
    create: XOR<FilingEntryCreateWithoutFilingItemsInput, FilingEntryUncheckedCreateWithoutFilingItemsInput>
  }

  export type AddItemCreateWithoutFiling_itemsInput = {
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsCreateNestedManyWithoutItemInput
    stock?: StockCreateNestedManyWithoutItemInput
    setting_items?: SettingItemsCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateWithoutFiling_itemsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutItemInput
    stock?: StockUncheckedCreateNestedManyWithoutItemInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemCreateOrConnectWithoutFiling_itemsInput = {
    where: AddItemWhereUniqueInput
    create: XOR<AddItemCreateWithoutFiling_itemsInput, AddItemUncheckedCreateWithoutFiling_itemsInput>
  }

  export type AddTouchCreateWithoutFiling_itemsInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutFiling_itemsInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutFiling_itemsInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutFiling_itemsInput, AddTouchUncheckedCreateWithoutFiling_itemsInput>
  }

  export type StockCreateWithoutFilingItemInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutFilingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutFilingItemInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput>
  }

  export type StockCreateManyFilingItemInputEnvelope = {
    data: StockCreateManyFilingItemInput | StockCreateManyFilingItemInput[]
    skipDuplicates?: boolean
  }

  export type SettingEntryCreateWithoutFilingItemsInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutFilingItemsInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutFilingItemsInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput>
  }

  export type BuffingEntryCreateWithoutFiling_itemsInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutFiling_itemsInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutFiling_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput>
  }

  export type FilingWastageCreateWithoutFiling_itemsInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filingPersonId?: AddFilingCreateNestedOneWithoutFilingWastagesInput
    filingLotId?: LotInfoCreateNestedOneWithoutFilingWastagesInput
  }

  export type FilingWastageUncheckedCreateWithoutFiling_itemsInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id?: number | null
    filing_lot_id?: number | null
  }

  export type FilingWastageCreateOrConnectWithoutFiling_itemsInput = {
    where: FilingWastageWhereUniqueInput
    create: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput>
  }

  export type LotSettingMapperCreateWithoutItemIdInput = {
    settingId: AddSettingCreateNestedOneWithoutSettingMapperInput
    lotId: LotInfoCreateNestedOneWithoutSettingMapperInput
    settingEntry: SettingEntryCreateNestedOneWithoutLotSettingMapperInput
  }

  export type LotSettingMapperUncheckedCreateWithoutItemIdInput = {
    id?: number
    setting_id: number
    lot_id: number
    setting_entry_id: number
  }

  export type LotSettingMapperCreateOrConnectWithoutItemIdInput = {
    where: LotSettingMapperWhereUniqueInput
    create: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput>
  }

  export type LotSettingMapperCreateManyItemIdInputEnvelope = {
    data: LotSettingMapperCreateManyItemIdInput | LotSettingMapperCreateManyItemIdInput[]
    skipDuplicates?: boolean
  }

  export type LotBuffingMapperCreateWithoutFilingItemIdInput = {
    buffingId: AddBuffingCreateNestedOneWithoutBuffingMapperInput
    lotId: LotInfoCreateNestedOneWithoutBuffingMapperInput
    settingItemId?: SettingItemsCreateNestedOneWithoutLotBuffingMapperInput
    buffingEntry: BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperCreateOrConnectWithoutFilingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    create: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput>
  }

  export type LotBuffingMapperCreateManyFilingItemIdInputEnvelope = {
    data: LotBuffingMapperCreateManyFilingItemIdInput | LotBuffingMapperCreateManyFilingItemIdInput[]
    skipDuplicates?: boolean
  }

  export type LotFilingMapperCreateWithoutFiling_itemsInput = {
    filingId: AddFilingCreateNestedOneWithoutLotFilingMapperInput
    lotId: LotInfoCreateNestedOneWithoutFilingMapperInput
    itemId: CastingItemsCreateNestedOneWithoutFilingLotMapperInput
    filingEntry: FilingEntryCreateNestedOneWithoutLotFilingMapperInput
  }

  export type LotFilingMapperUncheckedCreateWithoutFiling_itemsInput = {
    id?: number
    filing_id: number
    lot_id: number
    item_id: number
    filing_entry_id: number
  }

  export type LotFilingMapperCreateOrConnectWithoutFiling_itemsInput = {
    where: LotFilingMapperWhereUniqueInput
    create: XOR<LotFilingMapperCreateWithoutFiling_itemsInput, LotFilingMapperUncheckedCreateWithoutFiling_itemsInput>
  }

  export type FilingEntryUpsertWithoutFilingItemsInput = {
    update: XOR<FilingEntryUpdateWithoutFilingItemsInput, FilingEntryUncheckedUpdateWithoutFilingItemsInput>
    create: XOR<FilingEntryCreateWithoutFilingItemsInput, FilingEntryUncheckedCreateWithoutFilingItemsInput>
    where?: FilingEntryWhereInput
  }

  export type FilingEntryUpdateToOneWithWhereWithoutFilingItemsInput = {
    where?: FilingEntryWhereInput
    data: XOR<FilingEntryUpdateWithoutFilingItemsInput, FilingEntryUncheckedUpdateWithoutFilingItemsInput>
  }

  export type FilingEntryUpdateWithoutFilingItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person?: AddFilingUpdateOneRequiredWithoutFilingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput
    filingTotalBalance?: FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateWithoutFilingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingTotalBalance?: FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput
  }

  export type AddItemUpsertWithoutFiling_itemsInput = {
    update: XOR<AddItemUpdateWithoutFiling_itemsInput, AddItemUncheckedUpdateWithoutFiling_itemsInput>
    create: XOR<AddItemCreateWithoutFiling_itemsInput, AddItemUncheckedCreateWithoutFiling_itemsInput>
    where?: AddItemWhereInput
  }

  export type AddItemUpdateToOneWithWhereWithoutFiling_itemsInput = {
    where?: AddItemWhereInput
    data: XOR<AddItemUpdateWithoutFiling_itemsInput, AddItemUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type AddItemUpdateWithoutFiling_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUpdateManyWithoutItemNestedInput
    stock?: StockUpdateManyWithoutItemNestedInput
    setting_items?: SettingItemsUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUncheckedUpdateManyWithoutItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutItemNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AddTouchUpsertWithoutFiling_itemsInput = {
    update: XOR<AddTouchUpdateWithoutFiling_itemsInput, AddTouchUncheckedUpdateWithoutFiling_itemsInput>
    create: XOR<AddTouchCreateWithoutFiling_itemsInput, AddTouchUncheckedCreateWithoutFiling_itemsInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutFiling_itemsInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutFiling_itemsInput, AddTouchUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type AddTouchUpdateWithoutFiling_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type StockUpsertWithWhereUniqueWithoutFilingItemInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutFilingItemInput, StockUncheckedUpdateWithoutFilingItemInput>
    create: XOR<StockCreateWithoutFilingItemInput, StockUncheckedCreateWithoutFilingItemInput>
  }

  export type StockUpdateWithWhereUniqueWithoutFilingItemInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutFilingItemInput, StockUncheckedUpdateWithoutFilingItemInput>
  }

  export type StockUpdateManyWithWhereWithoutFilingItemInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutFilingItemInput>
  }

  export type SettingEntryUpsertWithWhereUniqueWithoutFilingItemsInput = {
    where: SettingEntryWhereUniqueInput
    update: XOR<SettingEntryUpdateWithoutFilingItemsInput, SettingEntryUncheckedUpdateWithoutFilingItemsInput>
    create: XOR<SettingEntryCreateWithoutFilingItemsInput, SettingEntryUncheckedCreateWithoutFilingItemsInput>
  }

  export type SettingEntryUpdateWithWhereUniqueWithoutFilingItemsInput = {
    where: SettingEntryWhereUniqueInput
    data: XOR<SettingEntryUpdateWithoutFilingItemsInput, SettingEntryUncheckedUpdateWithoutFilingItemsInput>
  }

  export type SettingEntryUpdateManyWithWhereWithoutFilingItemsInput = {
    where: SettingEntryScalarWhereInput
    data: XOR<SettingEntryUpdateManyMutationInput, SettingEntryUncheckedUpdateManyWithoutFilingItemsInput>
  }

  export type BuffingEntryUpsertWithWhereUniqueWithoutFiling_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    update: XOR<BuffingEntryUpdateWithoutFiling_itemsInput, BuffingEntryUncheckedUpdateWithoutFiling_itemsInput>
    create: XOR<BuffingEntryCreateWithoutFiling_itemsInput, BuffingEntryUncheckedCreateWithoutFiling_itemsInput>
  }

  export type BuffingEntryUpdateWithWhereUniqueWithoutFiling_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    data: XOR<BuffingEntryUpdateWithoutFiling_itemsInput, BuffingEntryUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type BuffingEntryUpdateManyWithWhereWithoutFiling_itemsInput = {
    where: BuffingEntryScalarWhereInput
    data: XOR<BuffingEntryUpdateManyMutationInput, BuffingEntryUncheckedUpdateManyWithoutFiling_itemsInput>
  }

  export type FilingWastageUpsertWithWhereUniqueWithoutFiling_itemsInput = {
    where: FilingWastageWhereUniqueInput
    update: XOR<FilingWastageUpdateWithoutFiling_itemsInput, FilingWastageUncheckedUpdateWithoutFiling_itemsInput>
    create: XOR<FilingWastageCreateWithoutFiling_itemsInput, FilingWastageUncheckedCreateWithoutFiling_itemsInput>
  }

  export type FilingWastageUpdateWithWhereUniqueWithoutFiling_itemsInput = {
    where: FilingWastageWhereUniqueInput
    data: XOR<FilingWastageUpdateWithoutFiling_itemsInput, FilingWastageUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type FilingWastageUpdateManyWithWhereWithoutFiling_itemsInput = {
    where: FilingWastageScalarWhereInput
    data: XOR<FilingWastageUpdateManyMutationInput, FilingWastageUncheckedUpdateManyWithoutFiling_itemsInput>
  }

  export type LotSettingMapperUpsertWithWhereUniqueWithoutItemIdInput = {
    where: LotSettingMapperWhereUniqueInput
    update: XOR<LotSettingMapperUpdateWithoutItemIdInput, LotSettingMapperUncheckedUpdateWithoutItemIdInput>
    create: XOR<LotSettingMapperCreateWithoutItemIdInput, LotSettingMapperUncheckedCreateWithoutItemIdInput>
  }

  export type LotSettingMapperUpdateWithWhereUniqueWithoutItemIdInput = {
    where: LotSettingMapperWhereUniqueInput
    data: XOR<LotSettingMapperUpdateWithoutItemIdInput, LotSettingMapperUncheckedUpdateWithoutItemIdInput>
  }

  export type LotSettingMapperUpdateManyWithWhereWithoutItemIdInput = {
    where: LotSettingMapperScalarWhereInput
    data: XOR<LotSettingMapperUpdateManyMutationInput, LotSettingMapperUncheckedUpdateManyWithoutItemIdInput>
  }

  export type LotBuffingMapperUpsertWithWhereUniqueWithoutFilingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    update: XOR<LotBuffingMapperUpdateWithoutFilingItemIdInput, LotBuffingMapperUncheckedUpdateWithoutFilingItemIdInput>
    create: XOR<LotBuffingMapperCreateWithoutFilingItemIdInput, LotBuffingMapperUncheckedCreateWithoutFilingItemIdInput>
  }

  export type LotBuffingMapperUpdateWithWhereUniqueWithoutFilingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    data: XOR<LotBuffingMapperUpdateWithoutFilingItemIdInput, LotBuffingMapperUncheckedUpdateWithoutFilingItemIdInput>
  }

  export type LotBuffingMapperUpdateManyWithWhereWithoutFilingItemIdInput = {
    where: LotBuffingMapperScalarWhereInput
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdInput>
  }

  export type LotFilingMapperUpsertWithoutFiling_itemsInput = {
    update: XOR<LotFilingMapperUpdateWithoutFiling_itemsInput, LotFilingMapperUncheckedUpdateWithoutFiling_itemsInput>
    create: XOR<LotFilingMapperCreateWithoutFiling_itemsInput, LotFilingMapperUncheckedCreateWithoutFiling_itemsInput>
    where?: LotFilingMapperWhereInput
  }

  export type LotFilingMapperUpdateToOneWithWhereWithoutFiling_itemsInput = {
    where?: LotFilingMapperWhereInput
    data: XOR<LotFilingMapperUpdateWithoutFiling_itemsInput, LotFilingMapperUncheckedUpdateWithoutFiling_itemsInput>
  }

  export type LotFilingMapperUpdateWithoutFiling_itemsInput = {
    filingId?: AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput
    itemId?: CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput
    filingEntry?: FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput
  }

  export type LotFilingMapperUncheckedUpdateWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingEntryCreateWithoutFilingTotalBalanceInput = {
    createdAt?: Date | string
    filing_person: AddFilingCreateNestedOneWithoutFilingsInput
    castingItem: CastingItemsCreateNestedOneWithoutFilingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutFiling_entryInput
    LotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryUncheckedCreateWithoutFilingTotalBalanceInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutFiling_entryInput
    LotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingEntryInput
  }

  export type FilingEntryCreateOrConnectWithoutFilingTotalBalanceInput = {
    where: FilingEntryWhereUniqueInput
    create: XOR<FilingEntryCreateWithoutFilingTotalBalanceInput, FilingEntryUncheckedCreateWithoutFilingTotalBalanceInput>
  }

  export type FilingEntryUpsertWithoutFilingTotalBalanceInput = {
    update: XOR<FilingEntryUpdateWithoutFilingTotalBalanceInput, FilingEntryUncheckedUpdateWithoutFilingTotalBalanceInput>
    create: XOR<FilingEntryCreateWithoutFilingTotalBalanceInput, FilingEntryUncheckedCreateWithoutFilingTotalBalanceInput>
    where?: FilingEntryWhereInput
  }

  export type FilingEntryUpdateToOneWithWhereWithoutFilingTotalBalanceInput = {
    where?: FilingEntryWhereInput
    data: XOR<FilingEntryUpdateWithoutFilingTotalBalanceInput, FilingEntryUncheckedUpdateWithoutFilingTotalBalanceInput>
  }

  export type FilingEntryUpdateWithoutFilingTotalBalanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person?: AddFilingUpdateOneRequiredWithoutFilingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutFiling_entryNestedInput
    LotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateWithoutFilingTotalBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput
    LotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput
  }

  export type AddFilingCreateWithoutFilingWastagesInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filings?: FilingEntryCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingUncheckedCreateWithoutFilingWastagesInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    filings?: FilingEntryUncheckedCreateNestedManyWithoutFiling_personInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutFilingCustomerIdInput
    lotFilingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutFilingIdInput
  }

  export type AddFilingCreateOrConnectWithoutFilingWastagesInput = {
    where: AddFilingWhereUniqueInput
    create: XOR<AddFilingCreateWithoutFilingWastagesInput, AddFilingUncheckedCreateWithoutFilingWastagesInput>
  }

  export type LotInfoCreateWithoutFilingWastagesInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutFilingWastagesInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutFilingWastagesInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutFilingWastagesInput, LotInfoUncheckedCreateWithoutFilingWastagesInput>
  }

  export type FilingItemsCreateWithoutFiling_wastageInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutFiling_wastageInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutFiling_wastageInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput>
  }

  export type AddFilingUpsertWithoutFilingWastagesInput = {
    update: XOR<AddFilingUpdateWithoutFilingWastagesInput, AddFilingUncheckedUpdateWithoutFilingWastagesInput>
    create: XOR<AddFilingCreateWithoutFilingWastagesInput, AddFilingUncheckedCreateWithoutFilingWastagesInput>
    where?: AddFilingWhereInput
  }

  export type AddFilingUpdateToOneWithWhereWithoutFilingWastagesInput = {
    where?: AddFilingWhereInput
    data: XOR<AddFilingUpdateWithoutFilingWastagesInput, AddFilingUncheckedUpdateWithoutFilingWastagesInput>
  }

  export type AddFilingUpdateWithoutFilingWastagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filings?: FilingEntryUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingIdNestedInput
  }

  export type AddFilingUncheckedUpdateWithoutFilingWastagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    filings?: FilingEntryUncheckedUpdateManyWithoutFiling_personNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutFilingCustomerIdNestedInput
    lotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingIdNestedInput
  }

  export type LotInfoUpsertWithoutFilingWastagesInput = {
    update: XOR<LotInfoUpdateWithoutFilingWastagesInput, LotInfoUncheckedUpdateWithoutFilingWastagesInput>
    create: XOR<LotInfoCreateWithoutFilingWastagesInput, LotInfoUncheckedCreateWithoutFilingWastagesInput>
    where?: LotInfoWhereInput
  }

  export type LotInfoUpdateToOneWithWhereWithoutFilingWastagesInput = {
    where?: LotInfoWhereInput
    data: XOR<LotInfoUpdateWithoutFilingWastagesInput, LotInfoUncheckedUpdateWithoutFilingWastagesInput>
  }

  export type LotInfoUpdateWithoutFilingWastagesInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutFilingWastagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutFiling_wastageInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutFiling_wastageInput, FilingItemsUncheckedUpdateWithoutFiling_wastageInput>
    create: XOR<FilingItemsCreateWithoutFiling_wastageInput, FilingItemsUncheckedCreateWithoutFiling_wastageInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutFiling_wastageInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutFiling_wastageInput, FilingItemsUncheckedUpdateWithoutFiling_wastageInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutFiling_wastageInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutFiling_wastageInput>
  }

  export type AddSettingCreateWithoutSettingsInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settingMapper?: LotSettingMapperCreateNestedManyWithoutSettingIdInput
    lotInfo?: LotInfoCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingUncheckedCreateWithoutSettingsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingIdInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingCreateOrConnectWithoutSettingsInput = {
    where: AddSettingWhereUniqueInput
    create: XOR<AddSettingCreateWithoutSettingsInput, AddSettingUncheckedCreateWithoutSettingsInput>
  }

  export type CastingItemsCreateWithoutSettingEntryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutSettingEntryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutSettingEntryInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutSettingEntryInput, CastingItemsUncheckedCreateWithoutSettingEntryInput>
  }

  export type FilingItemsCreateWithoutSetting_entryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutSetting_entryInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutSetting_entryInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceCreateWithoutSetting_entryInput = {
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
  }

  export type SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
  }

  export type SettingTotalBalanceCreateOrConnectWithoutSetting_entryInput = {
    where: SettingTotalBalanceWhereUniqueInput
    create: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceCreateManySetting_entryInputEnvelope = {
    data: SettingTotalBalanceCreateManySetting_entryInput | SettingTotalBalanceCreateManySetting_entryInput[]
    skipDuplicates?: boolean
  }

  export type SettingWastageCreateWithoutSettingEntryIdInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_items?: SettingItemsCreateNestedManyWithoutSetting_wastageInput
  }

  export type SettingWastageUncheckedCreateWithoutSettingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutSetting_wastageInput
  }

  export type SettingWastageCreateOrConnectWithoutSettingEntryIdInput = {
    where: SettingWastageWhereUniqueInput
    create: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput>
  }

  export type SettingWastageCreateManySettingEntryIdInputEnvelope = {
    data: SettingWastageCreateManySettingEntryIdInput | SettingWastageCreateManySettingEntryIdInput[]
    skipDuplicates?: boolean
  }

  export type LotSettingMapperCreateWithoutSettingEntryInput = {
    settingId: AddSettingCreateNestedOneWithoutSettingMapperInput
    lotId: LotInfoCreateNestedOneWithoutSettingMapperInput
    itemId?: FilingItemsCreateNestedOneWithoutLot_setting_mapperInput
  }

  export type LotSettingMapperUncheckedCreateWithoutSettingEntryInput = {
    id?: number
    setting_id: number
    lot_id: number
    filing_item_id?: number | null
  }

  export type LotSettingMapperCreateOrConnectWithoutSettingEntryInput = {
    where: LotSettingMapperWhereUniqueInput
    create: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput>
  }

  export type LotSettingMapperCreateManySettingEntryInputEnvelope = {
    data: LotSettingMapperCreateManySettingEntryInput | LotSettingMapperCreateManySettingEntryInput[]
    skipDuplicates?: boolean
  }

  export type SettingItemsCreateWithoutSettingEntryIdInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsUncheckedCreateWithoutSettingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutSettingEntryIdInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput>
  }

  export type SettingItemsCreateManySettingEntryIdInputEnvelope = {
    data: SettingItemsCreateManySettingEntryIdInput | SettingItemsCreateManySettingEntryIdInput[]
    skipDuplicates?: boolean
  }

  export type AddSettingUpsertWithoutSettingsInput = {
    update: XOR<AddSettingUpdateWithoutSettingsInput, AddSettingUncheckedUpdateWithoutSettingsInput>
    create: XOR<AddSettingCreateWithoutSettingsInput, AddSettingUncheckedCreateWithoutSettingsInput>
    where?: AddSettingWhereInput
  }

  export type AddSettingUpdateToOneWithWhereWithoutSettingsInput = {
    where?: AddSettingWhereInput
    data: XOR<AddSettingUpdateWithoutSettingsInput, AddSettingUncheckedUpdateWithoutSettingsInput>
  }

  export type AddSettingUpdateWithoutSettingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settingMapper?: LotSettingMapperUpdateManyWithoutSettingIdNestedInput
    lotInfo?: LotInfoUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type AddSettingUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingIdNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type CastingItemsUpsertWithoutSettingEntryInput = {
    update: XOR<CastingItemsUpdateWithoutSettingEntryInput, CastingItemsUncheckedUpdateWithoutSettingEntryInput>
    create: XOR<CastingItemsCreateWithoutSettingEntryInput, CastingItemsUncheckedCreateWithoutSettingEntryInput>
    where?: CastingItemsWhereInput
  }

  export type CastingItemsUpdateToOneWithWhereWithoutSettingEntryInput = {
    where?: CastingItemsWhereInput
    data: XOR<CastingItemsUpdateWithoutSettingEntryInput, CastingItemsUncheckedUpdateWithoutSettingEntryInput>
  }

  export type CastingItemsUpdateWithoutSettingEntryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutSettingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutSetting_entryInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutSetting_entryInput, FilingItemsUncheckedUpdateWithoutSetting_entryInput>
    create: XOR<FilingItemsCreateWithoutSetting_entryInput, FilingItemsUncheckedCreateWithoutSetting_entryInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutSetting_entryInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutSetting_entryInput, FilingItemsUncheckedUpdateWithoutSetting_entryInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutSetting_entryInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceUpsertWithWhereUniqueWithoutSetting_entryInput = {
    where: SettingTotalBalanceWhereUniqueInput
    update: XOR<SettingTotalBalanceUpdateWithoutSetting_entryInput, SettingTotalBalanceUncheckedUpdateWithoutSetting_entryInput>
    create: XOR<SettingTotalBalanceCreateWithoutSetting_entryInput, SettingTotalBalanceUncheckedCreateWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceUpdateWithWhereUniqueWithoutSetting_entryInput = {
    where: SettingTotalBalanceWhereUniqueInput
    data: XOR<SettingTotalBalanceUpdateWithoutSetting_entryInput, SettingTotalBalanceUncheckedUpdateWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceUpdateManyWithWhereWithoutSetting_entryInput = {
    where: SettingTotalBalanceScalarWhereInput
    data: XOR<SettingTotalBalanceUpdateManyMutationInput, SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryInput>
  }

  export type SettingTotalBalanceScalarWhereInput = {
    AND?: SettingTotalBalanceScalarWhereInput | SettingTotalBalanceScalarWhereInput[]
    OR?: SettingTotalBalanceScalarWhereInput[]
    NOT?: SettingTotalBalanceScalarWhereInput | SettingTotalBalanceScalarWhereInput[]
    id?: IntFilter<"SettingTotalBalance"> | number
    createdAt?: DateTimeFilter<"SettingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"SettingTotalBalance"> | number
    stone_count?: FloatFilter<"SettingTotalBalance"> | number
    stone_weight?: FloatFilter<"SettingTotalBalance"> | number
    remarks?: StringNullableFilter<"SettingTotalBalance"> | string | null
    wastage?: BoolFilter<"SettingTotalBalance"> | boolean
    total_product_weight?: FloatFilter<"SettingTotalBalance"> | number
    current_balance_weight?: FloatFilter<"SettingTotalBalance"> | number
    total_scrap_weight?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    balance?: FloatNullableFilter<"SettingTotalBalance"> | number | null
    setting_entry_id?: IntFilter<"SettingTotalBalance"> | number
  }

  export type SettingWastageUpsertWithWhereUniqueWithoutSettingEntryIdInput = {
    where: SettingWastageWhereUniqueInput
    update: XOR<SettingWastageUpdateWithoutSettingEntryIdInput, SettingWastageUncheckedUpdateWithoutSettingEntryIdInput>
    create: XOR<SettingWastageCreateWithoutSettingEntryIdInput, SettingWastageUncheckedCreateWithoutSettingEntryIdInput>
  }

  export type SettingWastageUpdateWithWhereUniqueWithoutSettingEntryIdInput = {
    where: SettingWastageWhereUniqueInput
    data: XOR<SettingWastageUpdateWithoutSettingEntryIdInput, SettingWastageUncheckedUpdateWithoutSettingEntryIdInput>
  }

  export type SettingWastageUpdateManyWithWhereWithoutSettingEntryIdInput = {
    where: SettingWastageScalarWhereInput
    data: XOR<SettingWastageUpdateManyMutationInput, SettingWastageUncheckedUpdateManyWithoutSettingEntryIdInput>
  }

  export type SettingWastageScalarWhereInput = {
    AND?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
    OR?: SettingWastageScalarWhereInput[]
    NOT?: SettingWastageScalarWhereInput | SettingWastageScalarWhereInput[]
    id?: IntFilter<"SettingWastage"> | number
    createdAt?: DateTimeFilter<"SettingWastage"> | Date | string
    total_receipt?: FloatFilter<"SettingWastage"> | number
    total_wastage?: FloatFilter<"SettingWastage"> | number
    balance?: FloatFilter<"SettingWastage"> | number
    wastage_percentage?: IntFilter<"SettingWastage"> | number
    given_gold?: IntNullableFilter<"SettingWastage"> | number | null
    add_wastage?: FloatNullableFilter<"SettingWastage"> | number | null
    overall_wastage?: FloatFilter<"SettingWastage"> | number
    closing_balance?: FloatFilter<"SettingWastage"> | number
    opening_balance?: FloatFilter<"SettingWastage"> | number
    setting_entry_id?: IntFilter<"SettingWastage"> | number
  }

  export type LotSettingMapperUpsertWithWhereUniqueWithoutSettingEntryInput = {
    where: LotSettingMapperWhereUniqueInput
    update: XOR<LotSettingMapperUpdateWithoutSettingEntryInput, LotSettingMapperUncheckedUpdateWithoutSettingEntryInput>
    create: XOR<LotSettingMapperCreateWithoutSettingEntryInput, LotSettingMapperUncheckedCreateWithoutSettingEntryInput>
  }

  export type LotSettingMapperUpdateWithWhereUniqueWithoutSettingEntryInput = {
    where: LotSettingMapperWhereUniqueInput
    data: XOR<LotSettingMapperUpdateWithoutSettingEntryInput, LotSettingMapperUncheckedUpdateWithoutSettingEntryInput>
  }

  export type LotSettingMapperUpdateManyWithWhereWithoutSettingEntryInput = {
    where: LotSettingMapperScalarWhereInput
    data: XOR<LotSettingMapperUpdateManyMutationInput, LotSettingMapperUncheckedUpdateManyWithoutSettingEntryInput>
  }

  export type SettingItemsUpsertWithWhereUniqueWithoutSettingEntryIdInput = {
    where: SettingItemsWhereUniqueInput
    update: XOR<SettingItemsUpdateWithoutSettingEntryIdInput, SettingItemsUncheckedUpdateWithoutSettingEntryIdInput>
    create: XOR<SettingItemsCreateWithoutSettingEntryIdInput, SettingItemsUncheckedCreateWithoutSettingEntryIdInput>
  }

  export type SettingItemsUpdateWithWhereUniqueWithoutSettingEntryIdInput = {
    where: SettingItemsWhereUniqueInput
    data: XOR<SettingItemsUpdateWithoutSettingEntryIdInput, SettingItemsUncheckedUpdateWithoutSettingEntryIdInput>
  }

  export type SettingItemsUpdateManyWithWhereWithoutSettingEntryIdInput = {
    where: SettingItemsScalarWhereInput
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyWithoutSettingEntryIdInput>
  }

  export type AddItemCreateWithoutSetting_itemsInput = {
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsCreateNestedManyWithoutItemInput
    stock?: StockCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsCreateNestedManyWithoutFilingitemInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateWithoutSetting_itemsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutItemInput
    stock?: StockUncheckedCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemCreateOrConnectWithoutSetting_itemsInput = {
    where: AddItemWhereUniqueInput
    create: XOR<AddItemCreateWithoutSetting_itemsInput, AddItemUncheckedCreateWithoutSetting_itemsInput>
  }

  export type AddTouchCreateWithoutSetting_itemsInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutSetting_itemsInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutSetting_itemsInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutSetting_itemsInput, AddTouchUncheckedCreateWithoutSetting_itemsInput>
  }

  export type SettingWastageCreateWithoutSetting_itemsInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    SettingEntryId: SettingEntryCreateNestedOneWithoutSettingWastageInput
  }

  export type SettingWastageUncheckedCreateWithoutSetting_itemsInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    setting_entry_id: number
  }

  export type SettingWastageCreateOrConnectWithoutSetting_itemsInput = {
    where: SettingWastageWhereUniqueInput
    create: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput>
  }

  export type BuffingEntryCreateWithoutSetting_itemsInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutSetting_itemsInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutSetting_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput>
  }

  export type StockCreateWithoutSettingItemInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    buffingItem?: BuffingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutSettingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutSettingItemInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput>
  }

  export type StockCreateManySettingItemInputEnvelope = {
    data: StockCreateManySettingItemInput | StockCreateManySettingItemInput[]
    skipDuplicates?: boolean
  }

  export type LotBuffingMapperCreateWithoutSettingItemIdInput = {
    buffingId: AddBuffingCreateNestedOneWithoutBuffingMapperInput
    lotId: LotInfoCreateNestedOneWithoutBuffingMapperInput
    filingItemId?: FilingItemsCreateNestedOneWithoutLotBuffingMapperInput
    buffingEntry: BuffingEntryCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput = {
    id?: number
    buffing_id: number
    lot_id: number
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotBuffingMapperCreateOrConnectWithoutSettingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    create: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput>
  }

  export type LotBuffingMapperCreateManySettingItemIdInputEnvelope = {
    data: LotBuffingMapperCreateManySettingItemIdInput | LotBuffingMapperCreateManySettingItemIdInput[]
    skipDuplicates?: boolean
  }

  export type SettingEntryCreateWithoutSettingItemsInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
  }

  export type SettingEntryUncheckedCreateWithoutSettingItemsInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
  }

  export type SettingEntryCreateOrConnectWithoutSettingItemsInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutSettingItemsInput, SettingEntryUncheckedCreateWithoutSettingItemsInput>
  }

  export type AddItemUpsertWithoutSetting_itemsInput = {
    update: XOR<AddItemUpdateWithoutSetting_itemsInput, AddItemUncheckedUpdateWithoutSetting_itemsInput>
    create: XOR<AddItemCreateWithoutSetting_itemsInput, AddItemUncheckedCreateWithoutSetting_itemsInput>
    where?: AddItemWhereInput
  }

  export type AddItemUpdateToOneWithWhereWithoutSetting_itemsInput = {
    where?: AddItemWhereInput
    data: XOR<AddItemUpdateWithoutSetting_itemsInput, AddItemUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type AddItemUpdateWithoutSetting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUpdateManyWithoutItemNestedInput
    stock?: StockUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFilingitemNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUncheckedUpdateManyWithoutItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AddTouchUpsertWithoutSetting_itemsInput = {
    update: XOR<AddTouchUpdateWithoutSetting_itemsInput, AddTouchUncheckedUpdateWithoutSetting_itemsInput>
    create: XOR<AddTouchCreateWithoutSetting_itemsInput, AddTouchUncheckedCreateWithoutSetting_itemsInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutSetting_itemsInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutSetting_itemsInput, AddTouchUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type AddTouchUpdateWithoutSetting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type SettingWastageUpsertWithWhereUniqueWithoutSetting_itemsInput = {
    where: SettingWastageWhereUniqueInput
    update: XOR<SettingWastageUpdateWithoutSetting_itemsInput, SettingWastageUncheckedUpdateWithoutSetting_itemsInput>
    create: XOR<SettingWastageCreateWithoutSetting_itemsInput, SettingWastageUncheckedCreateWithoutSetting_itemsInput>
  }

  export type SettingWastageUpdateWithWhereUniqueWithoutSetting_itemsInput = {
    where: SettingWastageWhereUniqueInput
    data: XOR<SettingWastageUpdateWithoutSetting_itemsInput, SettingWastageUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type SettingWastageUpdateManyWithWhereWithoutSetting_itemsInput = {
    where: SettingWastageScalarWhereInput
    data: XOR<SettingWastageUpdateManyMutationInput, SettingWastageUncheckedUpdateManyWithoutSetting_itemsInput>
  }

  export type BuffingEntryUpsertWithWhereUniqueWithoutSetting_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    update: XOR<BuffingEntryUpdateWithoutSetting_itemsInput, BuffingEntryUncheckedUpdateWithoutSetting_itemsInput>
    create: XOR<BuffingEntryCreateWithoutSetting_itemsInput, BuffingEntryUncheckedCreateWithoutSetting_itemsInput>
  }

  export type BuffingEntryUpdateWithWhereUniqueWithoutSetting_itemsInput = {
    where: BuffingEntryWhereUniqueInput
    data: XOR<BuffingEntryUpdateWithoutSetting_itemsInput, BuffingEntryUncheckedUpdateWithoutSetting_itemsInput>
  }

  export type BuffingEntryUpdateManyWithWhereWithoutSetting_itemsInput = {
    where: BuffingEntryScalarWhereInput
    data: XOR<BuffingEntryUpdateManyMutationInput, BuffingEntryUncheckedUpdateManyWithoutSetting_itemsInput>
  }

  export type StockUpsertWithWhereUniqueWithoutSettingItemInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutSettingItemInput, StockUncheckedUpdateWithoutSettingItemInput>
    create: XOR<StockCreateWithoutSettingItemInput, StockUncheckedCreateWithoutSettingItemInput>
  }

  export type StockUpdateWithWhereUniqueWithoutSettingItemInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutSettingItemInput, StockUncheckedUpdateWithoutSettingItemInput>
  }

  export type StockUpdateManyWithWhereWithoutSettingItemInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutSettingItemInput>
  }

  export type LotBuffingMapperUpsertWithWhereUniqueWithoutSettingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    update: XOR<LotBuffingMapperUpdateWithoutSettingItemIdInput, LotBuffingMapperUncheckedUpdateWithoutSettingItemIdInput>
    create: XOR<LotBuffingMapperCreateWithoutSettingItemIdInput, LotBuffingMapperUncheckedCreateWithoutSettingItemIdInput>
  }

  export type LotBuffingMapperUpdateWithWhereUniqueWithoutSettingItemIdInput = {
    where: LotBuffingMapperWhereUniqueInput
    data: XOR<LotBuffingMapperUpdateWithoutSettingItemIdInput, LotBuffingMapperUncheckedUpdateWithoutSettingItemIdInput>
  }

  export type LotBuffingMapperUpdateManyWithWhereWithoutSettingItemIdInput = {
    where: LotBuffingMapperScalarWhereInput
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdInput>
  }

  export type SettingEntryUpsertWithoutSettingItemsInput = {
    update: XOR<SettingEntryUpdateWithoutSettingItemsInput, SettingEntryUncheckedUpdateWithoutSettingItemsInput>
    create: XOR<SettingEntryCreateWithoutSettingItemsInput, SettingEntryUncheckedCreateWithoutSettingItemsInput>
    where?: SettingEntryWhereInput
  }

  export type SettingEntryUpdateToOneWithWhereWithoutSettingItemsInput = {
    where?: SettingEntryWhereInput
    data: XOR<SettingEntryUpdateWithoutSettingItemsInput, SettingEntryUncheckedUpdateWithoutSettingItemsInput>
  }

  export type SettingEntryUpdateWithoutSettingItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutSettingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
  }

  export type AddSettingCreateWithoutSettingMapperInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryCreateNestedManyWithoutSetting_personInput
    lotInfo?: LotInfoCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingUncheckedCreateWithoutSettingMapperInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    settings?: SettingEntryUncheckedCreateNestedManyWithoutSetting_personInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutSettingCustomerIdInput
  }

  export type AddSettingCreateOrConnectWithoutSettingMapperInput = {
    where: AddSettingWhereUniqueInput
    create: XOR<AddSettingCreateWithoutSettingMapperInput, AddSettingUncheckedCreateWithoutSettingMapperInput>
  }

  export type LotInfoCreateWithoutSettingMapperInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutSettingMapperInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutSettingMapperInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutSettingMapperInput, LotInfoUncheckedCreateWithoutSettingMapperInput>
  }

  export type FilingItemsCreateWithoutLot_setting_mapperInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutLot_setting_mapperInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutLot_setting_mapperInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutLot_setting_mapperInput, FilingItemsUncheckedCreateWithoutLot_setting_mapperInput>
  }

  export type SettingEntryCreateWithoutLotSettingMapperInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutLotSettingMapperInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutLotSettingMapperInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutLotSettingMapperInput, SettingEntryUncheckedCreateWithoutLotSettingMapperInput>
  }

  export type AddSettingUpsertWithoutSettingMapperInput = {
    update: XOR<AddSettingUpdateWithoutSettingMapperInput, AddSettingUncheckedUpdateWithoutSettingMapperInput>
    create: XOR<AddSettingCreateWithoutSettingMapperInput, AddSettingUncheckedCreateWithoutSettingMapperInput>
    where?: AddSettingWhereInput
  }

  export type AddSettingUpdateToOneWithWhereWithoutSettingMapperInput = {
    where?: AddSettingWhereInput
    data: XOR<AddSettingUpdateWithoutSettingMapperInput, AddSettingUncheckedUpdateWithoutSettingMapperInput>
  }

  export type AddSettingUpdateWithoutSettingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUpdateManyWithoutSetting_personNestedInput
    lotInfo?: LotInfoUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type AddSettingUncheckedUpdateWithoutSettingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: SettingEntryUncheckedUpdateManyWithoutSetting_personNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutSettingCustomerIdNestedInput
  }

  export type LotInfoUpsertWithoutSettingMapperInput = {
    update: XOR<LotInfoUpdateWithoutSettingMapperInput, LotInfoUncheckedUpdateWithoutSettingMapperInput>
    create: XOR<LotInfoCreateWithoutSettingMapperInput, LotInfoUncheckedCreateWithoutSettingMapperInput>
    where?: LotInfoWhereInput
  }

  export type LotInfoUpdateToOneWithWhereWithoutSettingMapperInput = {
    where?: LotInfoWhereInput
    data: XOR<LotInfoUpdateWithoutSettingMapperInput, LotInfoUncheckedUpdateWithoutSettingMapperInput>
  }

  export type LotInfoUpdateWithoutSettingMapperInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutSettingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type FilingItemsUpsertWithoutLot_setting_mapperInput = {
    update: XOR<FilingItemsUpdateWithoutLot_setting_mapperInput, FilingItemsUncheckedUpdateWithoutLot_setting_mapperInput>
    create: XOR<FilingItemsCreateWithoutLot_setting_mapperInput, FilingItemsUncheckedCreateWithoutLot_setting_mapperInput>
    where?: FilingItemsWhereInput
  }

  export type FilingItemsUpdateToOneWithWhereWithoutLot_setting_mapperInput = {
    where?: FilingItemsWhereInput
    data: XOR<FilingItemsUpdateWithoutLot_setting_mapperInput, FilingItemsUncheckedUpdateWithoutLot_setting_mapperInput>
  }

  export type FilingItemsUpdateWithoutLot_setting_mapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutLot_setting_mapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type SettingEntryUpsertWithoutLotSettingMapperInput = {
    update: XOR<SettingEntryUpdateWithoutLotSettingMapperInput, SettingEntryUncheckedUpdateWithoutLotSettingMapperInput>
    create: XOR<SettingEntryCreateWithoutLotSettingMapperInput, SettingEntryUncheckedCreateWithoutLotSettingMapperInput>
    where?: SettingEntryWhereInput
  }

  export type SettingEntryUpdateToOneWithWhereWithoutLotSettingMapperInput = {
    where?: SettingEntryWhereInput
    data: XOR<SettingEntryUpdateWithoutLotSettingMapperInput, SettingEntryUncheckedUpdateWithoutLotSettingMapperInput>
  }

  export type SettingEntryUpdateWithoutLotSettingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutLotSettingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryCreateWithoutSettingTotalBalanceInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutSettingTotalBalanceInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingWastage?: SettingWastageUncheckedCreateNestedManyWithoutSettingEntryIdInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutSettingTotalBalanceInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutSettingTotalBalanceInput, SettingEntryUncheckedCreateWithoutSettingTotalBalanceInput>
  }

  export type SettingEntryUpsertWithoutSettingTotalBalanceInput = {
    update: XOR<SettingEntryUpdateWithoutSettingTotalBalanceInput, SettingEntryUncheckedUpdateWithoutSettingTotalBalanceInput>
    create: XOR<SettingEntryCreateWithoutSettingTotalBalanceInput, SettingEntryUncheckedCreateWithoutSettingTotalBalanceInput>
    where?: SettingEntryWhereInput
  }

  export type SettingEntryUpdateToOneWithWhereWithoutSettingTotalBalanceInput = {
    where?: SettingEntryWhereInput
    data: XOR<SettingEntryUpdateWithoutSettingTotalBalanceInput, SettingEntryUncheckedUpdateWithoutSettingTotalBalanceInput>
  }

  export type SettingEntryUpdateWithoutSettingTotalBalanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutSettingTotalBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingItemsCreateWithoutSetting_wastageInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutSetting_wastageInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutSetting_wastageInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput>
  }

  export type SettingEntryCreateWithoutSettingWastageInput = {
    createdAt?: Date | string
    setting_person: AddSettingCreateNestedOneWithoutSettingsInput
    castingItem: CastingItemsCreateNestedOneWithoutSettingEntryInput
    filingItems?: FilingItemsCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceCreateNestedManyWithoutSetting_entryInput
    LotSettingMapper?: LotSettingMapperCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryUncheckedCreateWithoutSettingWastageInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
    casting_item_id: number
    filingItems?: FilingItemsUncheckedCreateNestedManyWithoutSetting_entryInput
    settingTotalBalance?: SettingTotalBalanceUncheckedCreateNestedManyWithoutSetting_entryInput
    LotSettingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutSettingEntryInput
    SettingItems?: SettingItemsUncheckedCreateNestedManyWithoutSettingEntryIdInput
  }

  export type SettingEntryCreateOrConnectWithoutSettingWastageInput = {
    where: SettingEntryWhereUniqueInput
    create: XOR<SettingEntryCreateWithoutSettingWastageInput, SettingEntryUncheckedCreateWithoutSettingWastageInput>
  }

  export type SettingItemsUpsertWithWhereUniqueWithoutSetting_wastageInput = {
    where: SettingItemsWhereUniqueInput
    update: XOR<SettingItemsUpdateWithoutSetting_wastageInput, SettingItemsUncheckedUpdateWithoutSetting_wastageInput>
    create: XOR<SettingItemsCreateWithoutSetting_wastageInput, SettingItemsUncheckedCreateWithoutSetting_wastageInput>
  }

  export type SettingItemsUpdateWithWhereUniqueWithoutSetting_wastageInput = {
    where: SettingItemsWhereUniqueInput
    data: XOR<SettingItemsUpdateWithoutSetting_wastageInput, SettingItemsUncheckedUpdateWithoutSetting_wastageInput>
  }

  export type SettingItemsUpdateManyWithWhereWithoutSetting_wastageInput = {
    where: SettingItemsScalarWhereInput
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyWithoutSetting_wastageInput>
  }

  export type SettingEntryUpsertWithoutSettingWastageInput = {
    update: XOR<SettingEntryUpdateWithoutSettingWastageInput, SettingEntryUncheckedUpdateWithoutSettingWastageInput>
    create: XOR<SettingEntryCreateWithoutSettingWastageInput, SettingEntryUncheckedCreateWithoutSettingWastageInput>
    where?: SettingEntryWhereInput
  }

  export type SettingEntryUpdateToOneWithWhereWithoutSettingWastageInput = {
    where?: SettingEntryWhereInput
    data: XOR<SettingEntryUpdateWithoutSettingWastageInput, SettingEntryUncheckedUpdateWithoutSettingWastageInput>
  }

  export type SettingEntryUpdateWithoutSettingWastageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutSettingWastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type AddBuffingCreateWithoutBuffingsInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingIdInput
    lotInfo?: LotInfoCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingUncheckedCreateWithoutBuffingsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingIdInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingCreateOrConnectWithoutBuffingsInput = {
    where: AddBuffingWhereUniqueInput
    create: XOR<AddBuffingCreateWithoutBuffingsInput, AddBuffingUncheckedCreateWithoutBuffingsInput>
  }

  export type CastingItemsCreateWithoutBuffingEntryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    stock?: StockCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutBuffingEntryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    stock?: StockUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutBuffingEntryInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutBuffingEntryInput, CastingItemsUncheckedCreateWithoutBuffingEntryInput>
  }

  export type FilingItemsCreateWithoutBuffing_entryInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutBuffing_entryInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutBuffing_entryInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput>
  }

  export type SettingItemsCreateWithoutBuffing_entryInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutBuffing_entryInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutBuffing_entryInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput>
  }

  export type BuffingTotalBalanceCreateWithoutBuffingEntryIdInput = {
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
  }

  export type BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
  }

  export type BuffingTotalBalanceCreateOrConnectWithoutBuffingEntryIdInput = {
    where: BuffingTotalBalanceWhereUniqueInput
    create: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput>
  }

  export type BuffingTotalBalanceCreateManyBuffingEntryIdInputEnvelope = {
    data: BuffingTotalBalanceCreateManyBuffingEntryIdInput | BuffingTotalBalanceCreateManyBuffingEntryIdInput[]
    skipDuplicates?: boolean
  }

  export type LotBuffingMapperCreateWithoutBuffingEntryInput = {
    buffingId: AddBuffingCreateNestedOneWithoutBuffingMapperInput
    lotId: LotInfoCreateNestedOneWithoutBuffingMapperInput
    settingItemId?: SettingItemsCreateNestedOneWithoutLotBuffingMapperInput
    filingItemId?: FilingItemsCreateNestedOneWithoutLotBuffingMapperInput
  }

  export type LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
  }

  export type LotBuffingMapperCreateOrConnectWithoutBuffingEntryInput = {
    where: LotBuffingMapperWhereUniqueInput
    create: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput>
  }

  export type LotBuffingMapperCreateManyBuffingEntryInputEnvelope = {
    data: LotBuffingMapperCreateManyBuffingEntryInput | LotBuffingMapperCreateManyBuffingEntryInput[]
    skipDuplicates?: boolean
  }

  export type BuffingItemsCreateWithoutBuffingEntryIdInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutBuffing_itemsInput
    touch: AddTouchCreateNestedOneWithoutBuffing_itemsInput
    stock?: StockCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    stock?: StockUncheckedCreateNestedManyWithoutBuffingItemInput
    buffing_wastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsCreateOrConnectWithoutBuffingEntryIdInput = {
    where: BuffingItemsWhereUniqueInput
    create: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput>
  }

  export type BuffingItemsCreateManyBuffingEntryIdInputEnvelope = {
    data: BuffingItemsCreateManyBuffingEntryIdInput | BuffingItemsCreateManyBuffingEntryIdInput[]
    skipDuplicates?: boolean
  }

  export type AddBuffingUpsertWithoutBuffingsInput = {
    update: XOR<AddBuffingUpdateWithoutBuffingsInput, AddBuffingUncheckedUpdateWithoutBuffingsInput>
    create: XOR<AddBuffingCreateWithoutBuffingsInput, AddBuffingUncheckedCreateWithoutBuffingsInput>
    where?: AddBuffingWhereInput
  }

  export type AddBuffingUpdateToOneWithWhereWithoutBuffingsInput = {
    where?: AddBuffingWhereInput
    data: XOR<AddBuffingUpdateWithoutBuffingsInput, AddBuffingUncheckedUpdateWithoutBuffingsInput>
  }

  export type AddBuffingUpdateWithoutBuffingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingIdNestedInput
    lotInfo?: LotInfoUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type AddBuffingUncheckedUpdateWithoutBuffingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type CastingItemsUpsertWithoutBuffingEntryInput = {
    update: XOR<CastingItemsUpdateWithoutBuffingEntryInput, CastingItemsUncheckedUpdateWithoutBuffingEntryInput>
    create: XOR<CastingItemsCreateWithoutBuffingEntryInput, CastingItemsUncheckedCreateWithoutBuffingEntryInput>
    where?: CastingItemsWhereInput
  }

  export type CastingItemsUpdateToOneWithWhereWithoutBuffingEntryInput = {
    where?: CastingItemsWhereInput
    data: XOR<CastingItemsUpdateWithoutBuffingEntryInput, CastingItemsUncheckedUpdateWithoutBuffingEntryInput>
  }

  export type CastingItemsUpdateWithoutBuffingEntryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutBuffingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type FilingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput = {
    where: FilingItemsWhereUniqueInput
    update: XOR<FilingItemsUpdateWithoutBuffing_entryInput, FilingItemsUncheckedUpdateWithoutBuffing_entryInput>
    create: XOR<FilingItemsCreateWithoutBuffing_entryInput, FilingItemsUncheckedCreateWithoutBuffing_entryInput>
  }

  export type FilingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput = {
    where: FilingItemsWhereUniqueInput
    data: XOR<FilingItemsUpdateWithoutBuffing_entryInput, FilingItemsUncheckedUpdateWithoutBuffing_entryInput>
  }

  export type FilingItemsUpdateManyWithWhereWithoutBuffing_entryInput = {
    where: FilingItemsScalarWhereInput
    data: XOR<FilingItemsUpdateManyMutationInput, FilingItemsUncheckedUpdateManyWithoutBuffing_entryInput>
  }

  export type SettingItemsUpsertWithWhereUniqueWithoutBuffing_entryInput = {
    where: SettingItemsWhereUniqueInput
    update: XOR<SettingItemsUpdateWithoutBuffing_entryInput, SettingItemsUncheckedUpdateWithoutBuffing_entryInput>
    create: XOR<SettingItemsCreateWithoutBuffing_entryInput, SettingItemsUncheckedCreateWithoutBuffing_entryInput>
  }

  export type SettingItemsUpdateWithWhereUniqueWithoutBuffing_entryInput = {
    where: SettingItemsWhereUniqueInput
    data: XOR<SettingItemsUpdateWithoutBuffing_entryInput, SettingItemsUncheckedUpdateWithoutBuffing_entryInput>
  }

  export type SettingItemsUpdateManyWithWhereWithoutBuffing_entryInput = {
    where: SettingItemsScalarWhereInput
    data: XOR<SettingItemsUpdateManyMutationInput, SettingItemsUncheckedUpdateManyWithoutBuffing_entryInput>
  }

  export type BuffingTotalBalanceUpsertWithWhereUniqueWithoutBuffingEntryIdInput = {
    where: BuffingTotalBalanceWhereUniqueInput
    update: XOR<BuffingTotalBalanceUpdateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedUpdateWithoutBuffingEntryIdInput>
    create: XOR<BuffingTotalBalanceCreateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedCreateWithoutBuffingEntryIdInput>
  }

  export type BuffingTotalBalanceUpdateWithWhereUniqueWithoutBuffingEntryIdInput = {
    where: BuffingTotalBalanceWhereUniqueInput
    data: XOR<BuffingTotalBalanceUpdateWithoutBuffingEntryIdInput, BuffingTotalBalanceUncheckedUpdateWithoutBuffingEntryIdInput>
  }

  export type BuffingTotalBalanceUpdateManyWithWhereWithoutBuffingEntryIdInput = {
    where: BuffingTotalBalanceScalarWhereInput
    data: XOR<BuffingTotalBalanceUpdateManyMutationInput, BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdInput>
  }

  export type BuffingTotalBalanceScalarWhereInput = {
    AND?: BuffingTotalBalanceScalarWhereInput | BuffingTotalBalanceScalarWhereInput[]
    OR?: BuffingTotalBalanceScalarWhereInput[]
    NOT?: BuffingTotalBalanceScalarWhereInput | BuffingTotalBalanceScalarWhereInput[]
    id?: IntFilter<"BuffingTotalBalance"> | number
    createdAt?: DateTimeFilter<"BuffingTotalBalance"> | Date | string
    receipt_weight?: FloatFilter<"BuffingTotalBalance"> | number
    remarks?: StringNullableFilter<"BuffingTotalBalance"> | string | null
    wastage?: BoolFilter<"BuffingTotalBalance"> | boolean
    total_scrap_weight?: FloatNullableFilter<"BuffingTotalBalance"> | number | null
    balance?: FloatFilter<"BuffingTotalBalance"> | number
    buffing_entry_id?: IntFilter<"BuffingTotalBalance"> | number
  }

  export type LotBuffingMapperUpsertWithWhereUniqueWithoutBuffingEntryInput = {
    where: LotBuffingMapperWhereUniqueInput
    update: XOR<LotBuffingMapperUpdateWithoutBuffingEntryInput, LotBuffingMapperUncheckedUpdateWithoutBuffingEntryInput>
    create: XOR<LotBuffingMapperCreateWithoutBuffingEntryInput, LotBuffingMapperUncheckedCreateWithoutBuffingEntryInput>
  }

  export type LotBuffingMapperUpdateWithWhereUniqueWithoutBuffingEntryInput = {
    where: LotBuffingMapperWhereUniqueInput
    data: XOR<LotBuffingMapperUpdateWithoutBuffingEntryInput, LotBuffingMapperUncheckedUpdateWithoutBuffingEntryInput>
  }

  export type LotBuffingMapperUpdateManyWithWhereWithoutBuffingEntryInput = {
    where: LotBuffingMapperScalarWhereInput
    data: XOR<LotBuffingMapperUpdateManyMutationInput, LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryInput>
  }

  export type BuffingItemsUpsertWithWhereUniqueWithoutBuffingEntryIdInput = {
    where: BuffingItemsWhereUniqueInput
    update: XOR<BuffingItemsUpdateWithoutBuffingEntryIdInput, BuffingItemsUncheckedUpdateWithoutBuffingEntryIdInput>
    create: XOR<BuffingItemsCreateWithoutBuffingEntryIdInput, BuffingItemsUncheckedCreateWithoutBuffingEntryIdInput>
  }

  export type BuffingItemsUpdateWithWhereUniqueWithoutBuffingEntryIdInput = {
    where: BuffingItemsWhereUniqueInput
    data: XOR<BuffingItemsUpdateWithoutBuffingEntryIdInput, BuffingItemsUncheckedUpdateWithoutBuffingEntryIdInput>
  }

  export type BuffingItemsUpdateManyWithWhereWithoutBuffingEntryIdInput = {
    where: BuffingItemsScalarWhereInput
    data: XOR<BuffingItemsUpdateManyMutationInput, BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdInput>
  }

  export type AddItemCreateWithoutBuffing_itemsInput = {
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsCreateNestedManyWithoutItemInput
    stock?: StockCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateWithoutBuffing_itemsInput = {
    id?: number
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutItemInput
    stock?: StockUncheckedCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemCreateOrConnectWithoutBuffing_itemsInput = {
    where: AddItemWhereUniqueInput
    create: XOR<AddItemCreateWithoutBuffing_itemsInput, AddItemUncheckedCreateWithoutBuffing_itemsInput>
  }

  export type AddTouchCreateWithoutBuffing_itemsInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    stock?: StockCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutBuffing_itemsInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    stock?: StockUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutBuffing_itemsInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutBuffing_itemsInput, AddTouchUncheckedCreateWithoutBuffing_itemsInput>
  }

  export type StockCreateWithoutBuffingItemInput = {
    createdAt?: Date | string
    weight: number
    item_purity: number
    remarks?: string | null
    castingItem?: CastingItemsCreateNestedOneWithoutStockInput
    filingItem?: FilingItemsCreateNestedOneWithoutStockInput
    settingItem?: SettingItemsCreateNestedOneWithoutStockInput
    item: AddItemCreateNestedOneWithoutStockInput
    touch: AddTouchCreateNestedOneWithoutStockInput
    casting_customer: AddCastingCreateNestedOneWithoutStockInput
  }

  export type StockUncheckedCreateWithoutBuffingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockCreateOrConnectWithoutBuffingItemInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput>
  }

  export type StockCreateManyBuffingItemInputEnvelope = {
    data: StockCreateManyBuffingItemInput | StockCreateManyBuffingItemInput[]
    skipDuplicates?: boolean
  }

  export type BuffingWastageCreateWithoutBuffing_itemsInput = {
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffingPersonId?: AddBuffingCreateNestedOneWithoutBuffingWastagesInput
    buffingLotId?: LotInfoCreateNestedOneWithoutBuffingWastagesInput
  }

  export type BuffingWastageUncheckedCreateWithoutBuffing_itemsInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id?: number | null
    buffing_lot_id?: number | null
  }

  export type BuffingWastageCreateOrConnectWithoutBuffing_itemsInput = {
    where: BuffingWastageWhereUniqueInput
    create: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput>
  }

  export type BuffingEntryCreateWithoutBuffingItemsInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    BuffingWastage?: BuffingWastageCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
  }

  export type BuffingEntryUncheckedCreateWithoutBuffingItemsInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    BuffingWastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
  }

  export type BuffingEntryCreateOrConnectWithoutBuffingItemsInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutBuffingItemsInput, BuffingEntryUncheckedCreateWithoutBuffingItemsInput>
  }

  export type AddItemUpsertWithoutBuffing_itemsInput = {
    update: XOR<AddItemUpdateWithoutBuffing_itemsInput, AddItemUncheckedUpdateWithoutBuffing_itemsInput>
    create: XOR<AddItemCreateWithoutBuffing_itemsInput, AddItemUncheckedCreateWithoutBuffing_itemsInput>
    where?: AddItemWhereInput
  }

  export type AddItemUpdateToOneWithWhereWithoutBuffing_itemsInput = {
    where?: AddItemWhereInput
    data: XOR<AddItemUpdateWithoutBuffing_itemsInput, AddItemUncheckedUpdateWithoutBuffing_itemsInput>
  }

  export type AddItemUpdateWithoutBuffing_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUpdateManyWithoutItemNestedInput
    stock?: StockUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateWithoutBuffing_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUncheckedUpdateManyWithoutItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AddTouchUpsertWithoutBuffing_itemsInput = {
    update: XOR<AddTouchUpdateWithoutBuffing_itemsInput, AddTouchUncheckedUpdateWithoutBuffing_itemsInput>
    create: XOR<AddTouchCreateWithoutBuffing_itemsInput, AddTouchUncheckedCreateWithoutBuffing_itemsInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutBuffing_itemsInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutBuffing_itemsInput, AddTouchUncheckedUpdateWithoutBuffing_itemsInput>
  }

  export type AddTouchUpdateWithoutBuffing_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    stock?: StockUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutBuffing_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    stock?: StockUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type StockUpsertWithWhereUniqueWithoutBuffingItemInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutBuffingItemInput, StockUncheckedUpdateWithoutBuffingItemInput>
    create: XOR<StockCreateWithoutBuffingItemInput, StockUncheckedCreateWithoutBuffingItemInput>
  }

  export type StockUpdateWithWhereUniqueWithoutBuffingItemInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutBuffingItemInput, StockUncheckedUpdateWithoutBuffingItemInput>
  }

  export type StockUpdateManyWithWhereWithoutBuffingItemInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutBuffingItemInput>
  }

  export type BuffingWastageUpsertWithWhereUniqueWithoutBuffing_itemsInput = {
    where: BuffingWastageWhereUniqueInput
    update: XOR<BuffingWastageUpdateWithoutBuffing_itemsInput, BuffingWastageUncheckedUpdateWithoutBuffing_itemsInput>
    create: XOR<BuffingWastageCreateWithoutBuffing_itemsInput, BuffingWastageUncheckedCreateWithoutBuffing_itemsInput>
  }

  export type BuffingWastageUpdateWithWhereUniqueWithoutBuffing_itemsInput = {
    where: BuffingWastageWhereUniqueInput
    data: XOR<BuffingWastageUpdateWithoutBuffing_itemsInput, BuffingWastageUncheckedUpdateWithoutBuffing_itemsInput>
  }

  export type BuffingWastageUpdateManyWithWhereWithoutBuffing_itemsInput = {
    where: BuffingWastageScalarWhereInput
    data: XOR<BuffingWastageUpdateManyMutationInput, BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsInput>
  }

  export type BuffingEntryUpsertWithoutBuffingItemsInput = {
    update: XOR<BuffingEntryUpdateWithoutBuffingItemsInput, BuffingEntryUncheckedUpdateWithoutBuffingItemsInput>
    create: XOR<BuffingEntryCreateWithoutBuffingItemsInput, BuffingEntryUncheckedCreateWithoutBuffingItemsInput>
    where?: BuffingEntryWhereInput
  }

  export type BuffingEntryUpdateToOneWithWhereWithoutBuffingItemsInput = {
    where?: BuffingEntryWhereInput
    data: XOR<BuffingEntryUpdateWithoutBuffingItemsInput, BuffingEntryUncheckedUpdateWithoutBuffingItemsInput>
  }

  export type BuffingEntryUpdateWithoutBuffingItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutBuffingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
  }

  export type BuffingEntryCreateWithoutBuffingTotalBalanceInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutBuffingTotalBalanceInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
    BuffingItems?: BuffingItemsUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutBuffingTotalBalanceInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedCreateWithoutBuffingTotalBalanceInput>
  }

  export type BuffingEntryUpsertWithoutBuffingTotalBalanceInput = {
    update: XOR<BuffingEntryUpdateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedUpdateWithoutBuffingTotalBalanceInput>
    create: XOR<BuffingEntryCreateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedCreateWithoutBuffingTotalBalanceInput>
    where?: BuffingEntryWhereInput
  }

  export type BuffingEntryUpdateToOneWithWhereWithoutBuffingTotalBalanceInput = {
    where?: BuffingEntryWhereInput
    data: XOR<BuffingEntryUpdateWithoutBuffingTotalBalanceInput, BuffingEntryUncheckedUpdateWithoutBuffingTotalBalanceInput>
  }

  export type BuffingEntryUpdateWithoutBuffingTotalBalanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutBuffingTotalBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type AddBuffingCreateWithoutBuffingMapperInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryCreateNestedManyWithoutBuffing_personInput
    lotInfo?: LotInfoCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingUncheckedCreateWithoutBuffingMapperInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    buffings?: BuffingEntryUncheckedCreateNestedManyWithoutBuffing_personInput
    lotInfo?: LotInfoUncheckedCreateNestedManyWithoutBuffingCustomerIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingPersonIdInput
  }

  export type AddBuffingCreateOrConnectWithoutBuffingMapperInput = {
    where: AddBuffingWhereUniqueInput
    create: XOR<AddBuffingCreateWithoutBuffingMapperInput, AddBuffingUncheckedCreateWithoutBuffingMapperInput>
  }

  export type LotInfoCreateWithoutBuffingMapperInput = {
    lotNumber: number
    IsActive?: boolean
    filingCustomerId?: AddFilingCreateNestedOneWithoutLotInfoInput
    settingCustomerId?: AddSettingCreateNestedOneWithoutLotInfoInput
    buffingCustomerId?: AddBuffingCreateNestedOneWithoutLotInfoInput
    filingMapper?: LotFilingMapperCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoUncheckedCreateWithoutBuffingMapperInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
    filingMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutLotIdInput
    settingMapper?: LotSettingMapperUncheckedCreateNestedManyWithoutLotIdInput
    filingWastages?: FilingWastageUncheckedCreateNestedManyWithoutFilingLotIdInput
    buffingWastages?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingLotIdInput
  }

  export type LotInfoCreateOrConnectWithoutBuffingMapperInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutBuffingMapperInput, LotInfoUncheckedCreateWithoutBuffingMapperInput>
  }

  export type SettingItemsCreateWithoutLotBuffingMapperInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    stock?: StockCreateNestedManyWithoutSettingItemInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutLotBuffingMapperInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    stock?: StockUncheckedCreateNestedManyWithoutSettingItemInput
  }

  export type SettingItemsCreateOrConnectWithoutLotBuffingMapperInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutLotBuffingMapperInput, SettingItemsUncheckedCreateWithoutLotBuffingMapperInput>
  }

  export type FilingItemsCreateWithoutLotBuffingMapperInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    stock?: StockCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutLotBuffingMapperInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    stock?: StockUncheckedCreateNestedManyWithoutFilingItemInput
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutLotBuffingMapperInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutLotBuffingMapperInput, FilingItemsUncheckedCreateWithoutLotBuffingMapperInput>
  }

  export type BuffingEntryCreateWithoutLotBuffingMapperInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    BuffingWastage?: BuffingWastageCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryUncheckedCreateWithoutLotBuffingMapperInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    BuffingWastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffingEntryIdInput
  }

  export type BuffingEntryCreateOrConnectWithoutLotBuffingMapperInput = {
    where: BuffingEntryWhereUniqueInput
    create: XOR<BuffingEntryCreateWithoutLotBuffingMapperInput, BuffingEntryUncheckedCreateWithoutLotBuffingMapperInput>
  }

  export type AddBuffingUpsertWithoutBuffingMapperInput = {
    update: XOR<AddBuffingUpdateWithoutBuffingMapperInput, AddBuffingUncheckedUpdateWithoutBuffingMapperInput>
    create: XOR<AddBuffingCreateWithoutBuffingMapperInput, AddBuffingUncheckedCreateWithoutBuffingMapperInput>
    where?: AddBuffingWhereInput
  }

  export type AddBuffingUpdateToOneWithWhereWithoutBuffingMapperInput = {
    where?: AddBuffingWhereInput
    data: XOR<AddBuffingUpdateWithoutBuffingMapperInput, AddBuffingUncheckedUpdateWithoutBuffingMapperInput>
  }

  export type AddBuffingUpdateWithoutBuffingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUpdateManyWithoutBuffing_personNestedInput
    lotInfo?: LotInfoUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type AddBuffingUncheckedUpdateWithoutBuffingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    buffings?: BuffingEntryUncheckedUpdateManyWithoutBuffing_personNestedInput
    lotInfo?: LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdNestedInput
  }

  export type LotInfoUpsertWithoutBuffingMapperInput = {
    update: XOR<LotInfoUpdateWithoutBuffingMapperInput, LotInfoUncheckedUpdateWithoutBuffingMapperInput>
    create: XOR<LotInfoCreateWithoutBuffingMapperInput, LotInfoUncheckedCreateWithoutBuffingMapperInput>
    where?: LotInfoWhereInput
  }

  export type LotInfoUpdateToOneWithWhereWithoutBuffingMapperInput = {
    where?: LotInfoWhereInput
    data: XOR<LotInfoUpdateWithoutBuffingMapperInput, LotInfoUncheckedUpdateWithoutBuffingMapperInput>
  }

  export type LotInfoUpdateWithoutBuffingMapperInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutBuffingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type SettingItemsUpsertWithoutLotBuffingMapperInput = {
    update: XOR<SettingItemsUpdateWithoutLotBuffingMapperInput, SettingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
    create: XOR<SettingItemsCreateWithoutLotBuffingMapperInput, SettingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    where?: SettingItemsWhereInput
  }

  export type SettingItemsUpdateToOneWithWhereWithoutLotBuffingMapperInput = {
    where?: SettingItemsWhereInput
    data: XOR<SettingItemsUpdateWithoutLotBuffingMapperInput, SettingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type SettingItemsUpdateWithoutLotBuffingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutLotBuffingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
  }

  export type FilingItemsUpsertWithoutLotBuffingMapperInput = {
    update: XOR<FilingItemsUpdateWithoutLotBuffingMapperInput, FilingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
    create: XOR<FilingItemsCreateWithoutLotBuffingMapperInput, FilingItemsUncheckedCreateWithoutLotBuffingMapperInput>
    where?: FilingItemsWhereInput
  }

  export type FilingItemsUpdateToOneWithWhereWithoutLotBuffingMapperInput = {
    where?: FilingItemsWhereInput
    data: XOR<FilingItemsUpdateWithoutLotBuffingMapperInput, FilingItemsUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type FilingItemsUpdateWithoutLotBuffingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutLotBuffingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type BuffingEntryUpsertWithoutLotBuffingMapperInput = {
    update: XOR<BuffingEntryUpdateWithoutLotBuffingMapperInput, BuffingEntryUncheckedUpdateWithoutLotBuffingMapperInput>
    create: XOR<BuffingEntryCreateWithoutLotBuffingMapperInput, BuffingEntryUncheckedCreateWithoutLotBuffingMapperInput>
    where?: BuffingEntryWhereInput
  }

  export type BuffingEntryUpdateToOneWithWhereWithoutLotBuffingMapperInput = {
    where?: BuffingEntryWhereInput
    data: XOR<BuffingEntryUpdateWithoutLotBuffingMapperInput, BuffingEntryUncheckedUpdateWithoutLotBuffingMapperInput>
  }

  export type BuffingEntryUpdateWithoutLotBuffingMapperInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutLotBuffingMapperInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type AddBuffingCreateWithoutBuffingWastagesInput = {
    createdAt?: Date | string
    buffing_person: AddBuffingCreateNestedOneWithoutBuffingsInput
    castingItem: CastingItemsCreateNestedOneWithoutBuffingEntryInput
    filing_items?: FilingItemsCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutBuffingEntryInput
  }

  export type AddBuffingUncheckedCreateWithoutBuffingWastagesInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
    casting_item_id: number
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutBuffing_entryInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedCreateNestedManyWithoutBuffingEntryIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutBuffingEntryInput
  }

  export type LotInfoCreateOrConnectWithoutBuffingWastagesInput = {
    where: LotInfoWhereUniqueInput
    create: XOR<LotInfoCreateWithoutBuffingWastagesInput, LotInfoUncheckedCreateWithoutBuffingWastagesInput>
  }

  export type BuffingItemsCreateWithoutBuffing_wastageInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutBuffing_itemsInput
    touch: AddTouchCreateNestedOneWithoutBuffing_itemsInput
    stock?: StockCreateNestedManyWithoutBuffingItemInput
    buffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingItemsInput
  }

  export type BuffingItemsUncheckedCreateWithoutBuffing_wastageInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
    stock?: StockUncheckedCreateNestedManyWithoutBuffingItemInput
  }

  export type BuffingItemsCreateOrConnectWithoutBuffing_wastageInput = {
    where: BuffingItemsWhereUniqueInput
    create: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput>
  }

  export type AddBuffingUpsertWithoutBuffingWastagesInput = {
    update: XOR<AddBuffingUpdateWithoutBuffingWastagesInput, AddBuffingUncheckedUpdateWithoutBuffingWastagesInput>
    create: XOR<AddBuffingCreateWithoutBuffingWastagesInput, AddBuffingUncheckedCreateWithoutBuffingWastagesInput>
    where?: AddBuffingWhereInput
  }

  export type AddBuffingUpdateToOneWithWhereWithoutBuffingWastagesInput = {
    where?: AddBuffingWhereInput
    data: XOR<AddBuffingUpdateWithoutBuffingWastagesInput, AddBuffingUncheckedUpdateWithoutBuffingWastagesInput>
  }

  export type AddBuffingUpdateWithoutBuffingWastagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
  }

  export type AddBuffingUncheckedUpdateWithoutBuffingWastagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
  }

  export type BuffingItemsUpsertWithWhereUniqueWithoutBuffing_wastageInput = {
    where: BuffingItemsWhereUniqueInput
    update: XOR<BuffingItemsUpdateWithoutBuffing_wastageInput, BuffingItemsUncheckedUpdateWithoutBuffing_wastageInput>
    create: XOR<BuffingItemsCreateWithoutBuffing_wastageInput, BuffingItemsUncheckedCreateWithoutBuffing_wastageInput>
  }

  export type BuffingItemsUpdateWithWhereUniqueWithoutBuffing_wastageInput = {
    where: BuffingItemsWhereUniqueInput
    data: XOR<BuffingItemsUpdateWithoutBuffing_wastageInput, BuffingItemsUncheckedUpdateWithoutBuffing_wastageInput>
  }

  export type BuffingItemsUpdateManyWithWhereWithoutBuffing_wastageInput = {
    where: BuffingItemsScalarWhereInput
    data: XOR<BuffingItemsUpdateManyMutationInput, BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageInput>
  }

  export type CastingItemsCreateWithoutStockInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    touch: AddTouchCreateNestedOneWithoutCasting_itemsInput
    item: AddItemCreateNestedOneWithoutCasting_itemsInput
    castingEntry: CastingEntryCreateNestedOneWithoutItemsInput
    filingEntry?: FilingEntryCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperCreateNestedManyWithoutItemIdInput
    casting_customer: AddCastingCreateNestedOneWithoutCastingitemsInput
  }

  export type CastingItemsUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
    filingEntry?: FilingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    settingEntry?: SettingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    buffingEntry?: BuffingEntryUncheckedCreateNestedManyWithoutCastingItemInput
    filingLotMapper?: LotFilingMapperUncheckedCreateNestedManyWithoutItemIdInput
  }

  export type CastingItemsCreateOrConnectWithoutStockInput = {
    where: CastingItemsWhereUniqueInput
    create: XOR<CastingItemsCreateWithoutStockInput, CastingItemsUncheckedCreateWithoutStockInput>
  }

  export type FilingItemsCreateWithoutStockInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    filing_entry: FilingEntryCreateNestedOneWithoutFilingItemsInput
    filingitem: AddItemCreateNestedOneWithoutFiling_itemsInput
    touch: AddTouchCreateNestedOneWithoutFiling_itemsInput
    setting_entry?: SettingEntryCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutFilingItemIdInput
    lotFilingMapperId?: LotFilingMapperCreateNestedOneWithoutFiling_itemsInput
  }

  export type FilingItemsUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
    setting_entry?: SettingEntryUncheckedCreateNestedManyWithoutFilingItemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutFiling_itemsInput
    filing_wastage?: FilingWastageUncheckedCreateNestedManyWithoutFiling_itemsInput
    lot_setting_mapper?: LotSettingMapperUncheckedCreateNestedManyWithoutItemIdInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutFilingItemIdInput
  }

  export type FilingItemsCreateOrConnectWithoutStockInput = {
    where: FilingItemsWhereUniqueInput
    create: XOR<FilingItemsCreateWithoutStockInput, FilingItemsUncheckedCreateWithoutStockInput>
  }

  export type SettingItemsCreateWithoutStockInput = {
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutSetting_itemsInput
    touch: AddTouchCreateNestedOneWithoutSetting_itemsInput
    setting_wastage?: SettingWastageCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryCreateNestedManyWithoutSetting_itemsInput
    LotBuffingMapper?: LotBuffingMapperCreateNestedManyWithoutSettingItemIdInput
    settingEntryId: SettingEntryCreateNestedOneWithoutSettingItemsInput
  }

  export type SettingItemsUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
    setting_wastage?: SettingWastageUncheckedCreateNestedManyWithoutSetting_itemsInput
    buffing_entry?: BuffingEntryUncheckedCreateNestedManyWithoutSetting_itemsInput
    LotBuffingMapper?: LotBuffingMapperUncheckedCreateNestedManyWithoutSettingItemIdInput
  }

  export type SettingItemsCreateOrConnectWithoutStockInput = {
    where: SettingItemsWhereUniqueInput
    create: XOR<SettingItemsCreateWithoutStockInput, SettingItemsUncheckedCreateWithoutStockInput>
  }

  export type BuffingItemsCreateWithoutStockInput = {
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    item: AddItemCreateNestedOneWithoutBuffing_itemsInput
    touch: AddTouchCreateNestedOneWithoutBuffing_itemsInput
    buffing_wastage?: BuffingWastageCreateNestedManyWithoutBuffing_itemsInput
    buffingEntryId: BuffingEntryCreateNestedOneWithoutBuffingItemsInput
  }

  export type BuffingItemsUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
    buffing_wastage?: BuffingWastageUncheckedCreateNestedManyWithoutBuffing_itemsInput
  }

  export type BuffingItemsCreateOrConnectWithoutStockInput = {
    where: BuffingItemsWhereUniqueInput
    create: XOR<BuffingItemsCreateWithoutStockInput, BuffingItemsUncheckedCreateWithoutStockInput>
  }

  export type AddItemCreateWithoutStockInput = {
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutItemInput
  }

  export type AddItemUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    name: string
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutItemInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutFilingitemInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutItemInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutItemInput
  }

  export type AddItemCreateOrConnectWithoutStockInput = {
    where: AddItemWhereUniqueInput
    create: XOR<AddItemCreateWithoutStockInput, AddItemUncheckedCreateWithoutStockInput>
  }

  export type AddTouchCreateWithoutStockInput = {
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsCreateNestedManyWithoutTouchInput
  }

  export type AddTouchUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    touch: number
    casting_entry?: CastingEntryUncheckedCreateNestedManyWithoutTouchInput
    casting_items?: CastingItemsUncheckedCreateNestedManyWithoutTouchInput
    filing_items?: FilingItemsUncheckedCreateNestedManyWithoutTouchInput
    setting_items?: SettingItemsUncheckedCreateNestedManyWithoutTouchInput
    buffing_items?: BuffingItemsUncheckedCreateNestedManyWithoutTouchInput
  }

  export type AddTouchCreateOrConnectWithoutStockInput = {
    where: AddTouchWhereUniqueInput
    create: XOR<AddTouchCreateWithoutStockInput, AddTouchUncheckedCreateWithoutStockInput>
  }

  export type AddCastingCreateWithoutStockInput = {
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryCreateNestedManyWithoutCasting_customerInput
    castingitems?: CastingItemsCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingUncheckedCreateWithoutStockInput = {
    id?: number
    createdAt?: Date | string
    name: string
    phoneNumber?: string | null
    address?: string | null
    email?: string | null
    entries?: CastingEntryUncheckedCreateNestedManyWithoutCasting_customerInput
    castingitems?: CastingItemsUncheckedCreateNestedManyWithoutCasting_customerInput
  }

  export type AddCastingCreateOrConnectWithoutStockInput = {
    where: AddCastingWhereUniqueInput
    create: XOR<AddCastingCreateWithoutStockInput, AddCastingUncheckedCreateWithoutStockInput>
  }

  export type CastingItemsUpsertWithoutStockInput = {
    update: XOR<CastingItemsUpdateWithoutStockInput, CastingItemsUncheckedUpdateWithoutStockInput>
    create: XOR<CastingItemsCreateWithoutStockInput, CastingItemsUncheckedCreateWithoutStockInput>
    where?: CastingItemsWhereInput
  }

  export type CastingItemsUpdateToOneWithWhereWithoutStockInput = {
    where?: CastingItemsWhereInput
    data: XOR<CastingItemsUpdateWithoutStockInput, CastingItemsUncheckedUpdateWithoutStockInput>
  }

  export type CastingItemsUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type FilingItemsUpsertWithoutStockInput = {
    update: XOR<FilingItemsUpdateWithoutStockInput, FilingItemsUncheckedUpdateWithoutStockInput>
    create: XOR<FilingItemsCreateWithoutStockInput, FilingItemsUncheckedCreateWithoutStockInput>
    where?: FilingItemsWhereInput
  }

  export type FilingItemsUpdateToOneWithWhereWithoutStockInput = {
    where?: FilingItemsWhereInput
    data: XOR<FilingItemsUpdateWithoutStockInput, FilingItemsUncheckedUpdateWithoutStockInput>
  }

  export type FilingItemsUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type SettingItemsUpsertWithoutStockInput = {
    update: XOR<SettingItemsUpdateWithoutStockInput, SettingItemsUncheckedUpdateWithoutStockInput>
    create: XOR<SettingItemsCreateWithoutStockInput, SettingItemsUncheckedCreateWithoutStockInput>
    where?: SettingItemsWhereInput
  }

  export type SettingItemsUpdateToOneWithWhereWithoutStockInput = {
    where?: SettingItemsWhereInput
    data: XOR<SettingItemsUpdateWithoutStockInput, SettingItemsUncheckedUpdateWithoutStockInput>
  }

  export type SettingItemsUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type BuffingItemsUpsertWithoutStockInput = {
    update: XOR<BuffingItemsUpdateWithoutStockInput, BuffingItemsUncheckedUpdateWithoutStockInput>
    create: XOR<BuffingItemsCreateWithoutStockInput, BuffingItemsUncheckedCreateWithoutStockInput>
    where?: BuffingItemsWhereInput
  }

  export type BuffingItemsUpdateToOneWithWhereWithoutStockInput = {
    where?: BuffingItemsWhereInput
    data: XOR<BuffingItemsUpdateWithoutStockInput, BuffingItemsUncheckedUpdateWithoutStockInput>
  }

  export type BuffingItemsUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput
    buffing_wastage?: BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput
    buffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
    buffing_wastage?: BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type AddItemUpsertWithoutStockInput = {
    update: XOR<AddItemUpdateWithoutStockInput, AddItemUncheckedUpdateWithoutStockInput>
    create: XOR<AddItemCreateWithoutStockInput, AddItemUncheckedCreateWithoutStockInput>
    where?: AddItemWhereInput
  }

  export type AddItemUpdateToOneWithWhereWithoutStockInput = {
    where?: AddItemWhereInput
    data: XOR<AddItemUpdateWithoutStockInput, AddItemUncheckedUpdateWithoutStockInput>
  }

  export type AddItemUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutItemNestedInput
  }

  export type AddItemUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    casting_items?: CastingItemsUncheckedUpdateManyWithoutItemNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFilingitemNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutItemNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type AddTouchUpsertWithoutStockInput = {
    update: XOR<AddTouchUpdateWithoutStockInput, AddTouchUncheckedUpdateWithoutStockInput>
    create: XOR<AddTouchCreateWithoutStockInput, AddTouchUncheckedCreateWithoutStockInput>
    where?: AddTouchWhereInput
  }

  export type AddTouchUpdateToOneWithWhereWithoutStockInput = {
    where?: AddTouchWhereInput
    data: XOR<AddTouchUpdateWithoutStockInput, AddTouchUncheckedUpdateWithoutStockInput>
  }

  export type AddTouchUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutTouchNestedInput
  }

  export type AddTouchUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    touch?: FloatFieldUpdateOperationsInput | number
    casting_entry?: CastingEntryUncheckedUpdateManyWithoutTouchNestedInput
    casting_items?: CastingItemsUncheckedUpdateManyWithoutTouchNestedInput
    filing_items?: FilingItemsUncheckedUpdateManyWithoutTouchNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutTouchNestedInput
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutTouchNestedInput
  }

  export type AddCastingUpsertWithoutStockInput = {
    update: XOR<AddCastingUpdateWithoutStockInput, AddCastingUncheckedUpdateWithoutStockInput>
    create: XOR<AddCastingCreateWithoutStockInput, AddCastingUncheckedCreateWithoutStockInput>
    where?: AddCastingWhereInput
  }

  export type AddCastingUpdateToOneWithWhereWithoutStockInput = {
    where?: AddCastingWhereInput
    data: XOR<AddCastingUpdateWithoutStockInput, AddCastingUncheckedUpdateWithoutStockInput>
  }

  export type AddCastingUpdateWithoutStockInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUpdateManyWithoutCasting_customerNestedInput
    castingitems?: CastingItemsUpdateManyWithoutCasting_customerNestedInput
  }

  export type AddCastingUncheckedUpdateWithoutStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: CastingEntryUncheckedUpdateManyWithoutCasting_customerNestedInput
    castingitems?: CastingItemsUncheckedUpdateManyWithoutCasting_customerNestedInput
  }

  export type CustomerTransactionCreateManyCustomerInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    value: number
    type: string
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
  }

  export type CustomerTransactionUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CastingEntryCreateManyCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    touch_id: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
  }

  export type CastingItemsCreateManyCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
  }

  export type StockCreateManyCasting_customerInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
  }

  export type CastingEntryUpdateWithoutCasting_customerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    touch?: AddTouchUpdateOneRequiredWithoutCasting_entryNestedInput
    items?: CastingItemsUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    items?: CastingItemsUncheckedUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateManyWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
  }

  export type CastingItemsUpdateWithoutCasting_customerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsUncheckedUpdateManyWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUpdateWithoutCasting_customerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockUncheckedUpdateManyWithoutCasting_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FilingWastageCreateManyFilingPersonIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_lot_id?: number | null
  }

  export type FilingEntryCreateManyFiling_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
  }

  export type LotInfoCreateManyFilingCustomerIdInput = {
    id?: number
    lotNumber: number
    setting_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
  }

  export type LotFilingMapperCreateManyFilingIdInput = {
    id?: number
    lot_id: number
    item_id: number
    filing_entry_id: number
  }

  export type FilingWastageUpdateWithoutFilingPersonIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filingLotId?: LotInfoUpdateOneWithoutFilingWastagesNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageUncheckedUpdateWithoutFilingPersonIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageUncheckedUpdateManyWithoutFilingPersonIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilingEntryUpdateWithoutFiling_personInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    castingItem?: CastingItemsUpdateOneRequiredWithoutFilingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateWithoutFiling_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateManyWithoutFiling_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotInfoUpdateWithoutFilingCustomerIdInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutFilingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateManyWithoutFilingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LotFilingMapperUpdateWithoutFilingIdInput = {
    lotId?: LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput
    itemId?: CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput
    filing_items?: FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput
    filingEntry?: FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput
  }

  export type LotFilingMapperUncheckedUpdateWithoutFilingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutFilingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingEntryCreateManySetting_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
  }

  export type LotSettingMapperCreateManySettingIdInput = {
    id?: number
    lot_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotInfoCreateManySettingCustomerIdInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    buffing_customer_id?: number | null
    IsActive?: boolean
  }

  export type SettingEntryUpdateWithoutSetting_personInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutSetting_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateManyWithoutSetting_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUpdateWithoutSettingIdInput = {
    lotId?: LotInfoUpdateOneRequiredWithoutSettingMapperNestedInput
    itemId?: FilingItemsUpdateOneWithoutLot_setting_mapperNestedInput
    settingEntry?: SettingEntryUpdateOneRequiredWithoutLotSettingMapperNestedInput
  }

  export type LotSettingMapperUncheckedUpdateWithoutSettingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutSettingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotInfoUpdateWithoutSettingCustomerIdInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    buffingCustomerId?: AddBuffingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutSettingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateManyWithoutSettingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuffingEntryCreateManyBuffing_personInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id: number
  }

  export type LotBuffingMapperCreateManyBuffingIdInput = {
    id?: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type LotInfoCreateManyBuffingCustomerIdInput = {
    id?: number
    lotNumber: number
    filing_customer_id?: number | null
    setting_customer_id?: number | null
    IsActive?: boolean
  }

  export type BuffingWastageCreateManyBuffingPersonIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_lot_id?: number | null
  }

  export type BuffingEntryUpdateWithoutBuffing_personInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutBuffing_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateManyWithoutBuffing_personInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUpdateWithoutBuffingIdInput = {
    lotId?: LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput
    settingItemId?: SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    filingItemId?: FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    buffingEntry?: BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateWithoutBuffingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutBuffingIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotInfoUpdateWithoutBuffingCustomerIdInput = {
    lotNumber?: IntFieldUpdateOperationsInput | number
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingCustomerId?: AddFilingUpdateOneWithoutLotInfoNestedInput
    settingCustomerId?: AddSettingUpdateOneWithoutLotInfoNestedInput
    filingMapper?: LotFilingMapperUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateWithoutBuffingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    filingMapper?: LotFilingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    settingMapper?: LotSettingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    buffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutLotIdNestedInput
    filingWastages?: FilingWastageUncheckedUpdateManyWithoutFilingLotIdNestedInput
    buffingWastages?: BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdNestedInput
  }

  export type LotInfoUncheckedUpdateManyWithoutBuffingCustomerIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    lotNumber?: IntFieldUpdateOperationsInput | number
    filing_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BuffingWastageUpdateWithoutBuffingPersonIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffingLotId?: LotInfoUpdateOneWithoutBuffingWastagesNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageUncheckedUpdateWithoutBuffingPersonIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffingPersonIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CastingItemsCreateManyItemInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
  }

  export type StockCreateManyItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type FilingItemsCreateManyFilingitemInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
  }

  export type SettingItemsCreateManyItemInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
  }

  export type BuffingItemsCreateManyItemInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
  }

  export type CastingItemsUpdateWithoutItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUpdateWithoutItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingItemsUpdateWithoutFilingitemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutFilingitemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutFilingitemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingItemsUpdateWithoutItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingItemsUpdateWithoutItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput
    stock?: StockUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput
    buffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
    stock?: StockUncheckedUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastingEntryCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    date: Date | string
    given_gold: number
    purity: number
    final_touch: number
    pure_value: number
    copper: number
    final_weight: number
    casting_customer_id: number
  }

  export type CastingItemsCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    casting_entry_id: number
    casting_customer_id: number
  }

  export type FilingItemsCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
  }

  export type SettingItemsCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    setting_entry_id: number
  }

  export type BuffingItemsCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    item_purity: number
    scrap_remarks?: string | null
    buffing_entry_id: number
  }

  export type StockCreateManyTouchInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type CastingEntryUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer?: AddCastingUpdateOneRequiredWithoutEntriesNestedInput
    items?: CastingItemsUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    items?: CastingItemsUncheckedUpdateManyWithoutCastingEntryNestedInput
    CastiingTotalBalance?: CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idNestedInput
  }

  export type CastingEntryUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    given_gold?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    final_touch?: FloatFieldUpdateOperationsInput | number
    pure_value?: FloatFieldUpdateOperationsInput | number
    copper?: FloatFieldUpdateOperationsInput | number
    final_weight?: FloatFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastingItemsUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    castingEntry?: CastingEntryUpdateOneRequiredWithoutItemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_entry_id?: IntFieldUpdateOperationsInput | number
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingItemsUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingItemsUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingItemsUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput
    stock?: StockUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput
    buffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
    stock?: StockUncheckedUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUpdateWithoutTouchInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastingItemsCreateManyCastingEntryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type CastiingTotalBalanceCreateManyItem_entry_idInput = {
    id?: number
    createdAt?: Date | string
    total_item_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    total_wastage: number
  }

  export type CastingItemsUpdateWithoutCastingEntryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    touch?: AddTouchUpdateOneRequiredWithoutCasting_itemsNestedInput
    item?: AddItemUpdateOneRequiredWithoutCasting_itemsNestedInput
    filingEntry?: FilingEntryUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUpdateManyWithoutCastingItemNestedInput
    stock?: StockUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUpdateManyWithoutItemIdNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutCastingitemsNestedInput
  }

  export type CastingItemsUncheckedUpdateWithoutCastingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
    filingEntry?: FilingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    settingEntry?: SettingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    buffingEntry?: BuffingEntryUncheckedUpdateManyWithoutCastingItemNestedInput
    stock?: StockUncheckedUpdateManyWithoutCastingItemNestedInput
    filingLotMapper?: LotFilingMapperUncheckedUpdateManyWithoutItemIdNestedInput
  }

  export type CastingItemsUncheckedUpdateManyWithoutCastingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceUpdateWithoutItem_entry_idInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceUncheckedUpdateWithoutItem_entry_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
  }

  export type CastiingTotalBalanceUncheckedUpdateManyWithoutItem_entry_idInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_item_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_wastage?: FloatFieldUpdateOperationsInput | number
  }

  export type FilingEntryCreateManyCastingItemInput = {
    id?: number
    createdAt?: Date | string
    filing_person_id: number
  }

  export type SettingEntryCreateManyCastingItemInput = {
    id?: number
    createdAt?: Date | string
    setting_person_id: number
  }

  export type BuffingEntryCreateManyCastingItemInput = {
    id?: number
    createdAt?: Date | string
    buffing_person_id: number
  }

  export type StockCreateManyCastingItemInput = {
    id?: number
    createdAt?: Date | string
    filing_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type LotFilingMapperCreateManyItemIdInput = {
    id?: number
    filing_id: number
    lot_id: number
    filing_entry_id: number
  }

  export type FilingEntryUpdateWithoutCastingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person?: AddFilingUpdateOneRequiredWithoutFilingsNestedInput
    filingItems?: FilingItemsUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutFiling_entryNestedInput
    filingTotalBalance?: FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdNestedInput
    LotFilingMapper?: LotFilingMapperUncheckedUpdateManyWithoutFilingEntryNestedInput
  }

  export type FilingEntryUncheckedUpdateManyWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_person_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingEntryUpdateWithoutCastingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    filingItems?: FilingItemsUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    filingItems?: FilingItemsUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateManyWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingEntryUpdateWithoutCastingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    BuffingWastage?: BuffingWastageUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateManyWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUpdateWithoutCastingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutCastingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotFilingMapperUpdateWithoutItemIdInput = {
    filingId?: AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput
    filing_items?: FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput
    filingEntry?: FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput
  }

  export type LotFilingMapperUncheckedUpdateWithoutItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotFilingMapperCreateManyLotIdInput = {
    id?: number
    filing_id: number
    item_id: number
    filing_entry_id: number
  }

  export type LotSettingMapperCreateManyLotIdInput = {
    id?: number
    setting_id: number
    filing_item_id?: number | null
    setting_entry_id: number
  }

  export type LotBuffingMapperCreateManyLotIdInput = {
    id?: number
    buffing_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type FilingWastageCreateManyFilingLotIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    filing_person_id?: number | null
  }

  export type BuffingWastageCreateManyBuffingLotIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
    buffing_person_id?: number | null
  }

  export type LotFilingMapperUpdateWithoutLotIdInput = {
    filingId?: AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput
    itemId?: CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput
    filing_items?: FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput
    filingEntry?: FilingEntryUpdateOneRequiredWithoutLotFilingMapperNestedInput
  }

  export type LotFilingMapperUncheckedUpdateWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUpdateWithoutLotIdInput = {
    settingId?: AddSettingUpdateOneRequiredWithoutSettingMapperNestedInput
    itemId?: FilingItemsUpdateOneWithoutLot_setting_mapperNestedInput
    settingEntry?: SettingEntryUpdateOneRequiredWithoutLotSettingMapperNestedInput
  }

  export type LotSettingMapperUncheckedUpdateWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUpdateWithoutLotIdInput = {
    buffingId?: AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput
    settingItemId?: SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    filingItemId?: FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    buffingEntry?: BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingWastageUpdateWithoutFilingLotIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filingPersonId?: AddFilingUpdateOneWithoutFilingWastagesNestedInput
    filing_items?: FilingItemsUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageUncheckedUpdateWithoutFilingLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_items?: FilingItemsUncheckedUpdateManyWithoutFiling_wastageNestedInput
  }

  export type FilingWastageUncheckedUpdateManyWithoutFilingLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuffingWastageUpdateWithoutBuffingLotIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffingPersonId?: AddBuffingUpdateOneWithoutBuffingWastagesNestedInput
    buffing_items?: BuffingItemsUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageUncheckedUpdateWithoutBuffingLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_items?: BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageNestedInput
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffingLotIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilingItemsCreateManyFiling_entryInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
    lot_filing_mapper_id?: number | null
  }

  export type FilingTotalBalanceCreateManyFilingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    after_weight?: number | null
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    wastage: boolean
    balance: number
  }

  export type LotFilingMapperCreateManyFilingEntryInput = {
    id?: number
    filing_id: number
    lot_id: number
    item_id: number
  }

  export type FilingItemsUpdateWithoutFiling_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutFiling_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutFiling_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilingTotalBalanceUpdateWithoutFilingEntryIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type FilingTotalBalanceUncheckedUpdateWithoutFilingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type FilingTotalBalanceUncheckedUpdateManyWithoutFilingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    after_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type LotFilingMapperUpdateWithoutFilingEntryInput = {
    filingId?: AddFilingUpdateOneRequiredWithoutLotFilingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutFilingMapperNestedInput
    itemId?: CastingItemsUpdateOneRequiredWithoutFilingLotMapperNestedInput
    filing_items?: FilingItemsUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperUncheckedUpdateWithoutFilingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdNestedInput
  }

  export type LotFilingMapperUncheckedUpdateManyWithoutFilingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    filing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingItemsCreateManyLotFilingMapperIdInput = {
    id?: number
    createdAt?: Date | string
    filing_entry_id: number
    type: $Enums.CASTINGENTRYTYPE
    filing_item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    stone_option?: $Enums.STONEOPTION | null
  }

  export type FilingItemsUpdateWithoutLotFilingMapperIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutLotFilingMapperIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutLotFilingMapperIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
  }

  export type StockCreateManyFilingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    setting_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type LotSettingMapperCreateManyItemIdInput = {
    id?: number
    setting_id: number
    lot_id: number
    setting_entry_id: number
  }

  export type LotBuffingMapperCreateManyFilingItemIdInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    buffing_entry_id: number
  }

  export type StockUpdateWithoutFilingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutFilingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutFilingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingEntryUpdateWithoutFilingItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person?: AddSettingUpdateOneRequiredWithoutSettingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutSettingEntryNestedInput
    settingTotalBalance?: SettingTotalBalanceUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateWithoutFilingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    settingTotalBalance?: SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryNestedInput
    settingWastage?: SettingWastageUncheckedUpdateManyWithoutSettingEntryIdNestedInput
    LotSettingMapper?: LotSettingMapperUncheckedUpdateManyWithoutSettingEntryNestedInput
    SettingItems?: SettingItemsUncheckedUpdateManyWithoutSettingEntryIdNestedInput
  }

  export type SettingEntryUncheckedUpdateManyWithoutFilingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingEntryUpdateWithoutFiling_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    setting_items?: SettingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    setting_items?: SettingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateManyWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingWastageUpdateWithoutFiling_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filingPersonId?: AddFilingUpdateOneWithoutFilingWastagesNestedInput
    filingLotId?: LotInfoUpdateOneWithoutFilingWastagesNestedInput
  }

  export type FilingWastageUncheckedUpdateWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FilingWastageUncheckedUpdateManyWithoutFiling_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    filing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LotSettingMapperUpdateWithoutItemIdInput = {
    settingId?: AddSettingUpdateOneRequiredWithoutSettingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutSettingMapperNestedInput
    settingEntry?: SettingEntryUpdateOneRequiredWithoutLotSettingMapperNestedInput
  }

  export type LotSettingMapperUncheckedUpdateWithoutItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUpdateWithoutFilingItemIdInput = {
    buffingId?: AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput
    settingItemId?: SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    buffingEntry?: BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateWithoutFilingItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type FilingItemsUpdateWithoutFiling_wastageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutFiling_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutFiling_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingTotalBalanceCreateManySetting_entryInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    stone_count: number
    stone_weight: number
    remarks?: string | null
    wastage: boolean
    total_product_weight: number
    current_balance_weight: number
    total_scrap_weight?: number | null
    balance?: number | null
  }

  export type SettingWastageCreateManySettingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    total_receipt: number
    total_wastage: number
    balance: number
    wastage_percentage: number
    given_gold?: number | null
    add_wastage?: number | null
    overall_wastage: number
    closing_balance: number
    opening_balance: number
  }

  export type LotSettingMapperCreateManySettingEntryInput = {
    id?: number
    setting_id: number
    lot_id: number
    filing_item_id?: number | null
  }

  export type SettingItemsCreateManySettingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    type?: $Enums.CASTINGENTRYTYPE | null
    setting_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
  }

  export type FilingItemsUpdateWithoutSetting_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutSetting_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutFiling_itemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutSetting_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingTotalBalanceUpdateWithoutSetting_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SettingTotalBalanceUncheckedUpdateWithoutSetting_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SettingTotalBalanceUncheckedUpdateManyWithoutSetting_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    stone_count?: FloatFieldUpdateOperationsInput | number
    stone_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_product_weight?: FloatFieldUpdateOperationsInput | number
    current_balance_weight?: FloatFieldUpdateOperationsInput | number
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SettingWastageUpdateWithoutSettingEntryIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_items?: SettingItemsUpdateManyWithoutSetting_wastageNestedInput
  }

  export type SettingWastageUncheckedUpdateWithoutSettingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_items?: SettingItemsUncheckedUpdateManyWithoutSetting_wastageNestedInput
  }

  export type SettingWastageUncheckedUpdateManyWithoutSettingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
  }

  export type LotSettingMapperUpdateWithoutSettingEntryInput = {
    settingId?: AddSettingUpdateOneRequiredWithoutSettingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutSettingMapperNestedInput
    itemId?: FilingItemsUpdateOneWithoutLot_setting_mapperNestedInput
  }

  export type LotSettingMapperUncheckedUpdateWithoutSettingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LotSettingMapperUncheckedUpdateManyWithoutSettingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    setting_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingItemsUpdateWithoutSettingEntryIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutSettingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateManyWithoutSettingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockCreateManySettingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    buffing_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type LotBuffingMapperCreateManySettingItemIdInput = {
    id?: number
    buffing_id: number
    lot_id: number
    filing_item_id?: number | null
    buffing_entry_id: number
  }

  export type SettingWastageUpdateWithoutSetting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    SettingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingWastageNestedInput
  }

  export type SettingWastageUncheckedUpdateWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingWastageUncheckedUpdateManyWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableIntFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingEntryUpdateWithoutSetting_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person?: AddBuffingUpdateOneRequiredWithoutBuffingsNestedInput
    castingItem?: CastingItemsUpdateOneRequiredWithoutBuffingEntryNestedInput
    filing_items?: FilingItemsUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
    filing_items?: FilingItemsUncheckedUpdateManyWithoutBuffing_entryNestedInput
    BuffingTotalBalance?: BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryNestedInput
    BuffingItems?: BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdNestedInput
  }

  export type BuffingEntryUncheckedUpdateManyWithoutSetting_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buffing_person_id?: IntFieldUpdateOperationsInput | number
    casting_item_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUpdateWithoutSettingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    buffingItem?: BuffingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutSettingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutSettingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUpdateWithoutSettingItemIdInput = {
    buffingId?: AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput
    filingItemId?: FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    buffingEntry?: BuffingEntryUpdateOneRequiredWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateWithoutSettingItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type SettingItemsUpdateWithoutSetting_wastageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    buffing_entry?: BuffingEntryUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutSetting_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    buffing_entry?: BuffingEntryUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateManyWithoutSetting_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceCreateManyBuffingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    receipt_weight: number
    remarks?: string | null
    wastage: boolean
    total_scrap_weight?: number | null
    balance: number
  }

  export type LotBuffingMapperCreateManyBuffingEntryInput = {
    id?: number
    buffing_id: number
    lot_id: number
    setting_item_id?: number | null
    filing_item_id?: number | null
  }

  export type BuffingItemsCreateManyBuffingEntryIdInput = {
    id?: number
    createdAt?: Date | string
    type: $Enums.CASTINGENTRYTYPE
    buffing_item_id: number
    scrap_weight: number
    touch_id: number
    item_purity: number
    scrap_remarks?: string | null
  }

  export type FilingItemsUpdateWithoutBuffing_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    filing_entry?: FilingEntryUpdateOneRequiredWithoutFilingItemsNestedInput
    filingitem?: AddItemUpdateOneRequiredWithoutFiling_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutFiling_itemsNestedInput
    stock?: StockUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUpdateManyWithoutFilingItemsNestedInput
    filing_wastage?: FilingWastageUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutFilingItemIdNestedInput
    lotFilingMapperId?: LotFilingMapperUpdateOneWithoutFiling_itemsNestedInput
  }

  export type FilingItemsUncheckedUpdateWithoutBuffing_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: StockUncheckedUpdateManyWithoutFilingItemNestedInput
    setting_entry?: SettingEntryUncheckedUpdateManyWithoutFilingItemsNestedInput
    filing_wastage?: FilingWastageUncheckedUpdateManyWithoutFiling_itemsNestedInput
    lot_setting_mapper?: LotSettingMapperUncheckedUpdateManyWithoutItemIdNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutFilingItemIdNestedInput
  }

  export type FilingItemsUncheckedUpdateManyWithoutBuffing_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filing_entry_id?: IntFieldUpdateOperationsInput | number
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    filing_item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stone_option?: NullableEnumSTONEOPTIONFieldUpdateOperationsInput | $Enums.STONEOPTION | null
    lot_filing_mapper_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingItemsUpdateWithoutBuffing_entryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutSetting_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutSetting_itemsNestedInput
    setting_wastage?: SettingWastageUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUpdateManyWithoutSettingItemIdNestedInput
    settingEntryId?: SettingEntryUpdateOneRequiredWithoutSettingItemsNestedInput
  }

  export type SettingItemsUncheckedUpdateWithoutBuffing_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
    setting_wastage?: SettingWastageUncheckedUpdateManyWithoutSetting_itemsNestedInput
    stock?: StockUncheckedUpdateManyWithoutSettingItemNestedInput
    LotBuffingMapper?: LotBuffingMapperUncheckedUpdateManyWithoutSettingItemIdNestedInput
  }

  export type SettingItemsUncheckedUpdateManyWithoutBuffing_entryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE | null
    setting_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    setting_entry_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceUpdateWithoutBuffingEntryIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceUncheckedUpdateWithoutBuffingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type BuffingTotalBalanceUncheckedUpdateManyWithoutBuffingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt_weight?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    wastage?: BoolFieldUpdateOperationsInput | boolean
    total_scrap_weight?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: FloatFieldUpdateOperationsInput | number
  }

  export type LotBuffingMapperUpdateWithoutBuffingEntryInput = {
    buffingId?: AddBuffingUpdateOneRequiredWithoutBuffingMapperNestedInput
    lotId?: LotInfoUpdateOneRequiredWithoutBuffingMapperNestedInput
    settingItemId?: SettingItemsUpdateOneWithoutLotBuffingMapperNestedInput
    filingItemId?: FilingItemsUpdateOneWithoutLotBuffingMapperNestedInput
  }

  export type LotBuffingMapperUncheckedUpdateWithoutBuffingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LotBuffingMapperUncheckedUpdateManyWithoutBuffingEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    buffing_id?: IntFieldUpdateOperationsInput | number
    lot_id?: IntFieldUpdateOperationsInput | number
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuffingItemsUpdateWithoutBuffingEntryIdInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput
    stock?: StockUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateWithoutBuffingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: StockUncheckedUpdateManyWithoutBuffingItemNestedInput
    buffing_wastage?: BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateManyWithoutBuffingEntryIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockCreateManyBuffingItemInput = {
    id?: number
    createdAt?: Date | string
    casting_item_id?: number | null
    filing_item_id?: number | null
    setting_item_id?: number | null
    item_id: number
    weight: number
    touch_id: number
    item_purity: number
    remarks?: string | null
    casting_customer_id: number
  }

  export type StockUpdateWithoutBuffingItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    castingItem?: CastingItemsUpdateOneWithoutStockNestedInput
    filingItem?: FilingItemsUpdateOneWithoutStockNestedInput
    settingItem?: SettingItemsUpdateOneWithoutStockNestedInput
    item?: AddItemUpdateOneRequiredWithoutStockNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutStockNestedInput
    casting_customer?: AddCastingUpdateOneRequiredWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutBuffingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type StockUncheckedUpdateManyWithoutBuffingItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    casting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    filing_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    setting_item_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    casting_customer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BuffingWastageUpdateWithoutBuffing_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffingPersonId?: AddBuffingUpdateOneWithoutBuffingWastagesNestedInput
    buffingLotId?: LotInfoUpdateOneWithoutBuffingWastagesNestedInput
  }

  export type BuffingWastageUncheckedUpdateWithoutBuffing_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuffingWastageUncheckedUpdateManyWithoutBuffing_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    total_receipt?: FloatFieldUpdateOperationsInput | number
    total_wastage?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    wastage_percentage?: IntFieldUpdateOperationsInput | number
    given_gold?: NullableFloatFieldUpdateOperationsInput | number | null
    add_wastage?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_wastage?: FloatFieldUpdateOperationsInput | number
    closing_balance?: FloatFieldUpdateOperationsInput | number
    opening_balance?: FloatFieldUpdateOperationsInput | number
    buffing_person_id?: NullableIntFieldUpdateOperationsInput | number | null
    buffing_lot_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuffingItemsUpdateWithoutBuffing_wastageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    item?: AddItemUpdateOneRequiredWithoutBuffing_itemsNestedInput
    touch?: AddTouchUpdateOneRequiredWithoutBuffing_itemsNestedInput
    stock?: StockUpdateManyWithoutBuffingItemNestedInput
    buffingEntryId?: BuffingEntryUpdateOneRequiredWithoutBuffingItemsNestedInput
  }

  export type BuffingItemsUncheckedUpdateWithoutBuffing_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
    stock?: StockUncheckedUpdateManyWithoutBuffingItemNestedInput
  }

  export type BuffingItemsUncheckedUpdateManyWithoutBuffing_wastageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCASTINGENTRYTYPEFieldUpdateOperationsInput | $Enums.CASTINGENTRYTYPE
    buffing_item_id?: IntFieldUpdateOperationsInput | number
    scrap_weight?: FloatFieldUpdateOperationsInput | number
    touch_id?: IntFieldUpdateOperationsInput | number
    item_purity?: FloatFieldUpdateOperationsInput | number
    scrap_remarks?: NullableStringFieldUpdateOperationsInput | string | null
    buffing_entry_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}